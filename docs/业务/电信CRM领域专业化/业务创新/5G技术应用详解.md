# 5G技术应用详解

## 概述

5G（第五代移动通信技术）作为新一代移动通信技术，为电信行业带来了革命性的变化。本文档详细阐述5G技术在NSRS号卡资源管理系统中的应用，包括5G网络切片、边缘计算、超低延迟通信等关键技术的实现方案。

## 5G核心技术特性

### 技术指标
- **峰值速率**: 下行20Gbps，上行10Gbps
- **用户体验速率**: 下行100Mbps，上行50Mbps
- **延迟**: 空口延迟1ms，端到端延迟10ms
- **连接密度**: 100万设备/km²
- **移动性**: 支持500km/h高速移动
- **能效**: 比4G提升100倍

### 5G应用场景枚举
```java
/**
 * 5G应用场景枚举
 */
public enum FiveGScenario {
    EMBB("增强移动宽带", "Enhanced Mobile Broadband", "高速率、大容量数据传输"),
    URLLC("超可靠低延迟通信", "Ultra-Reliable Low Latency Communications", "关键任务应用"),
    MMTC("大规模机器类通信", "Massive Machine Type Communications", "物联网大连接"),
    INDUSTRIAL("工业互联网", "Industrial Internet", "工业4.0应用"),
    AUTONOMOUS_DRIVING("自动驾驶", "Autonomous Driving", "车联网应用"),
    SMART_CITY("智慧城市", "Smart City", "城市智能化管理"),
    AR_VR("增强现实/虚拟现实", "AR/VR", "沉浸式体验"),
    REMOTE_SURGERY("远程手术", "Remote Surgery", "远程医疗");
    
    private final String chineseName;
    private final String englishName;
    private final String description;
    
    FiveGScenario(String chineseName, String englishName, String description) {
        this.chineseName = chineseName;
        this.englishName = englishName;
        this.description = description;
    }
    
    public String getChineseName() { return chineseName; }
    public String getEnglishName() { return englishName; }
    public String getDescription() { return description; }
}

/**
 * 5G网络切片类型
 */
public enum NetworkSliceType {
    EMBB_SLICE("eMBB切片", "高带宽、中等延迟"),
    URLLC_SLICE("uRLLC切片", "超低延迟、高可靠性"),
    MMTC_SLICE("mMTC切片", "大连接、低功耗"),
    CUSTOM_SLICE("定制切片", "客户定制化需求");
    
    private final String name;
    private final String characteristics;
    
    NetworkSliceType(String name, String characteristics) {
        this.name = name;
        this.characteristics = characteristics;
    }
    
    public String getName() { return name; }
    public String getCharacteristics() { return characteristics; }
}
```

## 5G网络切片管理

### 网络切片核心实体
```java
/**
 * 5G网络切片实体
 */
@Entity
@Table(name = "network_slice")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NetworkSlice {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long sliceId;
    
    @Column(name = "slice_identifier", unique = true, nullable = false)
    private String sliceIdentifier; // S-NSSAI
    
    @Column(name = "slice_name")
    private String sliceName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "slice_type")
    private NetworkSliceType sliceType;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "scenario")
    private FiveGScenario scenario;
    
    @Column(name = "sst") // Slice/Service Type
    private Integer sst;
    
    @Column(name = "sd") // Slice Differentiator
    private String sd;
    
    @Column(name = "max_bandwidth_dl") // 下行最大带宽(Mbps)
    private Integer maxBandwidthDl;
    
    @Column(name = "max_bandwidth_ul") // 上行最大带宽(Mbps)
    private Integer maxBandwidthUl;
    
    @Column(name = "guaranteed_bandwidth_dl") // 下行保证带宽(Mbps)
    private Integer guaranteedBandwidthDl;
    
    @Column(name = "guaranteed_bandwidth_ul") // 上行保证带宽(Mbps)
    private Integer guaranteedBandwidthUl;
    
    @Column(name = "latency_requirement") // 延迟要求(ms)
    private Integer latencyRequirement;
    
    @Column(name = "reliability_requirement") // 可靠性要求(%)
    private BigDecimal reliabilityRequirement;
    
    @Column(name = "max_device_density") // 最大设备密度(设备/km²)
    private Integer maxDeviceDensity;
    
    @Column(name = "coverage_area")
    private String coverageArea;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "slice_status")
    private SliceStatus sliceStatus;
    
    @Column(name = "tenant_id")
    private String tenantId; // 租户ID
    
    @Column(name = "created_time")
    private LocalDateTime createdTime;
    
    @Column(name = "activated_time")
    private LocalDateTime activatedTime;
    
    @Column(name = "deactivated_time")
    private LocalDateTime deactivatedTime;
    
    @Column(name = "slice_template_id")
    private String sliceTemplateId;
    
    @Column(name = "sla_parameters", columnDefinition = "JSON")
    private String slaParameters; // SLA参数JSON
    
    @Column(name = "resource_allocation", columnDefinition = "JSON")
    private String resourceAllocation; // 资源分配JSON
}

/**
 * 切片状态枚举
 */
public enum SliceStatus {
    DRAFT("草稿"),
    PENDING_APPROVAL("待审批"),
    APPROVED("已审批"),
    DEPLOYING("部署中"),
    ACTIVE("激活"),
    SUSPENDED("暂停"),
    DECOMMISSIONING("下线中"),
    DECOMMISSIONED("已下线"),
    FAILED("失败");
    
    private final String description;
    
    SliceStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() { return description; }
}
```

### 网络切片管理服务
```java
/**
 * 5G网络切片管理服务
 */
@Service
@Slf4j
public class NetworkSliceManagementService {
    
    @Autowired
    private NetworkSliceRepository networkSliceRepository;
    
    @Autowired
    private SliceTemplateRepository sliceTemplateRepository;
    
    @Autowired
    private ResourceOrchestrationService resourceOrchestrationService;
    
    @Autowired
    private SliceMonitoringService sliceMonitoringService;
    
    /**
     * 创建网络切片
     */
    public NetworkSlice createNetworkSlice(CreateSliceRequest request) {
        log.info("Creating network slice for tenant: {}, scenario: {}", 
            request.getTenantId(), request.getScenario());
        
        try {
            // 1. 验证请求参数
            validateSliceRequest(request);
            
            // 2. 检查资源可用性
            if (!checkResourceAvailability(request)) {
                throw new InsufficientResourceException("Insufficient resources for slice creation");
            }
            
            // 3. 生成切片标识符
            String sliceIdentifier = generateSliceIdentifier(request);
            
            // 4. 创建切片实体
            NetworkSlice slice = NetworkSlice.builder()
                .sliceIdentifier(sliceIdentifier)
                .sliceName(request.getSliceName())
                .sliceType(request.getSliceType())
                .scenario(request.getScenario())
                .sst(request.getSst())
                .sd(request.getSd())
                .maxBandwidthDl(request.getMaxBandwidthDl())
                .maxBandwidthUl(request.getMaxBandwidthUl())
                .guaranteedBandwidthDl(request.getGuaranteedBandwidthDl())
                .guaranteedBandwidthUl(request.getGuaranteedBandwidthUl())
                .latencyRequirement(request.getLatencyRequirement())
                .reliabilityRequirement(request.getReliabilityRequirement())
                .maxDeviceDensity(request.getMaxDeviceDensity())
                .coverageArea(request.getCoverageArea())
                .tenantId(request.getTenantId())
                .sliceStatus(SliceStatus.DRAFT)
                .createdTime(LocalDateTime.now())
                .sliceTemplateId(request.getSliceTemplateId())
                .slaParameters(JsonUtils.toJson(request.getSlaParameters()))
                .build();
            
            // 5. 保存切片
            slice = networkSliceRepository.save(slice);
            
            // 6. 记录切片创建事件
            recordSliceEvent(slice, "SLICE_CREATED", "Network slice created successfully");
            
            log.info("Network slice created successfully: {}", slice.getSliceIdentifier());
            return slice;
            
        } catch (Exception e) {
            log.error("Failed to create network slice for tenant: {}", request.getTenantId(), e);
            throw new SliceManagementException("Failed to create network slice", e);
        }
    }
    
    /**
     * 部署网络切片
     */
    public void deployNetworkSlice(Long sliceId) {
        log.info("Deploying network slice: {}", sliceId);
        
        try {
            NetworkSlice slice = getNetworkSlice(sliceId);
            
            if (slice.getSliceStatus() != SliceStatus.APPROVED) {
                throw new InvalidSliceStateException("Slice must be approved before deployment");
            }
            
            // 1. 更新状态为部署中
            updateSliceStatus(slice, SliceStatus.DEPLOYING);
            
            // 2. 资源编排
            ResourceAllocation allocation = resourceOrchestrationService.allocateResources(slice);
            
            // 3. 配置网络功能
            configureNetworkFunctions(slice, allocation);
            
            // 4. 建立数据路径
            establishDataPath(slice);
            
            // 5. 配置QoS策略
            configureQosPolicy(slice);
            
            // 6. 启动监控
            sliceMonitoringService.startMonitoring(slice);
            
            // 7. 更新状态为激活
            updateSliceStatus(slice, SliceStatus.ACTIVE);
            slice.setActivatedTime(LocalDateTime.now());
            slice.setResourceAllocation(JsonUtils.toJson(allocation));
            networkSliceRepository.save(slice);
            
            // 8. 记录部署事件
            recordSliceEvent(slice, "SLICE_DEPLOYED", "Network slice deployed successfully");
            
            log.info("Network slice deployed successfully: {}", slice.getSliceIdentifier());
            
        } catch (Exception e) {
            log.error("Failed to deploy network slice: {}", sliceId, e);
            // 回滚部署
            rollbackDeployment(sliceId);
            throw new SliceDeploymentException("Failed to deploy network slice", e);
        }
    }
    
    /**
     * 修改网络切片
     */
    public NetworkSlice modifyNetworkSlice(Long sliceId, ModifySliceRequest request) {
        log.info("Modifying network slice: {}", sliceId);
        
        try {
            NetworkSlice slice = getNetworkSlice(sliceId);
            
            // 1. 验证修改权限
            validateModificationPermission(slice, request);
            
            // 2. 检查资源可用性
            if (!checkModificationResourceAvailability(slice, request)) {
                throw new InsufficientResourceException("Insufficient resources for slice modification");
            }
            
            // 3. 应用修改
            applySliceModifications(slice, request);
            
            // 4. 重新配置网络
            if (slice.getSliceStatus() == SliceStatus.ACTIVE) {
                reconfigureNetworkSlice(slice);
            }
            
            // 5. 保存修改
            slice = networkSliceRepository.save(slice);
            
            // 6. 记录修改事件
            recordSliceEvent(slice, "SLICE_MODIFIED", "Network slice modified successfully");
            
            log.info("Network slice modified successfully: {}", slice.getSliceIdentifier());
            return slice;
            
        } catch (Exception e) {
            log.error("Failed to modify network slice: {}", sliceId, e);
            throw new SliceManagementException("Failed to modify network slice", e);
        }
    }
    
    /**
     * 删除网络切片
     */
    public void deleteNetworkSlice(Long sliceId) {
        log.info("Deleting network slice: {}", sliceId);
        
        try {
            NetworkSlice slice = getNetworkSlice(sliceId);
            
            // 1. 检查切片状态
            if (slice.getSliceStatus() == SliceStatus.ACTIVE) {
                // 先停用切片
                deactivateNetworkSlice(sliceId);
            }
            
            // 2. 更新状态为下线中
            updateSliceStatus(slice, SliceStatus.DECOMMISSIONING);
            
            // 3. 释放资源
            resourceOrchestrationService.releaseResources(slice);
            
            // 4. 停止监控
            sliceMonitoringService.stopMonitoring(slice);
            
            // 5. 清理配置
            cleanupSliceConfiguration(slice);
            
            // 6. 更新状态为已下线
            updateSliceStatus(slice, SliceStatus.DECOMMISSIONED);
            slice.setDeactivatedTime(LocalDateTime.now());
            networkSliceRepository.save(slice);
            
            // 7. 记录删除事件
            recordSliceEvent(slice, "SLICE_DELETED", "Network slice deleted successfully");
            
            log.info("Network slice deleted successfully: {}", slice.getSliceIdentifier());
            
        } catch (Exception e) {
            log.error("Failed to delete network slice: {}", sliceId, e);
            throw new SliceManagementException("Failed to delete network slice", e);
        }
    }
    
    /**
     * 获取切片性能指标
     */
    public SlicePerformanceMetrics getSlicePerformanceMetrics(Long sliceId) {
        log.debug("Getting performance metrics for slice: {}", sliceId);
        
        try {
            NetworkSlice slice = getNetworkSlice(sliceId);
            
            if (slice.getSliceStatus() != SliceStatus.ACTIVE) {
                throw new InvalidSliceStateException("Slice must be active to get performance metrics");
            }
            
            return sliceMonitoringService.getPerformanceMetrics(slice);
            
        } catch (Exception e) {
            log.error("Failed to get performance metrics for slice: {}", sliceId, e);
            throw new SliceManagementException("Failed to get performance metrics", e);
        }
    }
    
    /**
     * 切片自动扩缩容
     */
    @Scheduled(fixedRate = 30000) // 每30秒检查一次
    public void autoScaleSlices() {
        log.debug("Starting auto-scale check for network slices");
        
        try {
            List<NetworkSlice> activeSlices = networkSliceRepository.findBySliceStatus(SliceStatus.ACTIVE);
            
            for (NetworkSlice slice : activeSlices) {
                try {
                    checkAndScaleSlice(slice);
                } catch (Exception e) {
                    log.error("Failed to auto-scale slice: {}", slice.getSliceIdentifier(), e);
                }
            }
            
        } catch (Exception e) {
            log.error("Failed to perform auto-scale check", e);
        }
    }
    
    /**
     * 检查并扩缩容切片
     */
    private void checkAndScaleSlice(NetworkSlice slice) {
        SlicePerformanceMetrics metrics = sliceMonitoringService.getPerformanceMetrics(slice);
        
        // 检查是否需要扩容
        if (shouldScaleUp(slice, metrics)) {
            log.info("Scaling up slice: {}", slice.getSliceIdentifier());
            scaleUpSlice(slice, metrics);
        }
        // 检查是否需要缩容
        else if (shouldScaleDown(slice, metrics)) {
            log.info("Scaling down slice: {}", slice.getSliceIdentifier());
            scaleDownSlice(slice, metrics);
        }
    }
    
    /**
     * 判断是否需要扩容
     */
    private boolean shouldScaleUp(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        // CPU使用率超过80%
        if (metrics.getCpuUtilization() > 80.0) {
            return true;
        }
        
        // 内存使用率超过85%
        if (metrics.getMemoryUtilization() > 85.0) {
            return true;
        }
        
        // 带宽使用率超过90%
        if (metrics.getBandwidthUtilization() > 90.0) {
            return true;
        }
        
        // 延迟超过SLA要求的120%
        if (metrics.getAverageLatency() > slice.getLatencyRequirement() * 1.2) {
            return true;
        }
        
        return false;
    }
    
    /**
     * 判断是否需要缩容
     */
    private boolean shouldScaleDown(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        // CPU使用率低于30%且持续10分钟
        if (metrics.getCpuUtilization() < 30.0 && 
            metrics.getLowCpuDuration().toMinutes() > 10) {
            return true;
        }
        
        // 内存使用率低于40%且持续10分钟
        if (metrics.getMemoryUtilization() < 40.0 && 
            metrics.getLowMemoryDuration().toMinutes() > 10) {
            return true;
        }
        
        // 带宽使用率低于20%且持续15分钟
        if (metrics.getBandwidthUtilization() < 20.0 && 
            metrics.getLowBandwidthDuration().toMinutes() > 15) {
            return true;
        }
        
        return false;
    }
    
    // 辅助方法
    private void validateSliceRequest(CreateSliceRequest request) {
        if (request.getTenantId() == null || request.getTenantId().trim().isEmpty()) {
            throw new InvalidRequestException("Tenant ID is required");
        }
        
        if (request.getScenario() == null) {
            throw new InvalidRequestException("Scenario is required");
        }
        
        if (request.getLatencyRequirement() != null && request.getLatencyRequirement() < 1) {
            throw new InvalidRequestException("Latency requirement must be at least 1ms");
        }
    }
    
    private boolean checkResourceAvailability(CreateSliceRequest request) {
        return resourceOrchestrationService.checkResourceAvailability(
            request.getMaxBandwidthDl(),
            request.getMaxBandwidthUl(),
            request.getMaxDeviceDensity(),
            request.getCoverageArea());
    }
    
    private String generateSliceIdentifier(CreateSliceRequest request) {
        return String.format("SLICE_%s_%d_%s", 
            request.getScenario().name(),
            System.currentTimeMillis(),
            request.getTenantId().hashCode());
    }
    
    private NetworkSlice getNetworkSlice(Long sliceId) {
        return networkSliceRepository.findById(sliceId)
            .orElseThrow(() -> new SliceNotFoundException("Network slice not found: " + sliceId));
    }
    
    private void updateSliceStatus(NetworkSlice slice, SliceStatus status) {
        slice.setSliceStatus(status);
        networkSliceRepository.save(slice);
    }
    
    private void configureNetworkFunctions(NetworkSlice slice, ResourceAllocation allocation) {
        // 配置网络功能
        log.debug("Configuring network functions for slice: {}", slice.getSliceIdentifier());
    }
    
    private void establishDataPath(NetworkSlice slice) {
        // 建立数据路径
        log.debug("Establishing data path for slice: {}", slice.getSliceIdentifier());
    }
    
    private void configureQosPolicy(NetworkSlice slice) {
        // 配置QoS策略
        log.debug("Configuring QoS policy for slice: {}", slice.getSliceIdentifier());
    }
    
    private void rollbackDeployment(Long sliceId) {
        // 回滚部署
        log.warn("Rolling back deployment for slice: {}", sliceId);
    }
    
    private void validateModificationPermission(NetworkSlice slice, ModifySliceRequest request) {
        // 验证修改权限
        if (!slice.getTenantId().equals(request.getTenantId())) {
            throw new UnauthorizedException("Unauthorized to modify this slice");
        }
    }
    
    private boolean checkModificationResourceAvailability(NetworkSlice slice, ModifySliceRequest request) {
        // 检查修改所需的资源可用性
        return true;
    }
    
    private void applySliceModifications(NetworkSlice slice, ModifySliceRequest request) {
        // 应用切片修改
        if (request.getMaxBandwidthDl() != null) {
            slice.setMaxBandwidthDl(request.getMaxBandwidthDl());
        }
        if (request.getMaxBandwidthUl() != null) {
            slice.setMaxBandwidthUl(request.getMaxBandwidthUl());
        }
        // 其他修改...
    }
    
    private void reconfigureNetworkSlice(NetworkSlice slice) {
        // 重新配置网络切片
        log.debug("Reconfiguring network slice: {}", slice.getSliceIdentifier());
    }
    
    private void deactivateNetworkSlice(Long sliceId) {
        // 停用网络切片
        log.info("Deactivating network slice: {}", sliceId);
    }
    
    private void cleanupSliceConfiguration(NetworkSlice slice) {
        // 清理切片配置
        log.debug("Cleaning up configuration for slice: {}", slice.getSliceIdentifier());
    }
    
    private void scaleUpSlice(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        // 扩容切片
        log.info("Scaling up slice: {}", slice.getSliceIdentifier());
        resourceOrchestrationService.scaleUpResources(slice, metrics);
    }
    
    private void scaleDownSlice(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        // 缩容切片
        log.info("Scaling down slice: {}", slice.getSliceIdentifier());
        resourceOrchestrationService.scaleDownResources(slice, metrics);
    }
    
    private void recordSliceEvent(NetworkSlice slice, String eventType, String description) {
        // 记录切片事件
        log.debug("Recording slice event: {} for slice: {}", eventType, slice.getSliceIdentifier());
    }
}
```

## 5G边缘计算集成

### 边缘计算节点管理
```java
/**
 * 5G边缘计算节点实体
 */
@Entity
@Table(name = "edge_computing_node")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EdgeComputingNode {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long nodeId;
    
    @Column(name = "node_identifier", unique = true)
    private String nodeIdentifier;
    
    @Column(name = "node_name")
    private String nodeName;
    
    @Column(name = "location_info", columnDefinition = "JSON")
    private String locationInfo; // 地理位置信息
    
    @Column(name = "coverage_area")
    private String coverageArea;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "node_type")
    private EdgeNodeType nodeType;
    
    @Column(name = "cpu_cores")
    private Integer cpuCores;
    
    @Column(name = "memory_gb")
    private Integer memoryGb;
    
    @Column(name = "storage_gb")
    private Integer storageGb;
    
    @Column(name = "gpu_count")
    private Integer gpuCount;
    
    @Column(name = "network_bandwidth_mbps")
    private Integer networkBandwidthMbps;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "node_status")
    private EdgeNodeStatus nodeStatus;
    
    @Column(name = "deployed_services", columnDefinition = "JSON")
    private String deployedServices;
    
    @Column(name = "resource_utilization", columnDefinition = "JSON")
    private String resourceUtilization;
    
    @Column(name = "created_time")
    private LocalDateTime createdTime;
    
    @Column(name = "last_heartbeat")
    private LocalDateTime lastHeartbeat;
}

/**
 * 边缘节点类型
 */
public enum EdgeNodeType {
    MICRO_EDGE("微边缘", "用户设备级边缘"),
    ACCESS_EDGE("接入边缘", "基站级边缘"),
    AGGREGATION_EDGE("汇聚边缘", "区域级边缘"),
    REGIONAL_EDGE("区域边缘", "城市级边缘");
    
    private final String name;
    private final String description;
    
    EdgeNodeType(String name, String description) {
        this.name = name;
        this.description = description;
    }
    
    public String getName() { return name; }
    public String getDescription() { return description; }
}

/**
 * 边缘节点状态
 */
public enum EdgeNodeStatus {
    INITIALIZING("初始化中"),
    ACTIVE("活跃"),
    BUSY("繁忙"),
    MAINTENANCE("维护中"),
    OFFLINE("离线"),
    FAILED("故障");
    
    private final String description;
    
    EdgeNodeStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() { return description; }
}
```

### 边缘计算服务管理
```java
/**
 * 5G边缘计算服务
 */
@Service
@Slf4j
public class EdgeComputingService {
    
    @Autowired
    private EdgeComputingNodeRepository edgeNodeRepository;
    
    @Autowired
    private EdgeServiceRepository edgeServiceRepository;
    
    @Autowired
    private LoadBalancingService loadBalancingService;
    
    @Autowired
    private ServiceOrchestrationService serviceOrchestrationService;
    
    /**
     * 部署边缘服务
     */
    public EdgeServiceDeployment deployEdgeService(DeployEdgeServiceRequest request) {
        log.info("Deploying edge service: {} to location: {}", 
            request.getServiceName(), request.getTargetLocation());
        
        try {
            // 1. 选择最优边缘节点
            EdgeComputingNode targetNode = selectOptimalEdgeNode(request);
            
            if (targetNode == null) {
                throw new NoAvailableEdgeNodeException("No suitable edge node found");
            }
            
            // 2. 检查资源可用性
            if (!checkNodeResourceAvailability(targetNode, request.getResourceRequirements())) {
                throw new InsufficientResourceException("Insufficient resources on target node");
            }
            
            // 3. 创建服务部署
            EdgeServiceDeployment deployment = EdgeServiceDeployment.builder()
                .deploymentId(generateDeploymentId())
                .serviceName(request.getServiceName())
                .serviceVersion(request.getServiceVersion())
                .nodeId(targetNode.getNodeId())
                .resourceRequirements(JsonUtils.toJson(request.getResourceRequirements()))
                .deploymentConfig(JsonUtils.toJson(request.getDeploymentConfig()))
                .deploymentStatus(DeploymentStatus.DEPLOYING)
                .createdTime(LocalDateTime.now())
                .build();
            
            deployment = edgeServiceRepository.save(deployment);
            
            // 4. 执行部署
            executeServiceDeployment(deployment, targetNode, request);
            
            // 5. 更新节点状态
            updateNodeDeployedServices(targetNode, deployment);
            
            log.info("Edge service deployed successfully: {}", deployment.getDeploymentId());
            return deployment;
            
        } catch (Exception e) {
            log.error("Failed to deploy edge service: {}", request.getServiceName(), e);
            throw new EdgeServiceDeploymentException("Failed to deploy edge service", e);
        }
    }
    
    /**
     * 选择最优边缘节点
     */
    private EdgeComputingNode selectOptimalEdgeNode(DeployEdgeServiceRequest request) {
        log.debug("Selecting optimal edge node for service: {}", request.getServiceName());
        
        // 1. 获取候选节点
        List<EdgeComputingNode> candidateNodes = getCandidateNodes(request.getTargetLocation());
        
        if (candidateNodes.isEmpty()) {
            return null;
        }
        
        // 2. 计算节点评分
        EdgeComputingNode bestNode = null;
        double bestScore = -1;
        
        for (EdgeComputingNode node : candidateNodes) {
            double score = calculateNodeScore(node, request);
            if (score > bestScore) {
                bestScore = score;
                bestNode = node;
            }
        }
        
        log.debug("Selected edge node: {} with score: {}", 
            bestNode != null ? bestNode.getNodeIdentifier() : "none", bestScore);
        
        return bestNode;
    }
    
    /**
     * 计算节点评分
     */
    private double calculateNodeScore(EdgeComputingNode node, DeployEdgeServiceRequest request) {
        double score = 0.0;
        
        // 1. 资源可用性评分 (40%)
        double resourceScore = calculateResourceScore(node, request.getResourceRequirements());
        score += resourceScore * 0.4;
        
        // 2. 地理位置评分 (30%)
        double locationScore = calculateLocationScore(node, request.getTargetLocation());
        score += locationScore * 0.3;
        
        // 3. 负载评分 (20%)
        double loadScore = calculateLoadScore(node);
        score += loadScore * 0.2;
        
        // 4. 网络延迟评分 (10%)
        double latencyScore = calculateLatencyScore(node, request.getLatencyRequirement());
        score += latencyScore * 0.1;
        
        return score;
    }
    
    /**
     * 智能负载均衡
     */
    public EdgeComputingNode selectNodeForRequest(ServiceRequest serviceRequest) {
        log.debug("Selecting node for service request: {}", serviceRequest.getRequestId());
        
        try {
            // 1. 获取可用节点
            List<EdgeComputingNode> availableNodes = getAvailableNodes(serviceRequest.getLocation());
            
            if (availableNodes.isEmpty()) {
                throw new NoAvailableEdgeNodeException("No available edge nodes");
            }
            
            // 2. 应用负载均衡策略
            return loadBalancingService.selectNode(availableNodes, serviceRequest);
            
        } catch (Exception e) {
            log.error("Failed to select node for service request: {}", 
                serviceRequest.getRequestId(), e);
            throw new NodeSelectionException("Failed to select edge node", e);
        }
    }
    
    /**
     * 边缘服务迁移
     */
    public void migrateEdgeService(String deploymentId, Long targetNodeId) {
        log.info("Migrating edge service: {} to node: {}", deploymentId, targetNodeId);
        
        try {
            // 1. 获取当前部署
            EdgeServiceDeployment deployment = getEdgeServiceDeployment(deploymentId);
            EdgeComputingNode sourceNode = getEdgeNode(deployment.getNodeId());
            EdgeComputingNode targetNode = getEdgeNode(targetNodeId);
            
            // 2. 检查目标节点资源
            ResourceRequirements requirements = JsonUtils.fromJson(
                deployment.getResourceRequirements(), ResourceRequirements.class);
            
            if (!checkNodeResourceAvailability(targetNode, requirements)) {
                throw new InsufficientResourceException("Target node has insufficient resources");
            }
            
            // 3. 在目标节点部署服务
            deployServiceOnNode(deployment, targetNode);
            
            // 4. 切换流量
            switchTrafficToTargetNode(deployment, sourceNode, targetNode);
            
            // 5. 停止源节点服务
            stopServiceOnNode(deployment, sourceNode);
            
            // 6. 更新部署信息
            deployment.setNodeId(targetNodeId);
            deployment.setMigratedTime(LocalDateTime.now());
            edgeServiceRepository.save(deployment);
            
            // 7. 更新节点状态
            updateNodeDeployedServices(sourceNode, deployment, false);
            updateNodeDeployedServices(targetNode, deployment, true);
            
            log.info("Edge service migrated successfully: {}", deploymentId);
            
        } catch (Exception e) {
            log.error("Failed to migrate edge service: {}", deploymentId, e);
            throw new ServiceMigrationException("Failed to migrate edge service", e);
        }
    }
    
    /**
     * 边缘节点健康检查
     */
    @Scheduled(fixedRate = 30000) // 每30秒检查一次
    public void performHealthCheck() {
        log.debug("Performing edge node health check");
        
        try {
            List<EdgeComputingNode> allNodes = edgeNodeRepository.findAll();
            
            for (EdgeComputingNode node : allNodes) {
                try {
                    checkNodeHealth(node);
                } catch (Exception e) {
                    log.error("Health check failed for node: {}", 
                        node.getNodeIdentifier(), e);
                }
            }
            
        } catch (Exception e) {
            log.error("Failed to perform health check", e);
        }
    }
    
    /**
     * 检查节点健康状态
     */
    private void checkNodeHealth(EdgeComputingNode node) {
        // 1. 检查心跳
        if (isNodeHeartbeatTimeout(node)) {
            handleNodeOffline(node);
            return;
        }
        
        // 2. 检查资源使用率
        ResourceUtilization utilization = getNodeResourceUtilization(node);
        
        // 3. 检查服务状态
        List<EdgeServiceDeployment> deployments = getNodeDeployments(node);
        
        // 4. 更新节点状态
        EdgeNodeStatus newStatus = determineNodeStatus(node, utilization, deployments);
        
        if (newStatus != node.getNodeStatus()) {
            log.info("Node status changed: {} from {} to {}", 
                node.getNodeIdentifier(), node.getNodeStatus(), newStatus);
            
            node.setNodeStatus(newStatus);
            edgeNodeRepository.save(node);
            
            // 处理状态变化
            handleNodeStatusChange(node, newStatus);
        }
    }
    
    // 辅助方法
    private List<EdgeComputingNode> getCandidateNodes(String targetLocation) {
        return edgeNodeRepository.findByNodeStatusAndCoverageAreaContaining(
            EdgeNodeStatus.ACTIVE, targetLocation);
    }
    
    private double calculateResourceScore(EdgeComputingNode node, ResourceRequirements requirements) {
        // 计算资源匹配度评分
        ResourceUtilization utilization = getNodeResourceUtilization(node);
        
        double cpuScore = Math.max(0, 100 - utilization.getCpuUtilization()) / 100.0;
        double memoryScore = Math.max(0, 100 - utilization.getMemoryUtilization()) / 100.0;
        double storageScore = Math.max(0, 100 - utilization.getStorageUtilization()) / 100.0;
        
        return (cpuScore + memoryScore + storageScore) / 3.0;
    }
    
    private double calculateLocationScore(EdgeComputingNode node, String targetLocation) {
        // 计算地理位置评分（距离越近评分越高）
        double distance = calculateDistance(node.getLocationInfo(), targetLocation);
        return Math.max(0, 1.0 - distance / 100.0); // 假设100km为最大有效距离
    }
    
    private double calculateLoadScore(EdgeComputingNode node) {
        // 计算负载评分
        List<EdgeServiceDeployment> deployments = getNodeDeployments(node);
        int activeDeployments = (int) deployments.stream()
            .filter(d -> d.getDeploymentStatus() == DeploymentStatus.RUNNING)
            .count();
        
        // 假设每个节点最多支持10个活跃部署
        return Math.max(0, 1.0 - activeDeployments / 10.0);
    }
    
    private double calculateLatencyScore(EdgeComputingNode node, Integer latencyRequirement) {
        // 计算延迟评分
        if (latencyRequirement == null) {
            return 1.0;
        }
        
        double nodeLatency = getNodeAverageLatency(node);
        return Math.max(0, 1.0 - nodeLatency / latencyRequirement);
    }
    
    private boolean checkNodeResourceAvailability(EdgeComputingNode node, 
                                                 ResourceRequirements requirements) {
        ResourceUtilization utilization = getNodeResourceUtilization(node);
        
        // 检查CPU
        double availableCpu = node.getCpuCores() * (100 - utilization.getCpuUtilization()) / 100.0;
        if (availableCpu < requirements.getCpuCores()) {
            return false;
        }
        
        // 检查内存
        double availableMemory = node.getMemoryGb() * (100 - utilization.getMemoryUtilization()) / 100.0;
        if (availableMemory < requirements.getMemoryGb()) {
            return false;
        }
        
        // 检查存储
        double availableStorage = node.getStorageGb() * (100 - utilization.getStorageUtilization()) / 100.0;
        if (availableStorage < requirements.getStorageGb()) {
            return false;
        }
        
        return true;
    }
    
    private String generateDeploymentId() {
        return "DEPLOY_" + System.currentTimeMillis() + "_" + 
               ThreadLocalRandom.current().nextInt(1000, 9999);
    }
    
    private void executeServiceDeployment(EdgeServiceDeployment deployment, 
                                        EdgeComputingNode node, 
                                        DeployEdgeServiceRequest request) {
        // 执行服务部署
        serviceOrchestrationService.deployService(deployment, node, request);
    }
    
    private void updateNodeDeployedServices(EdgeComputingNode node, 
                                          EdgeServiceDeployment deployment) {
        updateNodeDeployedServices(node, deployment, true);
    }
    
    private void updateNodeDeployedServices(EdgeComputingNode node, 
                                          EdgeServiceDeployment deployment, 
                                          boolean add) {
        // 更新节点部署的服务列表
        List<String> deployedServices = JsonUtils.fromJson(
            node.getDeployedServices(), 
            new TypeReference<List<String>>() {});
        
        if (deployedServices == null) {
            deployedServices = new ArrayList<>();
        }
        
        if (add) {
            deployedServices.add(deployment.getDeploymentId());
        } else {
            deployedServices.remove(deployment.getDeploymentId());
        }
        
        node.setDeployedServices(JsonUtils.toJson(deployedServices));
        edgeNodeRepository.save(node);
    }
    
    private EdgeServiceDeployment getEdgeServiceDeployment(String deploymentId) {
        return edgeServiceRepository.findByDeploymentId(deploymentId)
            .orElseThrow(() -> new DeploymentNotFoundException("Deployment not found: " + deploymentId));
    }
    
    private EdgeComputingNode getEdgeNode(Long nodeId) {
        return edgeNodeRepository.findById(nodeId)
            .orElseThrow(() -> new EdgeNodeNotFoundException("Edge node not found: " + nodeId));
    }
    
    private List<EdgeComputingNode> getAvailableNodes(String location) {
        return edgeNodeRepository.findByNodeStatusInAndCoverageAreaContaining(
            Arrays.asList(EdgeNodeStatus.ACTIVE, EdgeNodeStatus.BUSY), location);
    }
    
    private void deployServiceOnNode(EdgeServiceDeployment deployment, EdgeComputingNode node) {
        // 在节点上部署服务
        log.debug("Deploying service on node: {}", node.getNodeIdentifier());
    }
    
    private void switchTrafficToTargetNode(EdgeServiceDeployment deployment, 
                                         EdgeComputingNode sourceNode, 
                                         EdgeComputingNode targetNode) {
        // 切换流量到目标节点
        log.debug("Switching traffic from {} to {}", 
            sourceNode.getNodeIdentifier(), targetNode.getNodeIdentifier());
    }
    
    private void stopServiceOnNode(EdgeServiceDeployment deployment, EdgeComputingNode node) {
        // 停止节点上的服务
        log.debug("Stopping service on node: {}", node.getNodeIdentifier());
    }
    
    private boolean isNodeHeartbeatTimeout(EdgeComputingNode node) {
        if (node.getLastHeartbeat() == null) {
            return true;
        }
        
        Duration timeSinceLastHeartbeat = Duration.between(
            node.getLastHeartbeat(), LocalDateTime.now());
        
        return timeSinceLastHeartbeat.toMinutes() > 5; // 5分钟超时
    }
    
    private void handleNodeOffline(EdgeComputingNode node) {
        log.warn("Node {} is offline, handling failover", node.getNodeIdentifier());
        
        node.setNodeStatus(EdgeNodeStatus.OFFLINE);
        edgeNodeRepository.save(node);
        
        // 触发服务迁移
        List<EdgeServiceDeployment> deployments = getNodeDeployments(node);
        for (EdgeServiceDeployment deployment : deployments) {
            if (deployment.getDeploymentStatus() == DeploymentStatus.RUNNING) {
                triggerServiceFailover(deployment);
            }
        }
    }
    
    private ResourceUtilization getNodeResourceUtilization(EdgeComputingNode node) {
        // 获取节点资源使用率
        return JsonUtils.fromJson(node.getResourceUtilization(), ResourceUtilization.class);
    }
    
    private List<EdgeServiceDeployment> getNodeDeployments(EdgeComputingNode node) {
        return edgeServiceRepository.findByNodeId(node.getNodeId());
    }
    
    private EdgeNodeStatus determineNodeStatus(EdgeComputingNode node, 
                                              ResourceUtilization utilization, 
                                              List<EdgeServiceDeployment> deployments) {
        // 根据资源使用率和服务状态确定节点状态
        if (utilization.getCpuUtilization() > 90 || utilization.getMemoryUtilization() > 95) {
            return EdgeNodeStatus.BUSY;
        }
        
        return EdgeNodeStatus.ACTIVE;
    }
    
    private void handleNodeStatusChange(EdgeComputingNode node, EdgeNodeStatus newStatus) {
        // 处理节点状态变化
        if (newStatus == EdgeNodeStatus.BUSY) {
            // 节点繁忙，考虑负载均衡
            considerLoadBalancing(node);
        } else if (newStatus == EdgeNodeStatus.OFFLINE || newStatus == EdgeNodeStatus.FAILED) {
            // 节点离线或故障，触发故障转移
            handleNodeFailure(node);
        }
    }
    
    private double calculateDistance(String location1, String location2) {
        // 计算两个位置之间的距离（简化实现）
        return 10.0; // 示例返回值
    }
    
    private double getNodeAverageLatency(EdgeComputingNode node) {
        // 获取节点平均延迟
        return 5.0; // 示例返回值
    }
    
    private void triggerServiceFailover(EdgeServiceDeployment deployment) {
        // 触发服务故障转移
        log.info("Triggering failover for deployment: {}", deployment.getDeploymentId());
    }
    
    private void considerLoadBalancing(EdgeComputingNode node) {
        // 考虑负载均衡
        log.debug("Considering load balancing for node: {}", node.getNodeIdentifier());
    }
    
    private void handleNodeFailure(EdgeComputingNode node) {
        // 处理节点故障
        log.error("Handling failure for node: {}", node.getNodeIdentifier());
    }
}
```

## 5G应用场景Demo

### 智能制造场景
```bash
#!/bin/bash
# 5G智能制造场景部署脚本

echo "=== 5G智能制造场景部署 ==="

# 1. 创建工业互联网网络切片
echo "创建工业互联网网络切片..."
curl -X POST http://localhost:8080/api/v1/network-slices \
  -H "Content-Type: application/json" \
  -d '{
    "sliceName": "智能制造切片",
    "sliceType": "CUSTOM_SLICE",
    "scenario": "INDUSTRIAL",
    "sst": 1,
    "sd": "000001",
    "maxBandwidthDl": 1000,
    "maxBandwidthUl": 500,
    "guaranteedBandwidthDl": 500,
    "guaranteedBandwidthUl": 250,
    "latencyRequirement": 1,
    "reliabilityRequirement": 99.999,
    "maxDeviceDensity": 10000,
    "coverageArea": "工厂区域A",
    "tenantId": "MANUFACTURING_CORP",
    "slaParameters": {
      "availability": 99.999,
      "jitter": 0.1,
      "packetLoss": 0.001
    }
  }'

echo "\n网络切片创建完成"

# 2. 部署边缘计算服务
echo "部署边缘AI质检服务..."
curl -X POST http://localhost:8080/api/v1/edge-services/deploy \
  -H "Content-Type: application/json" \
  -d '{
    "serviceName": "AI质检服务",
    "serviceVersion": "v1.0",
    "targetLocation": "工厂区域A",
    "resourceRequirements": {
      "cpuCores": 8,
      "memoryGb": 16,
      "storageGb": 100,
      "gpuCount": 1
    },
    "deploymentConfig": {
      "containerImage": "ai-quality-inspection:v1.0",
      "environmentVariables": {
        "MODEL_PATH": "/models/quality-inspection",
        "INFERENCE_BATCH_SIZE": "32"
      }
    },
    "latencyRequirement": 10
  }'

echo "\n边缘服务部署完成"

# 3. 配置设备连接
echo "配置工业设备连接..."
for i in {1..10}; do
  curl -X POST http://localhost:8080/api/v1/devices/register \
    -H "Content-Type: application/json" \
    -d "{
      \"deviceId\": \"MACHINE_${i}\",
      \"deviceType\": \"INDUSTRIAL_ROBOT\",
      \"imsi\": \"46000123456789${i}\",
      \"sliceIdentifier\": \"SLICE_INDUSTRIAL_xxx\",
      \"location\": \"工厂区域A-产线${i}\"
    }"
done

echo "\n设备注册完成"

# 4. 启动实时监控
echo "启动实时监控..."
curl -X POST http://localhost:8080/api/v1/monitoring/start \
  -H "Content-Type: application/json" \
  -d '{
    "monitoringType": "INDUSTRIAL_5G",
    "targets": ["SLICE_INDUSTRIAL_xxx"],
    "metrics": ["latency", "throughput", "reliability", "device_status"]
  }'

echo "\n5G智能制造场景部署完成！"
```

### 自动驾驶场景
```bash
#!/bin/bash
# 5G自动驾驶场景部署脚本

echo "=== 5G自动驾驶场景部署 ==="

# 1. 创建车联网网络切片
echo "创建车联网网络切片..."
curl -X POST http://localhost:8080/api/v1/network-slices \
  -H "Content-Type: application/json" \
  -d '{
    "sliceName": "车联网切片",
    "sliceType": "URLLC_SLICE",
    "scenario": "AUTONOMOUS_DRIVING",
    "sst": 2,
    "sd": "000002",
    "maxBandwidthDl": 2000,
    "maxBandwidthUl": 1000,
    "guaranteedBandwidthDl": 1000,
    "guaranteedBandwidthUl": 500,
    "latencyRequirement": 1,
    "reliabilityRequirement": 99.9999,
    "maxDeviceDensity": 1000,
    "coverageArea": "城市道路网络",
    "tenantId": "AUTONOMOUS_VEHICLE_CORP",
    "slaParameters": {
      "availability": 99.9999,
      "jitter": 0.05,
      "packetLoss": 0.0001
    }
  }'

# 2. 部署路侧边缘计算单元
echo "\n部署路侧边缘计算单元..."
for i in {1..5}; do
  curl -X POST http://localhost:8080/api/v1/edge-services/deploy \
    -H "Content-Type: application/json" \
    -d "{
      \"serviceName\": \"路侧感知服务\",
      \"serviceVersion\": \"v1.0\",
      \"targetLocation\": \"路口${i}\",
      \"resourceRequirements\": {
        \"cpuCores\": 16,
        \"memoryGb\": 32,
        \"storageGb\": 200,
        \"gpuCount\": 2
      },
      \"deploymentConfig\": {
        \"containerImage\": \"roadside-perception:v1.0\",
        \"environmentVariables\": {
          \"CAMERA_COUNT\": \"8\",
          \"LIDAR_COUNT\": \"4\",
          \"RADAR_COUNT\": \"6\"
        }
      },
      \"latencyRequirement\": 5
    }"
done

# 3. 注册自动驾驶车辆
echo "\n注册自动驾驶车辆..."
for i in {1..20}; do
  curl -X POST http://localhost:8080/api/v1/vehicles/register \
    -H "Content-Type: application/json" \
    -d "{
      \"vehicleId\": \"AV_${i}\",
      \"vehicleType\": \"AUTONOMOUS_VEHICLE\",
      \"imsi\": \"46000987654321${i}\",
      \"sliceIdentifier\": \"SLICE_AUTONOMOUS_DRIVING_xxx\",
      \"capabilities\": [\"L4_AUTONOMOUS\", \"V2X_COMMUNICATION\"],
      \"currentLocation": "路口1附近"
    }"
done

# 4. 启动V2X通信服务
echo "\n启动V2X通信服务..."
curl -X POST http://localhost:8080/api/v1/v2x/start \
  -H "Content-Type: application/json" \
  -d '{
    "serviceType": "V2X_COMMUNICATION",
    "coverageArea": "城市道路网络",
    "communicationModes": ["V2V", "V2I", "V2P", "V2N"],
    "messageTypes": ["BSM", "SPAT", "MAP", "RSA", "TIM"]
  }'

echo "\n5G自动驾驶场景部署完成！"
```

### AR/VR场景
```bash
#!/bin/bash
# 5G AR/VR场景部署脚本

echo "=== 5G AR/VR场景部署 ==="

# 1. 创建AR/VR网络切片
echo "创建AR/VR网络切片..."
curl -X POST http://localhost:8080/api/v1/network-slices \
  -H "Content-Type: application/json" \
  -d '{
    "sliceName": "AR/VR切片",
    "sliceType": "EMBB_SLICE",
    "scenario": "AR_VR",
    "sst": 3,
    "sd": "000003",
    "maxBandwidthDl": 5000,
    "maxBandwidthUl": 2000,
    "guaranteedBandwidthDl": 2000,
    "guaranteedBandwidthUl": 800,
    "latencyRequirement": 20,
    "reliabilityRequirement": 99.9,
    "maxDeviceDensity": 500,
    "coverageArea": "商业区域",
    "tenantId": "AR_VR_PLATFORM",
    "slaParameters": {
      "availability": 99.9,
      "jitter": 5,
      "packetLoss": 0.01
    }
  }'

# 2. 部署边缘渲染服务
echo "\n部署边缘渲染服务..."
curl -X POST http://localhost:8080/api/v1/edge-services/deploy \
  -H "Content-Type: application/json" \
  -d '{
    "serviceName": "边缘渲染服务",
    "serviceVersion": "v1.0",
    "targetLocation": "商业区域",
    "resourceRequirements": {
      "cpuCores": 32,
      "memoryGb": 64,
      "storageGb": 500,
      "gpuCount": 4
    },
    "deploymentConfig": {
      "containerImage": "edge-rendering:v1.0",
      "environmentVariables": {
        "RENDER_QUALITY": "HIGH",
        "MAX_CONCURRENT_USERS": "100"
      }
    },
    "latencyRequirement": 15
  }'

echo "\n5G AR/VR场景部署完成！"
```

## 5G性能监控与优化

### 性能监控服务
```java
/**
 * 5G性能监控服务
 */
@Service
@Slf4j
public class FiveGPerformanceMonitoringService {
    
    @Autowired
    private NetworkSliceRepository networkSliceRepository;
    
    @Autowired
    private PerformanceMetricsRepository metricsRepository;
    
    @Autowired
    private AlertService alertService;
    
    /**
     * 收集切片性能指标
     */
    @Scheduled(fixedRate = 10000) // 每10秒收集一次
    public void collectSliceMetrics() {
        log.debug("Collecting slice performance metrics");
        
        try {
            List<NetworkSlice> activeSlices = networkSliceRepository
                .findBySliceStatus(SliceStatus.ACTIVE);
            
            for (NetworkSlice slice : activeSlices) {
                try {
                    collectSliceMetrics(slice);
                } catch (Exception e) {
                    log.error("Failed to collect metrics for slice: {}", 
                        slice.getSliceIdentifier(), e);
                }
            }
            
        } catch (Exception e) {
            log.error("Failed to collect slice metrics", e);
        }
    }
    
    /**
     * 收集单个切片指标
     */
    private void collectSliceMetrics(NetworkSlice slice) {
        // 1. 收集基础性能指标
        SlicePerformanceMetrics metrics = SlicePerformanceMetrics.builder()
            .sliceId(slice.getSliceId())
            .sliceIdentifier(slice.getSliceIdentifier())
            .timestamp(LocalDateTime.now())
            .throughputDl(measureDownlinkThroughput(slice))
            .throughputUl(measureUplinkThroughput(slice))
            .latency(measureLatency(slice))
            .jitter(measureJitter(slice))
            .packetLoss(measurePacketLoss(slice))
            .availability(calculateAvailability(slice))
            .activeConnections(countActiveConnections(slice))
            .resourceUtilization(measureResourceUtilization(slice))
            .build();
        
        // 2. 保存指标
        metricsRepository.save(metrics);
        
        // 3. 检查SLA违规
        checkSlaViolations(slice, metrics);
        
        // 4. 触发自动优化
        triggerAutoOptimization(slice, metrics);
    }
    
    /**
     * 检查SLA违规
     */
    private void checkSlaViolations(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        List<SlaViolation> violations = new ArrayList<>();
        
        // 检查延迟SLA
        if (metrics.getLatency() > slice.getLatencyRequirement()) {
            violations.add(SlaViolation.builder()
                .violationType("LATENCY_VIOLATION")
                .expectedValue(slice.getLatencyRequirement().doubleValue())
                .actualValue(metrics.getLatency())
                .severity(determineSeverity(metrics.getLatency(), slice.getLatencyRequirement()))
                .build());
        }
        
        // 检查可靠性SLA
        if (metrics.getAvailability().compareTo(slice.getReliabilityRequirement()) < 0) {
            violations.add(SlaViolation.builder()
                .violationType("RELIABILITY_VIOLATION")
                .expectedValue(slice.getReliabilityRequirement().doubleValue())
                .actualValue(metrics.getAvailability().doubleValue())
                .severity("HIGH")
                .build());
        }
        
        // 发送告警
        if (!violations.isEmpty()) {
            alertService.sendSlaViolationAlert(slice, violations);
        }
    }
    
    /**
     * 触发自动优化
     */
    private void triggerAutoOptimization(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        // 1. 资源优化
        if (shouldOptimizeResources(metrics)) {
            optimizeSliceResources(slice, metrics);
        }
        
        // 2. 路由优化
        if (shouldOptimizeRouting(metrics)) {
            optimizeSliceRouting(slice, metrics);
        }
        
        // 3. QoS优化
        if (shouldOptimizeQos(metrics)) {
            optimizeSliceQos(slice, metrics);
        }
    }
    
    // 性能测量方法
    private Double measureDownlinkThroughput(NetworkSlice slice) {
        // 测量下行吞吐量
        return ThreadLocalRandom.current().nextDouble(800, 1200); // 示例值
    }
    
    private Double measureUplinkThroughput(NetworkSlice slice) {
        // 测量上行吞吐量
        return ThreadLocalRandom.current().nextDouble(400, 600); // 示例值
    }
    
    private Double measureLatency(NetworkSlice slice) {
        // 测量延迟
        return ThreadLocalRandom.current().nextDouble(1, 5); // 示例值
    }
    
    private Double measureJitter(NetworkSlice slice) {
        // 测量抖动
        return ThreadLocalRandom.current().nextDouble(0.1, 1.0); // 示例值
    }
    
    private Double measurePacketLoss(NetworkSlice slice) {
        // 测量丢包率
        return ThreadLocalRandom.current().nextDouble(0.001, 0.01); // 示例值
    }
    
    private BigDecimal calculateAvailability(NetworkSlice slice) {
        // 计算可用性
        return new BigDecimal("99.95"); // 示例值
    }
    
    private Integer countActiveConnections(NetworkSlice slice) {
        // 统计活跃连接数
        return ThreadLocalRandom.current().nextInt(50, 200); // 示例值
    }
    
    private ResourceUtilization measureResourceUtilization(NetworkSlice slice) {
        // 测量资源使用率
        return ResourceUtilization.builder()
            .cpuUtilization(ThreadLocalRandom.current().nextDouble(30, 80))
            .memoryUtilization(ThreadLocalRandom.current().nextDouble(40, 85))
            .storageUtilization(ThreadLocalRandom.current().nextDouble(20, 60))
            .networkUtilization(ThreadLocalRandom.current().nextDouble(50, 90))
            .build();
    }
    
    private String determineSeverity(Double actualLatency, Integer expectedLatency) {
        double ratio = actualLatency / expectedLatency;
        if (ratio > 2.0) {
            return "CRITICAL";
        } else if (ratio > 1.5) {
            return "HIGH";
        } else {
            return "MEDIUM";
        }
    }
    
    private boolean shouldOptimizeResources(SlicePerformanceMetrics metrics) {
        ResourceUtilization utilization = metrics.getResourceUtilization();
        return utilization.getCpuUtilization() > 85 || 
               utilization.getMemoryUtilization() > 90;
    }
    
    private boolean shouldOptimizeRouting(SlicePerformanceMetrics metrics) {
        return metrics.getLatency() > 10.0 || metrics.getPacketLoss() > 0.01;
    }
    
    private boolean shouldOptimizeQos(SlicePerformanceMetrics metrics) {
        return metrics.getJitter() > 2.0;
    }
    
    private void optimizeSliceResources(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        log.info("Optimizing resources for slice: {}", slice.getSliceIdentifier());
        // 实现资源优化逻辑
    }
    
    private void optimizeSliceRouting(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        log.info("Optimizing routing for slice: {}", slice.getSliceIdentifier());
        // 实现路由优化逻辑
    }
    
    private void optimizeSliceQos(NetworkSlice slice, SlicePerformanceMetrics metrics) {
        log.info("Optimizing QoS for slice: {}", slice.getSliceIdentifier());
        // 实现QoS优化逻辑
    }
}
```

## 最佳实践总结

### 1. 网络切片设计原则
- **场景驱动**: 根据具体应用场景设计切片参数
- **资源隔离**: 确保切片间资源完全隔离
- **弹性扩展**: 支持动态资源调整和扩缩容
- **SLA保证**: 严格遵守服务等级协议

### 2. 边缘计算部署策略
- **就近部署**: 将计算能力部署到最接近用户的位置
- **负载均衡**: 合理分配计算负载，避免热点
- **故障转移**: 建立完善的故障转移机制
- **资源优化**: 根据业务需求动态调整资源分配

### 3. 性能监控要点
- **实时监控**: 实时收集和分析性能指标
- **预警机制**: 建立多层次的性能预警体系
- **自动优化**: 基于AI的自动性能优化
- **SLA管理**: 严格的SLA监控和违规处理

### 4. 安全保障措施
- **端到端加密**: 确保数据传输安全
- **身份认证**: 强化设备和用户身份认证
- **访问控制**: 细粒度的访问权限控制
- **安全隔离**: 网络切片间的安全隔离

通过实施以上5G技术应用方案，NSRS号卡资源管理系统能够充分利用5G技术的优势，为各种创新应用场景提供强有力的网络支撑，推动电信行业的数字化转型和业务创新。