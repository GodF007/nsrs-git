# 物联网卡管理详解

## 概述

物联网卡（IoT SIM Card）是专门为物联网设备设计的SIM卡，具有低功耗、广覆盖、大连接等特点。本文档详细阐述物联网卡在NSRS号卡资源管理系统中的管理方案，包括物联网卡的分类、生命周期管理、连接管理、流量管理等核心功能。

## 物联网卡分类与特性

### 物联网卡类型枚举
```java
/**
 * 物联网卡类型枚举
 */
public enum IoTCardType {
    NB_IOT("NB-IoT卡", "窄带物联网卡", "低功耗广域网"),
    EMTC("eMTC卡", "增强机器类通信卡", "中等速率物联网"),
    LORA("LoRa卡", "长距离低功耗卡", "私有网络物联网"),
    STANDARD_2G("标准2G卡", "传统2G物联网卡", "基础连接"),
    STANDARD_4G("标准4G卡", "4G物联网卡", "高速连接"),
    STANDARD_5G("标准5G卡", "5G物联网卡", "超高速连接"),
    ESIM("eSIM卡", "嵌入式SIM卡", "可编程SIM");
    
    private final String chineseName;
    private final String description;
    private final String networkType;
    
    IoTCardType(String chineseName, String description, String networkType) {
        this.chineseName = chineseName;
        this.description = description;
        this.networkType = networkType;
    }
    
    public String getChineseName() { return chineseName; }
    public String getDescription() { return description; }
    public String getNetworkType() { return networkType; }
}

/**
 * 物联网应用场景枚举
 */
public enum IoTApplicationScenario {
    SMART_METER("智能抄表", "水电气表远程抄表", IoTCardType.NB_IOT),
    VEHICLE_TRACKING("车辆追踪", "车辆位置监控", IoTCardType.STANDARD_4G),
    ENVIRONMENTAL_MONITORING("环境监测", "空气质量、温湿度监测", IoTCardType.NB_IOT),
    SMART_AGRICULTURE("智慧农业", "土壤监测、灌溉控制", IoTCardType.LORA),
    INDUSTRIAL_IOT("工业物联网", "设备监控、预测维护", IoTCardType.EMTC),
    SMART_CITY("智慧城市", "路灯、停车位管理", IoTCardType.NB_IOT),
    WEARABLE_DEVICE("可穿戴设备", "健康监测设备", IoTCardType.EMTC),
    ASSET_TRACKING("资产追踪", "物流、仓储管理", IoTCardType.STANDARD_4G);
    
    private final String chineseName;
    private final String description;
    private final IoTCardType recommendedCardType;
    
    IoTApplicationScenario(String chineseName, String description, IoTCardType recommendedCardType) {
        this.chineseName = chineseName;
        this.description = description;
        this.recommendedCardType = recommendedCardType;
    }
    
    public String getChineseName() { return chineseName; }
    public String getDescription() { return description; }
    public IoTCardType getRecommendedCardType() { return recommendedCardType; }
}
```

## 物联网卡核心实体

### IoT卡实体类
```java
/**
 * 物联网卡实体
 */
@Entity
@Table(name = "iot_card")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class IoTCard {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long cardId;
    
    @Column(unique = true, nullable = false)
    private String iccid; // 集成电路卡识别码
    
    @Column(unique = true)
    private String imsi; // 国际移动用户识别码
    
    @Column(unique = true)
    private String msisdn; // 手机号码
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private IoTCardType cardType; // 卡类型
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private IoTCardStatus status; // 卡状态
    
    @Enumerated(EnumType.STRING)
    private IoTApplicationScenario applicationScenario; // 应用场景
    
    private String deviceId; // 绑定设备ID
    private String deviceType; // 设备类型
    private String customerId; // 客户ID
    private String customerName; // 客户名称
    
    // 套餐信息
    private String packageId; // 套餐ID
    private String packageName; // 套餐名称
    private Long monthlyDataLimit; // 月流量限制(KB)
    private BigDecimal monthlyFee; // 月费用
    
    // 使用统计
    private Long totalDataUsed; // 总使用流量(KB)
    private Long currentMonthDataUsed; // 当月使用流量(KB)
    private Integer connectionCount; // 连接次数
    private LocalDateTime lastConnectionTime; // 最后连接时间
    private String lastLocation; // 最后位置
    
    // 时间信息
    private LocalDateTime activationTime; // 激活时间
    private LocalDateTime expirationTime; // 到期时间
    private LocalDateTime createTime; // 创建时间
    private LocalDateTime updateTime; // 更新时间
    
    // 技术参数
    private String apn; // 接入点名称
    private String networkOperator; // 网络运营商
    private String roamingProfile; // 漫游配置
    private Boolean isRoamingEnabled; // 是否启用漫游
    
    // 安全配置
    private String encryptionKey; // 加密密钥
    private Boolean isSecureConnection; // 是否安全连接
    private String certificateId; // 证书ID
}

/**
 * 物联网卡状态枚举
 */
public enum IoTCardStatus {
    INVENTORY("库存", "卡片在库存中，未分配"),
    ALLOCATED("已分配", "卡片已分配给客户，未激活"),
    ACTIVE("激活", "卡片已激活，可正常使用"),
    SUSPENDED("暂停", "卡片被暂停，无法连接网络"),
    DEACTIVATED("停用", "卡片已停用"),
    EXPIRED("过期", "卡片已过期"),
    TERMINATED("终止", "卡片服务已终止"),
    LOST("丢失", "卡片丢失或被盗"),
    DAMAGED("损坏", "卡片物理损坏");
    
    private final String chineseName;
    private final String description;
    
    IoTCardStatus(String chineseName, String description) {
        this.chineseName = chineseName;
        this.description = description;
    }
    
    public String getChineseName() { return chineseName; }
    public String getDescription() { return description; }
}
```

## 物联网卡管理服务

### 核心管理服务
```java
/**
 * 物联网卡管理服务
 */
@Service
@Slf4j
public class IoTCardManagementService {
    
    @Autowired
    private IoTCardRepository iotCardRepository;
    
    @Autowired
    private IoTPackageRepository packageRepository;
    
    @Autowired
    private IoTDeviceRepository deviceRepository;
    
    @Autowired
    private DataUsageService dataUsageService;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 批量创建物联网卡
     */
    @Transactional
    public List<IoTCard> createIoTCards(IoTCardBatchCreateRequest request) {
        log.info("Creating {} IoT cards for customer: {}", 
            request.getQuantity(), request.getCustomerId());
        
        List<IoTCard> cards = new ArrayList<>();
        
        for (int i = 0; i < request.getQuantity(); i++) {
            IoTCard card = IoTCard.builder()
                .iccid(generateIccid())
                .imsi(generateImsi())
                .msisdn(generateMsisdn())
                .cardType(request.getCardType())
                .status(IoTCardStatus.INVENTORY)
                .applicationScenario(request.getApplicationScenario())
                .customerId(request.getCustomerId())
                .customerName(request.getCustomerName())
                .packageId(request.getPackageId())
                .apn(generateApn(request.getCardType()))
                .networkOperator(request.getNetworkOperator())
                .isRoamingEnabled(request.getIsRoamingEnabled())
                .isSecureConnection(true)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .build();
            
            // 设置套餐信息
            setPackageInfo(card, request.getPackageId());
            
            cards.add(card);
        }
        
        List<IoTCard> savedCards = iotCardRepository.saveAll(cards);
        
        log.info("Successfully created {} IoT cards", savedCards.size());
        return savedCards;
    }
    
    /**
     * 激活物联网卡
     */
    @Transactional
    public IoTCard activateCard(String iccid, IoTCardActivationRequest request) {
        log.info("Activating IoT card: {}", iccid);
        
        IoTCard card = iotCardRepository.findByIccid(iccid)
            .orElseThrow(() -> new IoTCardNotFoundException("IoT card not found: " + iccid));
        
        // 验证卡状态
        if (card.getStatus() != IoTCardStatus.ALLOCATED && 
            card.getStatus() != IoTCardStatus.INVENTORY) {
            throw new InvalidCardStatusException(
                "Card cannot be activated in current status: " + card.getStatus());
        }
        
        // 绑定设备
        if (request.getDeviceId() != null) {
            bindDevice(card, request.getDeviceId(), request.getDeviceType());
        }
        
        // 更新卡状态
        card.setStatus(IoTCardStatus.ACTIVE);
        card.setActivationTime(LocalDateTime.now());
        card.setExpirationTime(calculateExpirationTime(card));
        card.setUpdateTime(LocalDateTime.now());
        
        // 初始化流量统计
        initializeDataUsage(card);
        
        IoTCard savedCard = iotCardRepository.save(card);
        
        // 发送激活通知
        notificationService.sendActivationNotification(savedCard);
        
        log.info("IoT card activated successfully: {}", iccid);
        return savedCard;
    }
    
    /**
     * 暂停物联网卡
     */
    @Transactional
    public IoTCard suspendCard(String iccid, String reason) {
        log.info("Suspending IoT card: {}, reason: {}", iccid, reason);
        
        IoTCard card = iotCardRepository.findByIccid(iccid)
            .orElseThrow(() -> new IoTCardNotFoundException("IoT card not found: " + iccid));
        
        if (card.getStatus() != IoTCardStatus.ACTIVE) {
            throw new InvalidCardStatusException(
                "Only active cards can be suspended: " + card.getStatus());
        }
        
        card.setStatus(IoTCardStatus.SUSPENDED);
        card.setUpdateTime(LocalDateTime.now());
        
        IoTCard savedCard = iotCardRepository.save(card);
        
        // 记录暂停原因
        recordStatusChange(card, IoTCardStatus.ACTIVE, IoTCardStatus.SUSPENDED, reason);
        
        // 发送暂停通知
        notificationService.sendSuspensionNotification(savedCard, reason);
        
        log.info("IoT card suspended successfully: {}", iccid);
        return savedCard;
    }
    
    /**
     * 恢复物联网卡
     */
    @Transactional
    public IoTCard resumeCard(String iccid) {
        log.info("Resuming IoT card: {}", iccid);
        
        IoTCard card = iotCardRepository.findByIccid(iccid)
            .orElseThrow(() -> new IoTCardNotFoundException("IoT card not found: " + iccid));
        
        if (card.getStatus() != IoTCardStatus.SUSPENDED) {
            throw new InvalidCardStatusException(
                "Only suspended cards can be resumed: " + card.getStatus());
        }
        
        // 检查是否过期
        if (card.getExpirationTime() != null && 
            card.getExpirationTime().isBefore(LocalDateTime.now())) {
            card.setStatus(IoTCardStatus.EXPIRED);
        } else {
            card.setStatus(IoTCardStatus.ACTIVE);
        }
        
        card.setUpdateTime(LocalDateTime.now());
        
        IoTCard savedCard = iotCardRepository.save(card);
        
        // 记录恢复操作
        recordStatusChange(card, IoTCardStatus.SUSPENDED, card.getStatus(), "Manual resume");
        
        // 发送恢复通知
        notificationService.sendResumptionNotification(savedCard);
        
        log.info("IoT card resumed successfully: {}", iccid);
        return savedCard;
    }
    
    /**
     * 绑定设备
     */
    @Transactional
    public IoTCard bindDevice(IoTCard card, String deviceId, String deviceType) {
        log.info("Binding device {} to IoT card: {}", deviceId, card.getIccid());
        
        // 检查设备是否已存在
        Optional<IoTDevice> existingDevice = deviceRepository.findByDeviceId(deviceId);
        if (existingDevice.isPresent() && 
            !existingDevice.get().getIccid().equals(card.getIccid())) {
            throw new DeviceAlreadyBoundException(
                "Device already bound to another card: " + deviceId);
        }
        
        // 创建或更新设备记录
        IoTDevice device = existingDevice.orElse(new IoTDevice());
        device.setDeviceId(deviceId);
        device.setDeviceType(deviceType);
        device.setIccid(card.getIccid());
        device.setBindTime(LocalDateTime.now());
        device.setStatus("BOUND");
        
        deviceRepository.save(device);
        
        // 更新卡信息
        card.setDeviceId(deviceId);
        card.setDeviceType(deviceType);
        card.setUpdateTime(LocalDateTime.now());
        
        return iotCardRepository.save(card);
    }
    
    /**
     * 解绑设备
     */
    @Transactional
    public IoTCard unbindDevice(String iccid) {
        log.info("Unbinding device from IoT card: {}", iccid);
        
        IoTCard card = iotCardRepository.findByIccid(iccid)
            .orElseThrow(() -> new IoTCardNotFoundException("IoT card not found: " + iccid));
        
        if (card.getDeviceId() != null) {
            // 更新设备状态
            deviceRepository.findByDeviceId(card.getDeviceId())
                .ifPresent(device -> {
                    device.setStatus("UNBOUND");
                    device.setUnbindTime(LocalDateTime.now());
                    deviceRepository.save(device);
                });
            
            // 清除卡的设备信息
            card.setDeviceId(null);
            card.setDeviceType(null);
            card.setUpdateTime(LocalDateTime.now());
        }
        
        return iotCardRepository.save(card);
    }
    
    // 辅助方法
    private String generateIccid() {
        // 生成ICCID逻辑
        return "89860" + System.currentTimeMillis() + 
               String.format("%04d", ThreadLocalRandom.current().nextInt(10000));
    }
    
    private String generateImsi() {
        // 生成IMSI逻辑
        return "460001" + System.currentTimeMillis() % 10000000000L;
    }
    
    private String generateMsisdn() {
        // 生成MSISDN逻辑
        return "1390" + String.format("%07d", ThreadLocalRandom.current().nextInt(10000000));
    }
    
    private String generateApn(IoTCardType cardType) {
        switch (cardType) {
            case NB_IOT:
                return "nbiot.mnc001.mcc460.gprs";
            case EMTC:
                return "emtc.mnc001.mcc460.gprs";
            case LORA:
                return "lora.mnc001.mcc460.gprs";
            default:
                return "iot.mnc001.mcc460.gprs";
        }
    }
    
    private void setPackageInfo(IoTCard card, String packageId) {
        packageRepository.findById(packageId).ifPresent(pkg -> {
            card.setPackageName(pkg.getPackageName());
            card.setMonthlyDataLimit(pkg.getDataLimit());
            card.setMonthlyFee(pkg.getMonthlyFee());
        });
    }
    
    private LocalDateTime calculateExpirationTime(IoTCard card) {
        // 根据套餐计算到期时间，默认1年
        return LocalDateTime.now().plusYears(1);
    }
    
    private void initializeDataUsage(IoTCard card) {
        card.setTotalDataUsed(0L);
        card.setCurrentMonthDataUsed(0L);
        card.setConnectionCount(0);
    }
    
    private void recordStatusChange(IoTCard card, IoTCardStatus fromStatus, 
                                  IoTCardStatus toStatus, String reason) {
        // 记录状态变更历史
        log.info("IoT card {} status changed from {} to {}, reason: {}", 
            card.getIccid(), fromStatus, toStatus, reason);
    }
}
```

## 流量管理服务

### 数据使用监控
```java
/**
 * 物联网卡流量管理服务
 */
@Service
@Slf4j
public class IoTDataUsageService {
    
    @Autowired
    private IoTCardRepository iotCardRepository;
    
    @Autowired
    private DataUsageRecordRepository usageRecordRepository;
    
    @Autowired
    private AlertService alertService;
    
    /**
     * 记录数据使用
     */
    @Transactional
    public void recordDataUsage(String iccid, Long dataUsed, String sessionId) {
        log.debug("Recording data usage for card: {}, data: {} KB", iccid, dataUsed);
        
        IoTCard card = iotCardRepository.findByIccid(iccid)
            .orElseThrow(() -> new IoTCardNotFoundException("IoT card not found: " + iccid));
        
        // 更新卡的使用统计
        card.setTotalDataUsed(card.getTotalDataUsed() + dataUsed);
        card.setCurrentMonthDataUsed(card.getCurrentMonthDataUsed() + dataUsed);
        card.setConnectionCount(card.getConnectionCount() + 1);
        card.setLastConnectionTime(LocalDateTime.now());
        card.setUpdateTime(LocalDateTime.now());
        
        // 创建使用记录
        DataUsageRecord record = DataUsageRecord.builder()
            .iccid(iccid)
            .sessionId(sessionId)
            .dataUsed(dataUsed)
            .usageTime(LocalDateTime.now())
            .deviceId(card.getDeviceId())
            .location(card.getLastLocation())
            .build();
        
        usageRecordRepository.save(record);
        iotCardRepository.save(card);
        
        // 检查流量限制
        checkDataLimitAndAlert(card);
    }
    
    /**
     * 检查流量限制并发送告警
     */
    private void checkDataLimitAndAlert(IoTCard card) {
        if (card.getMonthlyDataLimit() == null || card.getMonthlyDataLimit() <= 0) {
            return;
        }
        
        double usagePercentage = (double) card.getCurrentMonthDataUsed() / card.getMonthlyDataLimit() * 100;
        
        // 80%告警
        if (usagePercentage >= 80 && usagePercentage < 90) {
            alertService.sendDataUsageAlert(card, usagePercentage, "WARNING");
        }
        // 90%告警
        else if (usagePercentage >= 90 && usagePercentage < 100) {
            alertService.sendDataUsageAlert(card, usagePercentage, "CRITICAL");
        }
        // 超限告警
        else if (usagePercentage >= 100) {
            alertService.sendDataUsageAlert(card, usagePercentage, "EXCEEDED");
            // 可选择暂停服务
            if (shouldSuspendOnExceed(card)) {
                suspendCardForDataExceed(card);
            }
        }
    }
    
    /**
     * 获取流量使用统计
     */
    public IoTDataUsageStatistics getUsageStatistics(String iccid, LocalDate startDate, LocalDate endDate) {
        IoTCard card = iotCardRepository.findByIccid(iccid)
            .orElseThrow(() -> new IoTCardNotFoundException("IoT card not found: " + iccid));
        
        List<DataUsageRecord> records = usageRecordRepository
            .findByIccidAndUsageTimeBetween(iccid, 
                startDate.atStartOfDay(), 
                endDate.atTime(23, 59, 59));
        
        return IoTDataUsageStatistics.builder()
            .iccid(iccid)
            .totalDataUsed(records.stream().mapToLong(DataUsageRecord::getDataUsed).sum())
            .sessionCount(records.size())
            .averageSessionData(records.isEmpty() ? 0 : 
                records.stream().mapToLong(DataUsageRecord::getDataUsed).average().orElse(0))
            .peakUsageDay(findPeakUsageDay(records))
            .dailyUsageBreakdown(calculateDailyUsage(records))
            .monthlyLimit(card.getMonthlyDataLimit())
            .remainingData(card.getMonthlyDataLimit() - card.getCurrentMonthDataUsed())
            .usagePercentage((double) card.getCurrentMonthDataUsed() / card.getMonthlyDataLimit() * 100)
            .build();
    }
    
    /**
     * 重置月度流量统计
     */
    @Scheduled(cron = "0 0 0 1 * ?") // 每月1号零点执行
    @Transactional
    public void resetMonthlyDataUsage() {
        log.info("Resetting monthly data usage for all IoT cards");
        
        List<IoTCard> activeCards = iotCardRepository.findByStatus(IoTCardStatus.ACTIVE);
        
        for (IoTCard card : activeCards) {
            card.setCurrentMonthDataUsed(0L);
            card.setUpdateTime(LocalDateTime.now());
        }
        
        iotCardRepository.saveAll(activeCards);
        
        log.info("Monthly data usage reset completed for {} cards", activeCards.size());
    }
    
    // 辅助方法
    private boolean shouldSuspendOnExceed(IoTCard card) {
        // 根据客户配置决定是否超限暂停
        return true; // 示例：默认超限暂停
    }
    
    private void suspendCardForDataExceed(IoTCard card) {
        card.setStatus(IoTCardStatus.SUSPENDED);
        card.setUpdateTime(LocalDateTime.now());
        iotCardRepository.save(card);
        
        log.warn("IoT card suspended due to data limit exceeded: {}", card.getIccid());
    }
    
    private LocalDate findPeakUsageDay(List<DataUsageRecord> records) {
        return records.stream()
            .collect(Collectors.groupingBy(
                record -> record.getUsageTime().toLocalDate(),
                Collectors.summingLong(DataUsageRecord::getDataUsed)))
            .entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }
    
    private Map<LocalDate, Long> calculateDailyUsage(List<DataUsageRecord> records) {
        return records.stream()
            .collect(Collectors.groupingBy(
                record -> record.getUsageTime().toLocalDate(),
                Collectors.summingLong(DataUsageRecord::getDataUsed)));
    }
}
```

## 连接管理与监控

### 连接状态监控
```java
/**
 * 物联网卡连接监控服务
 */
@Service
@Slf4j
public class IoTConnectionMonitoringService {
    
    @Autowired
    private IoTCardRepository iotCardRepository;
    
    @Autowired
    private ConnectionEventRepository connectionEventRepository;
    
    @Autowired
    private AlertService alertService;
    
    /**
     * 记录连接事件
     */
    @Async
    public void recordConnectionEvent(IoTConnectionEvent event) {
        log.debug("Recording connection event for card: {}, type: {}", 
            event.getIccid(), event.getEventType());
        
        try {
            // 保存连接事件
            connectionEventRepository.save(event);
            
            // 更新卡的连接信息
            updateCardConnectionInfo(event);
            
            // 检查连接异常
            checkConnectionAnomalies(event);
            
        } catch (Exception e) {
            log.error("Failed to record connection event", e);
        }
    }
    
    /**
     * 更新卡连接信息
     */
    private void updateCardConnectionInfo(IoTConnectionEvent event) {
        iotCardRepository.findByIccid(event.getIccid()).ifPresent(card -> {
            if (event.getEventType() == ConnectionEventType.CONNECT) {
                card.setLastConnectionTime(event.getEventTime());
                card.setLastLocation(event.getLocation());
                card.setConnectionCount(card.getConnectionCount() + 1);
            }
            card.setUpdateTime(LocalDateTime.now());
            iotCardRepository.save(card);
        });
    }
    
    /**
     * 检查连接异常
     */
    private void checkConnectionAnomalies(IoTConnectionEvent event) {
        String iccid = event.getIccid();
        
        // 检查频繁连接
        if (isFrequentConnection(iccid)) {
            alertService.sendConnectionAlert(iccid, "FREQUENT_CONNECTION", 
                "Device connecting too frequently");
        }
        
        // 检查连接失败
        if (event.getEventType() == ConnectionEventType.CONNECT_FAILED) {
            int failureCount = getRecentFailureCount(iccid);
            if (failureCount >= 5) {
                alertService.sendConnectionAlert(iccid, "REPEATED_FAILURES", 
                    "Multiple connection failures detected");
            }
        }
        
        // 检查异常位置
        if (isAbnormalLocation(event)) {
            alertService.sendConnectionAlert(iccid, "ABNORMAL_LOCATION", 
                "Device detected in unexpected location");
        }
    }
    
    /**
     * 获取连接统计
     */
    public IoTConnectionStatistics getConnectionStatistics(String iccid, 
                                                         LocalDateTime startTime, 
                                                         LocalDateTime endTime) {
        List<IoTConnectionEvent> events = connectionEventRepository
            .findByIccidAndEventTimeBetween(iccid, startTime, endTime);
        
        long connectCount = events.stream()
            .filter(e -> e.getEventType() == ConnectionEventType.CONNECT)
            .count();
        
        long disconnectCount = events.stream()
            .filter(e -> e.getEventType() == ConnectionEventType.DISCONNECT)
            .count();
        
        long failureCount = events.stream()
            .filter(e -> e.getEventType() == ConnectionEventType.CONNECT_FAILED)
            .count();
        
        double averageSessionDuration = calculateAverageSessionDuration(events);
        
        return IoTConnectionStatistics.builder()
            .iccid(iccid)
            .totalConnections(connectCount)
            .totalDisconnections(disconnectCount)
            .failedConnections(failureCount)
            .successRate(connectCount > 0 ? (double) connectCount / (connectCount + failureCount) * 100 : 0)
            .averageSessionDuration(averageSessionDuration)
            .peakConnectionTime(findPeakConnectionTime(events))
            .uniqueLocations(getUniqueLocations(events))
            .build();
    }
    
    /**
     * 监控离线设备
     */
    @Scheduled(fixedRate = 300000) // 每5分钟检查一次
    public void monitorOfflineDevices() {
        log.debug("Monitoring offline IoT devices");
        
        LocalDateTime threshold = LocalDateTime.now().minusHours(24);
        
        List<IoTCard> offlineCards = iotCardRepository
            .findByStatusAndLastConnectionTimeBefore(IoTCardStatus.ACTIVE, threshold);
        
        for (IoTCard card : offlineCards) {
            // 检查是否应该发送离线告警
            if (shouldAlertForOfflineDevice(card)) {
                alertService.sendOfflineAlert(card);
            }
        }
    }
    
    // 辅助方法
    private boolean isFrequentConnection(String iccid) {
        LocalDateTime oneHourAgo = LocalDateTime.now().minusHours(1);
        long recentConnections = connectionEventRepository
            .countByIccidAndEventTypeAndEventTimeAfter(
                iccid, ConnectionEventType.CONNECT, oneHourAgo);
        return recentConnections > 100; // 1小时内超过100次连接
    }
    
    private int getRecentFailureCount(String iccid) {
        LocalDateTime oneHourAgo = LocalDateTime.now().minusHours(1);
        return (int) connectionEventRepository
            .countByIccidAndEventTypeAndEventTimeAfter(
                iccid, ConnectionEventType.CONNECT_FAILED, oneHourAgo);
    }
    
    private boolean isAbnormalLocation(IoTConnectionEvent event) {
        // 检查位置是否异常（简化实现）
        return event.getLocation() != null && 
               event.getLocation().contains("UNKNOWN");
    }
    
    private double calculateAverageSessionDuration(List<IoTConnectionEvent> events) {
        // 计算平均会话时长（简化实现）
        return 300.0; // 示例：5分钟
    }
    
    private LocalDateTime findPeakConnectionTime(List<IoTConnectionEvent> events) {
        return events.stream()
            .filter(e -> e.getEventType() == ConnectionEventType.CONNECT)
            .collect(Collectors.groupingBy(
                e -> e.getEventTime().withMinute(0).withSecond(0),
                Collectors.counting()))
            .entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }
    
    private Set<String> getUniqueLocations(List<IoTConnectionEvent> events) {
        return events.stream()
            .map(IoTConnectionEvent::getLocation)
            .filter(Objects::nonNull)
            .collect(Collectors.toSet());
    }
    
    private boolean shouldAlertForOfflineDevice(IoTCard card) {
        // 根据设备类型和客户配置决定是否告警
        return card.getLastConnectionTime() != null && 
               card.getLastConnectionTime().isBefore(LocalDateTime.now().minusDays(1));
    }
}
```

## Demo脚本示例

### 物联网卡管理Demo
```bash
#!/bin/bash
# 物联网卡管理Demo脚本

echo "=== 物联网卡管理Demo ==="

# 1. 批量创建NB-IoT卡
echo "1. 批量创建NB-IoT卡..."
curl -X POST http://localhost:8080/api/v1/iot-cards/batch-create \
  -H "Content-Type: application/json" \
  -d '{
    "quantity": 100,
    "cardType": "NB_IOT",
    "applicationScenario": "SMART_METER",
    "customerId": "CUSTOMER_001",
    "customerName": "智能电表公司",
    "packageId": "PKG_NBIOT_BASIC",
    "networkOperator": "CHINA_MOBILE",
    "isRoamingEnabled": false
  }'

# 2. 激活物联网卡
echo "\n2. 激活物联网卡..."
curl -X POST http://localhost:8080/api/v1/iot-cards/89860123456789012345/activate \
  -H "Content-Type: application/json" \
  -d '{
    "deviceId": "METER_001",
    "deviceType": "SMART_WATER_METER",
    "location": "北京市朝阳区"
  }'

# 3. 记录数据使用
echo "\n3. 记录数据使用..."
curl -X POST http://localhost:8080/api/v1/iot-cards/data-usage \
  -H "Content-Type: application/json" \
  -d '{
    "iccid": "89860123456789012345",
    "dataUsed": 1024,
    "sessionId": "SESSION_001",
    "location": "北京市朝阳区"
  }'

# 4. 查询流量统计
echo "\n4. 查询流量统计..."
curl -X GET "http://localhost:8080/api/v1/iot-cards/89860123456789012345/usage-statistics?startDate=2024-01-01&endDate=2024-01-31"

# 5. 查询连接统计
echo "\n5. 查询连接统计..."
curl -X GET "http://localhost:8080/api/v1/iot-cards/89860123456789012345/connection-statistics?startTime=2024-01-01T00:00:00&endTime=2024-01-31T23:59:59"

# 6. 暂停物联网卡
echo "\n6. 暂停物联网卡..."
curl -X POST http://localhost:8080/api/v1/iot-cards/89860123456789012345/suspend \
  -H "Content-Type: application/json" \
  -d '{
    "reason": "客户申请暂停服务"
  }'

# 7. 恢复物联网卡
echo "\n7. 恢复物联网卡..."
curl -X POST http://localhost:8080/api/v1/iot-cards/89860123456789012345/resume

echo "\n物联网卡管理Demo完成！"
```

### 智能抄表场景Demo
```bash
#!/bin/bash
# 智能抄表场景Demo脚本

echo "=== 智能抄表场景Demo ==="

# 1. 为水务公司创建NB-IoT卡
echo "1. 为水务公司创建NB-IoT卡..."
curl -X POST http://localhost:8080/api/v1/iot-cards/batch-create \
  -H "Content-Type: application/json" \
  -d '{
    "quantity": 1000,
    "cardType": "NB_IOT",
    "applicationScenario": "SMART_METER",
    "customerId": "WATER_COMPANY_001",
    "customerName": "北京市自来水公司",
    "packageId": "PKG_NBIOT_METER",
    "networkOperator": "CHINA_TELECOM",
    "isRoamingEnabled": false
  }'

# 2. 批量激活水表设备
echo "\n2. 批量激活水表设备..."
for i in {1..10}; do
  iccid="8986012345678901234${i}"
  device_id="WATER_METER_$(printf "%03d" $i)"
  
  curl -X POST http://localhost:8080/api/v1/iot-cards/${iccid}/activate \
    -H "Content-Type: application/json" \
    -d "{
      \"deviceId\": \"${device_id}\",
      \"deviceType\": \"SMART_WATER_METER\",
      \"location\": \"北京市朝阳区小区${i}号楼\"
    }"
  
  sleep 1
done

# 3. 模拟水表数据上报
echo "\n3. 模拟水表数据上报..."
for i in {1..10}; do
  iccid="8986012345678901234${i}"
  data_used=$((RANDOM % 100 + 50)) # 50-150KB随机数据
  
  curl -X POST http://localhost:8080/api/v1/iot-cards/data-usage \
    -H "Content-Type: application/json" \
    -d "{
      \"iccid\": \"${iccid}\",
      \"dataUsed\": ${data_used},
      \"sessionId\": \"METER_SESSION_${i}_$(date +%s)\",
      \"location\": \"北京市朝阳区小区${i}号楼\"
    }"
  
  sleep 0.5
done

# 4. 查询整体使用情况
echo "\n4. 查询整体使用情况..."
curl -X GET "http://localhost:8080/api/v1/iot-cards/statistics/customer/WATER_COMPANY_001"

echo "\n智能抄表场景Demo完成！"
```

## 最佳实践总结

### 1. 卡片管理策略
- **分类管理**: 根据应用场景选择合适的卡类型
- **生命周期管理**: 建立完整的状态流转机制
- **批量操作**: 支持大规模卡片的批量管理
- **设备绑定**: 建立卡片与设备的关联关系

### 2. 流量监控要点
- **实时监控**: 实时跟踪流量使用情况
- **阈值告警**: 设置多级流量告警阈值
- **自动控制**: 超限自动暂停或限速
- **统计分析**: 提供详细的使用统计报告

### 3. 连接管理优化
- **连接监控**: 监控设备连接状态和质量
- **异常检测**: 及时发现连接异常和安全威胁
- **性能优化**: 优化连接参数提升稳定性
- **故障处理**: 建立快速故障定位和处理机制

### 4. 安全保障措施
- **身份认证**: 强化设备身份认证机制
- **数据加密**: 确保数据传输安全
- **访问控制**: 实施细粒度访问控制
- **安全审计**: 建立完整的安全审计体系

通过实施以上物联网卡管理方案，NSRS号卡资源管理系统能够为各种物联网应用场景提供专业、可靠的卡片管理服务，支撑物联网产业的快速发展。