# 电信计费规范详解

## 概述

电信计费系统是电信运营商的核心业务支撑系统，负责对用户使用的各种电信服务进行计费和收费。本文档详细阐述电信计费的相关规范、标准和在NSRS号卡资源管理系统中的实现方案。

## 计费系统架构

### 计费系统组成
- **实时计费系统 (OCS)**: Online Charging System
- **离线计费系统 (OFCS)**: Offline Charging System  
- **计费数据记录 (CDR)**: Call Detail Record
- **计费网关 (CGF)**: Charging Gateway Function
- **计费触发功能 (CTF)**: Charging Trigger Function

### 计费模式
```java
/**
 * 计费模式枚举
 */
public enum ChargingMode {
    PREPAID("预付费", "用户预先充值，实时扣费"),
    POSTPAID("后付费", "用户先使用后付费"),
    HYBRID("混合计费", "预付费和后付费混合模式"),
    FREE("免费", "免费服务，不计费");
    
    private final String description;
    private final String detail;
    
    ChargingMode(String description, String detail) {
        this.description = description;
        this.detail = detail;
    }
    
    public String getDescription() { return description; }
    public String getDetail() { return detail; }
}

/**
 * 计费类型枚举
 */
public enum ChargingType {
    DURATION_BASED("时长计费", "按通话时长计费"),
    VOLUME_BASED("流量计费", "按数据流量计费"),
    EVENT_BASED("事件计费", "按事件次数计费"),
    CONTENT_BASED("内容计费", "按内容价值计费"),
    FLAT_RATE("包月计费", "固定费率计费"),
    TIERED_RATE("阶梯计费", "分层费率计费");
    
    private final String description;
    private final String detail;
    
    ChargingType(String description, String detail) {
        this.description = description;
        this.detail = detail;
    }
    
    public String getDescription() { return description; }
    public String getDetail() { return detail; }
}
```

## 实时计费系统 (OCS)

### OCS核心功能实现
```java
/**
 * 在线计费系统服务
 */
@Service
@Slf4j
public class OnlineChargingService {
    
    @Autowired
    private AccountService accountService;
    
    @Autowired
    private RatingService ratingService;
    
    @Autowired
    private QuotaService quotaService;
    
    @Autowired
    private ChargingEventRepository chargingEventRepository;
    
    /**
     * 处理计费请求
     */
    public ChargingResponse processChargingRequest(ChargingRequest request) {
        log.info("Processing charging request for MSISDN: {}, Service: {}", 
            maskMsisdn(request.getMsisdn()), request.getServiceType());
        
        try {
            // 1. 验证用户账户
            Account account = accountService.getAccountByMsisdn(request.getMsisdn());
            if (account == null) {
                return ChargingResponse.error("ACCOUNT_NOT_FOUND", "Account not found");
            }
            
            // 2. 检查账户状态
            if (!isAccountActive(account)) {
                return ChargingResponse.error("ACCOUNT_INACTIVE", "Account is not active");
            }
            
            // 3. 费率计算
            RatingResult ratingResult = ratingService.calculateCharges(
                request.getMsisdn(), 
                request.getServiceType(), 
                request.getUsageInfo());
            
            // 4. 余额检查和预留
            if (account.getChargingMode() == ChargingMode.PREPAID) {
                return handlePrepaidCharging(account, request, ratingResult);
            } else {
                return handlePostpaidCharging(account, request, ratingResult);
            }
            
        } catch (Exception e) {
            log.error("Failed to process charging request for MSISDN: {}", 
                maskMsisdn(request.getMsisdn()), e);
            return ChargingResponse.error("SYSTEM_ERROR", "System error occurred");
        }
    }
    
    /**
     * 处理预付费计费
     */
    private ChargingResponse handlePrepaidCharging(Account account, 
                                                  ChargingRequest request, 
                                                  RatingResult ratingResult) {
        log.debug("Handling prepaid charging for account: {}", account.getAccountId());
        
        // 检查余额是否足够
        if (account.getBalance().compareTo(ratingResult.getTotalCharge()) < 0) {
            return ChargingResponse.error("INSUFFICIENT_BALANCE", 
                "Insufficient balance for the requested service");
        }
        
        // 预留金额
        BigDecimal reservedAmount = ratingResult.getTotalCharge();
        boolean reservationSuccess = accountService.reserveBalance(
            account.getAccountId(), reservedAmount);
        
        if (!reservationSuccess) {
            return ChargingResponse.error("RESERVATION_FAILED", 
                "Failed to reserve balance");
        }
        
        // 分配配额
        QuotaAllocation quotaAllocation = quotaService.allocateQuota(
            account.getAccountId(), 
            request.getServiceType(), 
            ratingResult);
        
        // 记录计费事件
        recordChargingEvent(account, request, ratingResult, "GRANTED");
        
        return ChargingResponse.success(
            quotaAllocation.getGrantedQuota(),
            quotaAllocation.getValidityTime(),
            ratingResult.getTotalCharge());
    }
    
    /**
     * 处理后付费计费
     */
    private ChargingResponse handlePostpaidCharging(Account account, 
                                                   ChargingRequest request, 
                                                   RatingResult ratingResult) {
        log.debug("Handling postpaid charging for account: {}", account.getAccountId());
        
        // 检查信用额度
        BigDecimal creditLimit = account.getCreditLimit();
        BigDecimal currentDebt = account.getCurrentDebt();
        BigDecimal availableCredit = creditLimit.subtract(currentDebt);
        
        if (availableCredit.compareTo(ratingResult.getTotalCharge()) < 0) {
            return ChargingResponse.error("CREDIT_LIMIT_EXCEEDED", 
                "Credit limit exceeded");
        }
        
        // 增加债务
        accountService.addDebt(account.getAccountId(), ratingResult.getTotalCharge());
        
        // 分配配额（后付费通常给予更大的配额）
        QuotaAllocation quotaAllocation = quotaService.allocatePostpaidQuota(
            account.getAccountId(), 
            request.getServiceType());
        
        // 记录计费事件
        recordChargingEvent(account, request, ratingResult, "GRANTED");
        
        return ChargingResponse.success(
            quotaAllocation.getGrantedQuota(),
            quotaAllocation.getValidityTime(),
            ratingResult.getTotalCharge());
    }
    
    /**
     * 处理配额使用报告
     */
    public ChargingResponse processUsageReport(UsageReportRequest request) {
        log.info("Processing usage report for session: {}", request.getSessionId());
        
        try {
            // 1. 获取会话信息
            ChargingSession session = getChargingSession(request.getSessionId());
            if (session == null) {
                return ChargingResponse.error("SESSION_NOT_FOUND", "Session not found");
            }
            
            // 2. 计算实际使用费用
            RatingResult actualUsage = ratingService.calculateActualUsage(
                session.getMsisdn(),
                session.getServiceType(),
                request.getUsedQuota());
            
            // 3. 调整账户余额/债务
            adjustAccountBalance(session, actualUsage);
            
            // 4. 更新配额
            QuotaAllocation newQuota = quotaService.updateQuota(
                session.getAccountId(),
                request.getUsedQuota(),
                request.getRemainingQuota());
            
            // 5. 记录使用事件
            recordUsageEvent(session, request, actualUsage);
            
            return ChargingResponse.success(
                newQuota.getGrantedQuota(),
                newQuota.getValidityTime(),
                actualUsage.getTotalCharge());
            
        } catch (Exception e) {
            log.error("Failed to process usage report for session: {}", 
                request.getSessionId(), e);
            return ChargingResponse.error("SYSTEM_ERROR", "System error occurred");
        }
    }
    
    /**
     * 处理会话终止
     */
    public ChargingResponse processSessionTermination(SessionTerminationRequest request) {
        log.info("Processing session termination for session: {}", request.getSessionId());
        
        try {
            ChargingSession session = getChargingSession(request.getSessionId());
            if (session == null) {
                return ChargingResponse.error("SESSION_NOT_FOUND", "Session not found");
            }
            
            // 计算最终费用
            RatingResult finalUsage = ratingService.calculateFinalUsage(
                session.getMsisdn(),
                session.getServiceType(),
                request.getTotalUsedQuota());
            
            // 释放预留余额并扣除实际费用
            finalizeCharging(session, finalUsage);
            
            // 回收未使用配额
            quotaService.reclaimUnusedQuota(
                session.getAccountId(),
                request.getUnusedQuota());
            
            // 关闭会话
            closeChargingSession(session.getSessionId());
            
            // 记录会话终止事件
            recordSessionTerminationEvent(session, request, finalUsage);
            
            return ChargingResponse.success(null, null, finalUsage.getTotalCharge());
            
        } catch (Exception e) {
            log.error("Failed to process session termination for session: {}", 
                request.getSessionId(), e);
            return ChargingResponse.error("SYSTEM_ERROR", "System error occurred");
        }
    }
    
    // 辅助方法
    private boolean isAccountActive(Account account) {
        return account.getStatus() == AccountStatus.ACTIVE;
    }
    
    private void recordChargingEvent(Account account, ChargingRequest request, 
                                   RatingResult ratingResult, String result) {
        ChargingEvent event = ChargingEvent.builder()
            .accountId(account.getAccountId())
            .msisdn(request.getMsisdn())
            .serviceType(request.getServiceType())
            .chargingMode(account.getChargingMode())
            .requestedQuota(request.getRequestedQuota())
            .chargedAmount(ratingResult.getTotalCharge())
            .result(result)
            .timestamp(LocalDateTime.now())
            .build();
        
        chargingEventRepository.save(event);
    }
    
    private ChargingSession getChargingSession(String sessionId) {
        // 从会话存储中获取计费会话
        return ChargingSession.builder()
            .sessionId(sessionId)
            .accountId(12345L)
            .msisdn("86138****1234")
            .serviceType(ServiceType.DATA)
            .startTime(LocalDateTime.now().minusHours(1))
            .build();
    }
    
    private void adjustAccountBalance(ChargingSession session, RatingResult actualUsage) {
        // 调整账户余额或债务
        log.debug("Adjusting account balance for session: {}", session.getSessionId());
    }
    
    private void recordUsageEvent(ChargingSession session, UsageReportRequest request, 
                                RatingResult actualUsage) {
        // 记录使用事件
        log.debug("Recording usage event for session: {}", session.getSessionId());
    }
    
    private void finalizeCharging(ChargingSession session, RatingResult finalUsage) {
        // 最终化计费
        log.debug("Finalizing charging for session: {}", session.getSessionId());
    }
    
    private void closeChargingSession(String sessionId) {
        // 关闭计费会话
        log.debug("Closing charging session: {}", sessionId);
    }
    
    private void recordSessionTerminationEvent(ChargingSession session, 
                                             SessionTerminationRequest request, 
                                             RatingResult finalUsage) {
        // 记录会话终止事件
        log.debug("Recording session termination for session: {}", session.getSessionId());
    }
    
    private String maskMsisdn(String msisdn) {
        if (msisdn == null || msisdn.length() < 7) {
            return msisdn;
        }
        return msisdn.substring(0, 3) + "****" + msisdn.substring(7);
    }
}
```

## 费率引擎系统

### 费率计算服务
```java
/**
 * 费率计算服务
 */
@Service
@Slf4j
public class RatingService {
    
    @Autowired
    private TariffRepository tariffRepository;
    
    @Autowired
    private PromotionService promotionService;
    
    @Autowired
    private RoamingService roamingService;
    
    /**
     * 计算费用
     */
    public RatingResult calculateCharges(String msisdn, ServiceType serviceType, 
                                       UsageInfo usageInfo) {
        log.debug("Calculating charges for MSISDN: {}, Service: {}", 
            maskMsisdn(msisdn), serviceType);
        
        try {
            // 1. 获取用户资费套餐
            TariffPlan tariffPlan = getTariffPlan(msisdn);
            
            // 2. 获取适用的费率
            List<Rate> applicableRates = getApplicableRates(
                tariffPlan, serviceType, usageInfo);
            
            // 3. 计算基础费用
            BigDecimal baseCharge = calculateBaseCharge(applicableRates, usageInfo);
            
            // 4. 应用促销优惠
            BigDecimal discount = promotionService.calculateDiscount(
                msisdn, serviceType, baseCharge);
            
            // 5. 计算漫游费用
            BigDecimal roamingCharge = BigDecimal.ZERO;
            if (usageInfo.isRoaming()) {
                roamingCharge = roamingService.calculateRoamingCharge(
                    msisdn, usageInfo.getVisitedNetwork(), serviceType, usageInfo);
            }
            
            // 6. 计算税费
            BigDecimal tax = calculateTax(baseCharge.add(roamingCharge).subtract(discount));
            
            // 7. 计算总费用
            BigDecimal totalCharge = baseCharge
                .add(roamingCharge)
                .subtract(discount)
                .add(tax);
            
            return RatingResult.builder()
                .baseCharge(baseCharge)
                .roamingCharge(roamingCharge)
                .discount(discount)
                .tax(tax)
                .totalCharge(totalCharge)
                .currency(tariffPlan.getCurrency())
                .ratingTime(LocalDateTime.now())
                .build();
            
        } catch (Exception e) {
            log.error("Failed to calculate charges for MSISDN: {}", 
                maskMsisdn(msisdn), e);
            throw new RatingException("Failed to calculate charges", e);
        }
    }
    
    /**
     * 计算基础费用
     */
    private BigDecimal calculateBaseCharge(List<Rate> rates, UsageInfo usageInfo) {
        BigDecimal totalCharge = BigDecimal.ZERO;
        
        for (Rate rate : rates) {
            BigDecimal charge = BigDecimal.ZERO;
            
            switch (rate.getChargingType()) {
                case DURATION_BASED:
                    charge = calculateDurationCharge(rate, usageInfo.getDuration());
                    break;
                case VOLUME_BASED:
                    charge = calculateVolumeCharge(rate, usageInfo.getVolume());
                    break;
                case EVENT_BASED:
                    charge = calculateEventCharge(rate, usageInfo.getEventCount());
                    break;
                case FLAT_RATE:
                    charge = rate.getFlatRate();
                    break;
                case TIERED_RATE:
                    charge = calculateTieredCharge(rate, usageInfo);
                    break;
            }
            
            totalCharge = totalCharge.add(charge);
        }
        
        return totalCharge;
    }
    
    /**
     * 计算时长费用
     */
    private BigDecimal calculateDurationCharge(Rate rate, Duration duration) {
        if (duration == null) {
            return BigDecimal.ZERO;
        }
        
        long seconds = duration.getSeconds();
        BigDecimal units = BigDecimal.valueOf(seconds)
            .divide(BigDecimal.valueOf(rate.getTimeUnit()), 2, RoundingMode.CEILING);
        
        return units.multiply(rate.getUnitPrice());
    }
    
    /**
     * 计算流量费用
     */
    private BigDecimal calculateVolumeCharge(Rate rate, Long volume) {
        if (volume == null || volume == 0) {
            return BigDecimal.ZERO;
        }
        
        BigDecimal units = BigDecimal.valueOf(volume)
            .divide(BigDecimal.valueOf(rate.getVolumeUnit()), 2, RoundingMode.CEILING);
        
        return units.multiply(rate.getUnitPrice());
    }
    
    /**
     * 计算事件费用
     */
    private BigDecimal calculateEventCharge(Rate rate, Integer eventCount) {
        if (eventCount == null || eventCount == 0) {
            return BigDecimal.ZERO;
        }
        
        return BigDecimal.valueOf(eventCount).multiply(rate.getUnitPrice());
    }
    
    /**
     * 计算阶梯费用
     */
    private BigDecimal calculateTieredCharge(Rate rate, UsageInfo usageInfo) {
        BigDecimal totalCharge = BigDecimal.ZERO;
        Long remainingUsage = usageInfo.getVolume();
        
        List<RateTier> tiers = rate.getRateTiers();
        for (RateTier tier : tiers) {
            if (remainingUsage <= 0) {
                break;
            }
            
            Long tierUsage = Math.min(remainingUsage, tier.getUpperLimit() - tier.getLowerLimit());
            BigDecimal tierCharge = BigDecimal.valueOf(tierUsage)
                .multiply(tier.getUnitPrice());
            
            totalCharge = totalCharge.add(tierCharge);
            remainingUsage -= tierUsage;
        }
        
        return totalCharge;
    }
    
    /**
     * 计算税费
     */
    private BigDecimal calculateTax(BigDecimal chargeableAmount) {
        // 假设税率为10%
        BigDecimal taxRate = new BigDecimal("0.10");
        return chargeableAmount.multiply(taxRate).setScale(2, RoundingMode.HALF_UP);
    }
    
    // 辅助方法
    private TariffPlan getTariffPlan(String msisdn) {
        // 获取用户的资费套餐
        return TariffPlan.builder()
            .planId("PLAN_001")
            .planName("标准套餐")
            .currency("CNY")
            .build();
    }
    
    private List<Rate> getApplicableRates(TariffPlan tariffPlan, 
                                        ServiceType serviceType, 
                                        UsageInfo usageInfo) {
        // 获取适用的费率
        return tariffRepository.findApplicableRates(
            tariffPlan.getPlanId(), 
            serviceType, 
            usageInfo.getTimeOfDay(),
            usageInfo.getDayOfWeek());
    }
    
    private String maskMsisdn(String msisdn) {
        if (msisdn == null || msisdn.length() < 7) {
            return msisdn;
        }
        return msisdn.substring(0, 3) + "****" + msisdn.substring(7);
    }
}
```

## CDR处理系统

### CDR生成和处理
```java
/**
 * CDR处理服务
 */
@Service
@Slf4j
public class CdrProcessingService {
    
    @Autowired
    private CdrRepository cdrRepository;
    
    @Autowired
    private BillingService billingService;
    
    @Autowired
    private FraudDetectionService fraudDetectionService;
    
    /**
     * 生成语音CDR
     */
    public VoiceCdr generateVoiceCdr(VoiceCallEvent callEvent) {
        log.debug("Generating voice CDR for call: {}", callEvent.getCallId());
        
        VoiceCdr cdr = VoiceCdr.builder()
            .cdrId(generateCdrId())
            .recordType(CdrType.VOICE)
            .callingParty(callEvent.getCallingParty())
            .calledParty(callEvent.getCalledParty())
            .callStartTime(callEvent.getStartTime())
            .callEndTime(callEvent.getEndTime())
            .callDuration(Duration.between(callEvent.getStartTime(), callEvent.getEndTime()))
            .originatingCellId(callEvent.getOriginatingCellId())
            .terminatingCellId(callEvent.getTerminatingCellId())
            .serviceType(ServiceType.VOICE)
            .chargedParty(determineChargedParty(callEvent))
            .chargingMode(getChargingMode(callEvent.getCallingParty()))
            .recordOpeningTime(LocalDateTime.now())
            .recordClosureTime(LocalDateTime.now())
            .causeForRecordClosing("NORMAL_RELEASE")
            .build();
        
        // 保存CDR
        cdrRepository.save(cdr);
        
        // 触发计费处理
        triggerBillingProcess(cdr);
        
        return cdr;
    }
    
    /**
     * 生成数据CDR
     */
    public DataCdr generateDataCdr(DataSessionEvent sessionEvent) {
        log.debug("Generating data CDR for session: {}", sessionEvent.getSessionId());
        
        DataCdr cdr = DataCdr.builder()
            .cdrId(generateCdrId())
            .recordType(CdrType.DATA)
            .msisdn(sessionEvent.getMsisdn())
            .imsi(sessionEvent.getImsi())
            .sessionStartTime(sessionEvent.getStartTime())
            .sessionEndTime(sessionEvent.getEndTime())
            .sessionDuration(Duration.between(sessionEvent.getStartTime(), sessionEvent.getEndTime()))
            .upLinkVolume(sessionEvent.getUpLinkVolume())
            .downLinkVolume(sessionEvent.getDownLinkVolume())
            .totalVolume(sessionEvent.getUpLinkVolume() + sessionEvent.getDownLinkVolume())
            .apn(sessionEvent.getApn())
            .pdpType(sessionEvent.getPdpType())
            .servingNodeAddress(sessionEvent.getServingNodeAddress())
            .chargingId(sessionEvent.getChargingId())
            .serviceType(ServiceType.DATA)
            .chargingMode(getChargingMode(sessionEvent.getMsisdn()))
            .recordOpeningTime(LocalDateTime.now())
            .recordClosureTime(LocalDateTime.now())
            .causeForRecordClosing("NORMAL_RELEASE")
            .build();
        
        // 保存CDR
        cdrRepository.save(cdr);
        
        // 触发计费处理
        triggerBillingProcess(cdr);
        
        return cdr;
    }
    
    /**
     * 生成短信CDR
     */
    public SmsCdr generateSmsCdr(SmsEvent smsEvent) {
        log.debug("Generating SMS CDR for message: {}", smsEvent.getMessageId());
        
        SmsCdr cdr = SmsCdr.builder()
            .cdrId(generateCdrId())
            .recordType(CdrType.SMS)
            .originatingNumber(smsEvent.getOriginatingNumber())
            .destinationNumber(smsEvent.getDestinationNumber())
            .messageReference(smsEvent.getMessageReference())
            .messageType(smsEvent.getMessageType())
            .messageStatus(smsEvent.getMessageStatus())
            .submitTime(smsEvent.getSubmitTime())
            .deliveryTime(smsEvent.getDeliveryTime())
            .messageLength(smsEvent.getMessageLength())
            .serviceType(ServiceType.SMS)
            .chargingMode(getChargingMode(smsEvent.getOriginatingNumber()))
            .recordOpeningTime(LocalDateTime.now())
            .recordClosureTime(LocalDateTime.now())
            .causeForRecordClosing("NORMAL_DELIVERY")
            .build();
        
        // 保存CDR
        cdrRepository.save(cdr);
        
        // 触发计费处理
        triggerBillingProcess(cdr);
        
        return cdr;
    }
    
    /**
     * 批量处理CDR
     */
    @Scheduled(fixedRate = 60000) // 每分钟执行一次
    public void processCdrBatch() {
        log.debug("Starting CDR batch processing");
        
        try {
            // 获取待处理的CDR
            List<BaseCdr> pendingCdrs = cdrRepository.findPendingCdrs(1000);
            
            if (pendingCdrs.isEmpty()) {
                log.debug("No pending CDRs found");
                return;
            }
            
            log.info("Processing {} CDRs", pendingCdrs.size());
            
            // 分批处理CDR
            List<List<BaseCdr>> batches = partitionList(pendingCdrs, 100);
            
            for (List<BaseCdr> batch : batches) {
                processCdrBatchInternal(batch);
            }
            
            log.info("CDR batch processing completed");
            
        } catch (Exception e) {
            log.error("Failed to process CDR batch", e);
        }
    }
    
    /**
     * 内部批处理方法
     */
    private void processCdrBatchInternal(List<BaseCdr> cdrs) {
        for (BaseCdr cdr : cdrs) {
            try {
                // 1. 验证CDR
                if (!validateCdr(cdr)) {
                    markCdrAsError(cdr, "CDR validation failed");
                    continue;
                }
                
                // 2. 欺诈检测
                if (fraudDetectionService.detectFraud(cdr)) {
                    markCdrAsFraud(cdr);
                    continue;
                }
                
                // 3. 费率计算
                RatingResult ratingResult = calculateCdrCharges(cdr);
                
                // 4. 更新账单
                billingService.updateBill(cdr, ratingResult);
                
                // 5. 标记CDR为已处理
                markCdrAsProcessed(cdr);
                
            } catch (Exception e) {
                log.error("Failed to process CDR: {}", cdr.getCdrId(), e);
                markCdrAsError(cdr, e.getMessage());
            }
        }
    }
    
    /**
     * 验证CDR
     */
    private boolean validateCdr(BaseCdr cdr) {
        // 基本字段验证
        if (cdr.getCdrId() == null || cdr.getRecordType() == null) {
            return false;
        }
        
        // 时间验证
        if (cdr.getRecordOpeningTime() == null || cdr.getRecordClosureTime() == null) {
            return false;
        }
        
        // 根据CDR类型进行特定验证
        switch (cdr.getRecordType()) {
            case VOICE:
                return validateVoiceCdr((VoiceCdr) cdr);
            case DATA:
                return validateDataCdr((DataCdr) cdr);
            case SMS:
                return validateSmsCdr((SmsCdr) cdr);
            default:
                return false;
        }
    }
    
    private boolean validateVoiceCdr(VoiceCdr cdr) {
        return cdr.getCallingParty() != null && 
               cdr.getCalledParty() != null && 
               cdr.getCallDuration() != null;
    }
    
    private boolean validateDataCdr(DataCdr cdr) {
        return cdr.getMsisdn() != null && 
               cdr.getTotalVolume() != null && 
               cdr.getTotalVolume() >= 0;
    }
    
    private boolean validateSmsCdr(SmsCdr cdr) {
        return cdr.getOriginatingNumber() != null && 
               cdr.getDestinationNumber() != null;
    }
    
    /**
     * 计算CDR费用
     */
    private RatingResult calculateCdrCharges(BaseCdr cdr) {
        String msisdn = extractMsisdn(cdr);
        ServiceType serviceType = cdr.getServiceType();
        UsageInfo usageInfo = extractUsageInfo(cdr);
        
        return ratingService.calculateCharges(msisdn, serviceType, usageInfo);
    }
    
    // 辅助方法
    private String generateCdrId() {
        return "CDR_" + System.currentTimeMillis() + "_" + 
               ThreadLocalRandom.current().nextInt(1000, 9999);
    }
    
    private String determineChargedParty(VoiceCallEvent callEvent) {
        // 通常主叫方付费
        return callEvent.getCallingParty();
    }
    
    private ChargingMode getChargingMode(String msisdn) {
        // 从用户配置中获取计费模式
        return ChargingMode.PREPAID; // 示例
    }
    
    private void triggerBillingProcess(BaseCdr cdr) {
        // 触发计费处理
        log.debug("Triggering billing process for CDR: {}", cdr.getCdrId());
    }
    
    private <T> List<List<T>> partitionList(List<T> list, int partitionSize) {
        List<List<T>> partitions = new ArrayList<>();
        for (int i = 0; i < list.size(); i += partitionSize) {
            partitions.add(list.subList(i, Math.min(i + partitionSize, list.size())));
        }
        return partitions;
    }
    
    private void markCdrAsError(BaseCdr cdr, String errorMessage) {
        cdr.setProcessingStatus(CdrProcessingStatus.ERROR);
        cdr.setErrorMessage(errorMessage);
        cdrRepository.save(cdr);
    }
    
    private void markCdrAsFraud(BaseCdr cdr) {
        cdr.setProcessingStatus(CdrProcessingStatus.FRAUD);
        cdrRepository.save(cdr);
    }
    
    private void markCdrAsProcessed(BaseCdr cdr) {
        cdr.setProcessingStatus(CdrProcessingStatus.PROCESSED);
        cdrRepository.save(cdr);
    }
    
    private String extractMsisdn(BaseCdr cdr) {
        switch (cdr.getRecordType()) {
            case VOICE:
                return ((VoiceCdr) cdr).getCallingParty();
            case DATA:
                return ((DataCdr) cdr).getMsisdn();
            case SMS:
                return ((SmsCdr) cdr).getOriginatingNumber();
            default:
                return null;
        }
    }
    
    private UsageInfo extractUsageInfo(BaseCdr cdr) {
        switch (cdr.getRecordType()) {
            case VOICE:
                VoiceCdr voiceCdr = (VoiceCdr) cdr;
                return UsageInfo.builder()
                    .duration(voiceCdr.getCallDuration())
                    .timeOfDay(voiceCdr.getCallStartTime().toLocalTime())
                    .dayOfWeek(voiceCdr.getCallStartTime().getDayOfWeek())
                    .build();
            case DATA:
                DataCdr dataCdr = (DataCdr) cdr;
                return UsageInfo.builder()
                    .volume(dataCdr.getTotalVolume())
                    .duration(dataCdr.getSessionDuration())
                    .timeOfDay(dataCdr.getSessionStartTime().toLocalTime())
                    .dayOfWeek(dataCdr.getSessionStartTime().getDayOfWeek())
                    .build();
            case SMS:
                SmsCdr smsCdr = (SmsCdr) cdr;
                return UsageInfo.builder()
                    .eventCount(1)
                    .timeOfDay(smsCdr.getSubmitTime().toLocalTime())
                    .dayOfWeek(smsCdr.getSubmitTime().getDayOfWeek())
                    .build();
            default:
                return UsageInfo.builder().build();
        }
    }
}
```

## 账单生成系统

### 账单服务实现
```java
/**
 * 账单服务
 */
@Service
@Slf4j
public class BillingService {
    
    @Autowired
    private BillRepository billRepository;
    
    @Autowired
    private AccountService accountService;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 生成月度账单
     */
    @Scheduled(cron = "0 0 2 1 * ?") // 每月1日凌晨2点执行
    public void generateMonthlyBills() {
        log.info("Starting monthly bill generation");
        
        try {
            YearMonth billingPeriod = YearMonth.now().minusMonths(1);
            
            // 获取所有活跃账户
            List<Account> activeAccounts = accountService.getActiveAccounts();
            
            log.info("Generating bills for {} accounts for period: {}", 
                activeAccounts.size(), billingPeriod);
            
            // 分批处理账户
            List<List<Account>> batches = partitionList(activeAccounts, 100);
            
            for (List<Account> batch : batches) {
                processBillingBatch(batch, billingPeriod);
            }
            
            log.info("Monthly bill generation completed");
            
        } catch (Exception e) {
            log.error("Failed to generate monthly bills", e);
        }
    }
    
    /**
     * 处理账单批次
     */
    private void processBillingBatch(List<Account> accounts, YearMonth billingPeriod) {
        for (Account account : accounts) {
            try {
                generateAccountBill(account, billingPeriod);
            } catch (Exception e) {
                log.error("Failed to generate bill for account: {}", 
                    account.getAccountId(), e);
            }
        }
    }
    
    /**
     * 生成账户账单
     */
    private void generateAccountBill(Account account, YearMonth billingPeriod) {
        log.debug("Generating bill for account: {} for period: {}", 
            account.getAccountId(), billingPeriod);
        
        // 检查是否已生成账单
        if (billRepository.existsByAccountIdAndBillingPeriod(
                account.getAccountId(), billingPeriod)) {
            log.debug("Bill already exists for account: {} period: {}", 
                account.getAccountId(), billingPeriod);
            return;
        }
        
        // 获取账单期间的使用记录
        List<UsageRecord> usageRecords = getUsageRecords(
            account.getAccountId(), billingPeriod);
        
        // 计算账单明细
        BillDetails billDetails = calculateBillDetails(account, usageRecords);
        
        // 创建账单
        Bill bill = Bill.builder()
            .billId(generateBillId())
            .accountId(account.getAccountId())
            .msisdn(account.getMsisdn())
            .billingPeriod(billingPeriod)
            .billDate(LocalDate.now())
            .dueDate(LocalDate.now().plusDays(30))
            .previousBalance(account.getPreviousBalance())
            .currentCharges(billDetails.getTotalCharges())
            .adjustments(billDetails.getAdjustments())
            .taxes(billDetails.getTaxes())
            .totalAmount(billDetails.getTotalAmount())
            .currency(account.getCurrency())
            .billStatus(BillStatus.GENERATED)
            .billDetails(billDetails)
            .build();
        
        // 保存账单
        billRepository.save(bill);
        
        // 更新账户余额
        updateAccountBalance(account, bill);
        
        // 发送账单通知
        sendBillNotification(account, bill);
        
        log.info("Bill generated successfully for account: {}, amount: {}", 
            account.getAccountId(), bill.getTotalAmount());
    }
    
    /**
     * 计算账单明细
     */
    private BillDetails calculateBillDetails(Account account, List<UsageRecord> usageRecords) {
        BillDetails.BillDetailsBuilder builder = BillDetails.builder();
        
        BigDecimal totalCharges = BigDecimal.ZERO;
        BigDecimal voiceCharges = BigDecimal.ZERO;
        BigDecimal dataCharges = BigDecimal.ZERO;
        BigDecimal smsCharges = BigDecimal.ZERO;
        BigDecimal roamingCharges = BigDecimal.ZERO;
        BigDecimal valueAddedServices = BigDecimal.ZERO;
        
        // 按服务类型汇总费用
        for (UsageRecord record : usageRecords) {
            switch (record.getServiceType()) {
                case VOICE:
                    voiceCharges = voiceCharges.add(record.getChargedAmount());
                    break;
                case DATA:
                    dataCharges = dataCharges.add(record.getChargedAmount());
                    break;
                case SMS:
                    smsCharges = smsCharges.add(record.getChargedAmount());
                    break;
                case ROAMING:
                    roamingCharges = roamingCharges.add(record.getChargedAmount());
                    break;
                case VALUE_ADDED:
                    valueAddedServices = valueAddedServices.add(record.getChargedAmount());
                    break;
            }
            totalCharges = totalCharges.add(record.getChargedAmount());
        }
        
        // 计算月租费
        BigDecimal monthlyFee = account.getMonthlyFee();
        totalCharges = totalCharges.add(monthlyFee);
        
        // 计算调整费用（优惠、退费等）
        BigDecimal adjustments = calculateAdjustments(account);
        
        // 计算税费
        BigDecimal taxes = calculateTaxes(totalCharges.add(adjustments));
        
        // 计算总金额
        BigDecimal totalAmount = totalCharges.add(adjustments).add(taxes);
        
        return builder
            .monthlyFee(monthlyFee)
            .voiceCharges(voiceCharges)
            .dataCharges(dataCharges)
            .smsCharges(smsCharges)
            .roamingCharges(roamingCharges)
            .valueAddedServices(valueAddedServices)
            .totalCharges(totalCharges)
            .adjustments(adjustments)
            .taxes(taxes)
            .totalAmount(totalAmount)
            .build();
    }
    
    /**
     * 更新CDR对应的账单
     */
    public void updateBill(BaseCdr cdr, RatingResult ratingResult) {
        log.debug("Updating bill for CDR: {}", cdr.getCdrId());
        
        try {
            String msisdn = extractMsisdn(cdr);
            Account account = accountService.getAccountByMsisdn(msisdn);
            
            if (account == null) {
                log.warn("Account not found for MSISDN: {}", maskMsisdn(msisdn));
                return;
            }
            
            // 获取当前账单周期
            YearMonth currentPeriod = YearMonth.now();
            
            // 获取或创建当前账单
            Bill currentBill = getOrCreateCurrentBill(account, currentPeriod);
            
            // 创建使用记录
            UsageRecord usageRecord = UsageRecord.builder()
                .recordId(generateUsageRecordId())
                .accountId(account.getAccountId())
                .billId(currentBill.getBillId())
                .cdrId(cdr.getCdrId())
                .serviceType(cdr.getServiceType())
                .usageTime(cdr.getRecordOpeningTime())
                .chargedAmount(ratingResult.getTotalCharge())
                .currency(account.getCurrency())
                .build();
            
            // 保存使用记录
            saveUsageRecord(usageRecord);
            
            // 更新账单金额
            updateBillAmount(currentBill, ratingResult.getTotalCharge());
            
            log.debug("Bill updated successfully for CDR: {}", cdr.getCdrId());
            
        } catch (Exception e) {
            log.error("Failed to update bill for CDR: {}", cdr.getCdrId(), e);
        }
    }
    
    // 辅助方法
    private List<UsageRecord> getUsageRecords(Long accountId, YearMonth billingPeriod) {
        LocalDateTime startTime = billingPeriod.atDay(1).atStartOfDay();
        LocalDateTime endTime = billingPeriod.atEndOfMonth().atTime(23, 59, 59);
        
        return usageRecordRepository.findByAccountIdAndUsageTimeBetween(
            accountId, startTime, endTime);
    }
    
    private BigDecimal calculateAdjustments(Account account) {
        // 计算调整费用（优惠、退费等）
        return BigDecimal.ZERO;
    }
    
    private BigDecimal calculateTaxes(BigDecimal chargeableAmount) {
        // 计算税费
        BigDecimal taxRate = new BigDecimal("0.10");
        return chargeableAmount.multiply(taxRate).setScale(2, RoundingMode.HALF_UP);
    }
    
    private void updateAccountBalance(Account account, Bill bill) {
        if (account.getChargingMode() == ChargingMode.POSTPAID) {
            // 后付费账户增加债务
            accountService.addDebt(account.getAccountId(), bill.getTotalAmount());
        }
    }
    
    private void sendBillNotification(Account account, Bill bill) {
        // 发送账单通知
        notificationService.sendBillNotification(account, bill);
    }
    
    private String generateBillId() {
        return "BILL_" + System.currentTimeMillis();
    }
    
    private String generateUsageRecordId() {
        return "USAGE_" + System.currentTimeMillis();
    }
    
    private String extractMsisdn(BaseCdr cdr) {
        // 从CDR中提取MSISDN
        switch (cdr.getRecordType()) {
            case VOICE:
                return ((VoiceCdr) cdr).getCallingParty();
            case DATA:
                return ((DataCdr) cdr).getMsisdn();
            case SMS:
                return ((SmsCdr) cdr).getOriginatingNumber();
            default:
                return null;
        }
    }
    
    private Bill getOrCreateCurrentBill(Account account, YearMonth billingPeriod) {
        return billRepository.findByAccountIdAndBillingPeriod(
            account.getAccountId(), billingPeriod)
            .orElseGet(() -> createNewBill(account, billingPeriod));
    }
    
    private Bill createNewBill(Account account, YearMonth billingPeriod) {
        Bill bill = Bill.builder()
            .billId(generateBillId())
            .accountId(account.getAccountId())
            .msisdn(account.getMsisdn())
            .billingPeriod(billingPeriod)
            .billDate(LocalDate.now())
            .totalAmount(BigDecimal.ZERO)
            .currency(account.getCurrency())
            .billStatus(BillStatus.DRAFT)
            .build();
        
        return billRepository.save(bill);
    }
    
    private void updateBillAmount(Bill bill, BigDecimal additionalAmount) {
        bill.setTotalAmount(bill.getTotalAmount().add(additionalAmount));
        billRepository.save(bill);
    }
    
    private void saveUsageRecord(UsageRecord usageRecord) {
        // 保存使用记录
        log.debug("Saving usage record: {}", usageRecord.getRecordId());
    }
    
    private <T> List<List<T>> partitionList(List<T> list, int partitionSize) {
        List<List<T>> partitions = new ArrayList<>();
        for (int i = 0; i < list.size(); i += partitionSize) {
            partitions.add(list.subList(i, Math.min(i + partitionSize, list.size())));
        }
        return partitions;
    }
    
    private String maskMsisdn(String msisdn) {
        if (msisdn == null || msisdn.length() < 7) {
            return msisdn;
        }
        return msisdn.substring(0, 3) + "****" + msisdn.substring(7);
    }
}
```

## 最佳实践总结

### 1. 计费准确性
- **精确计算**: 使用BigDecimal进行货币计算，避免浮点数精度问题
- **费率管理**: 建立完善的费率管理体系，支持复杂的计费规则
- **时区处理**: 正确处理不同时区的计费时间
- **舍入规则**: 统一的金额舍入规则

### 2. 性能优化
- **批量处理**: 采用批量处理提高CDR处理效率
- **异步处理**: 使用异步处理避免阻塞主业务流程
- **缓存策略**: 缓存费率和用户配置信息
- **数据分区**: 按时间分区存储CDR和账单数据

### 3. 数据一致性
- **事务管理**: 确保计费操作的事务一致性
- **幂等性**: 确保重复处理不会产生重复计费
- **数据校验**: 多层次的数据校验机制
- **对账机制**: 定期对账确保数据准确性

### 4. 监控告警
- **实时监控**: 监控计费系统的处理性能和准确性
- **异常检测**: 自动检测异常计费模式
- **欺诈检测**: 集成欺诈检测机制
- **业务监控**: 监控计费收入和用户使用模式

### 5. 合规要求
- **审计追踪**: 完整的计费操作审计日志
- **数据保留**: 符合监管要求的数据保留策略
- **隐私保护**: 保护用户隐私信息
- **监管报告**: 支持各种监管报告需求

通过实施以上电信计费规范和最佳实践，NSRS号卡资源管理系统能够提供准确、高效、合规的计费服务，满足电信运营商的业务需求和监管要求。