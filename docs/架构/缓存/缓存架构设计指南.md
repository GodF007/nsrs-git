# 缓存架构设计指南

## 概述

缓存架构是提升NSRS号卡资源管理系统性能的关键技术。本文档详细阐述了基于Redis集群和本地缓存（Caffeine）的多级缓存策略，包括缓存设计原则、技术选型、配置方案、使用示例和最佳实践。

### 缓存架构目标

- **性能提升**: 减少数据库访问，提升响应速度
- **高可用性**: 缓存集群支持故障转移
- **数据一致性**: 保证缓存与数据库数据的一致性
- **内存优化**: 合理的缓存策略和过期机制
- **监控可观测**: 完善的缓存监控和统计

### 多级缓存架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        Client Request                           │
└─────────────────────┬───────────────────────────────────────────┘
                      │
┌─────────────────────┴───────────────────────────────────────────┐
│                    L1 Cache (Caffeine)                         │
│                   ┌─────────────────┐                          │
│                   │  Local Memory   │                          │
│                   │   - Hot Data    │                          │
│                   │   - Fast Access │                          │
│                   └─────────────────┘                          │
└─────────────────────┬───────────────────────────────────────────┘
                      │ Cache Miss
┌─────────────────────┴───────────────────────────────────────────┐
│                    L2 Cache (Redis)                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │Redis Master │  │Redis Slave1 │  │Redis Slave2 │            │
│  │   (Write)   │  │   (Read)    │  │   (Read)    │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
│         │                 │                 │                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │  Sentinel1  │  │  Sentinel2  │  │  Sentinel3  │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────┬───────────────────────────────────────────┘
                      │ Cache Miss
┌─────────────────────┴───────────────────────────────────────────┐
│                    L3 Database                                 │
│  ┌─────────────┐                    ┌─────────────┐            │
│  │MySQL Master │◄──Replication────►│MySQL Slave  │            │
│  │  (Write)    │                    │   (Read)    │            │
│  └─────────────┘                    └─────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

## Redis集群架构

### 1. Redis主从复制配置

```yaml
# redis-master.conf
port 6379
bind 0.0.0.0
requireauth nsrs_redis_2024
masterauth nsrs_redis_2024

# 持久化配置
save 900 1
save 300 10
save 60 10000
appendonly yes
appendfsync everysec
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 内存配置
maxmemory 4gb
maxmemory-policy allkeys-lru

# 网络配置
tcp-keepalive 300
timeout 0
tcp-backlog 511

# 日志配置
loglevel notice
logfile /var/log/redis/redis-master.log

# 慢查询配置
slowlog-log-slower-than 10000
slowlog-max-len 128
```

```yaml
# redis-slave.conf
port 6379
bind 0.0.0.0
requireauth nsrs_redis_2024
masterauth nsrs_redis_2024

# 主从配置
slaveof 10.1.7.10 6379
slave-read-only yes
slave-serve-stale-data yes
slave-priority 100

# 持久化配置
appendonly yes
appendfsync everysec

# 内存配置
maxmemory 4gb
maxmemory-policy allkeys-lru

# 日志配置
loglevel notice
logfile /var/log/redis/redis-slave.log
```

### 2. Redis Sentinel配置

```yaml
# sentinel.conf
port 26379
bind 0.0.0.0

# 监控主节点
sentinel monitor nsrs-master 10.1.7.10 6379 2
sentinel auth-pass nsrs-master nsrs_redis_2024

# 故障检测配置
sentinel down-after-milliseconds nsrs-master 5000
sentinel parallel-syncs nsrs-master 1
sentinel failover-timeout nsrs-master 10000

# 通知脚本
sentinel notification-script nsrs-master /opt/redis/notify.sh
sentinel client-reconfig-script nsrs-master /opt/redis/reconfig.sh

# 日志配置
logfile /var/log/redis/sentinel.log

# 安全配置
sentinel deny-scripts-reconfig yes
```

### 3. Redis Cluster配置

```yaml
# redis-cluster.conf
port 7000
bind 0.0.0.0
requireauth nsrs_redis_2024
masterauth nsrs_redis_2024

# 集群配置
cluster-enabled yes
cluster-config-file nodes-7000.conf
cluster-node-timeout 5000
cluster-announce-ip 10.1.7.10
cluster-announce-port 7000
cluster-announce-bus-port 17000

# 持久化配置
appendonly yes
appendfsync everysec

# 内存配置
maxmemory 2gb
maxmemory-policy allkeys-lru

# 日志配置
loglevel notice
logfile /var/log/redis/redis-cluster-7000.log
```

```bash
#!/bin/bash
# 创建Redis集群
redis-cli --cluster create \
  10.1.7.10:7000 10.1.7.11:7000 10.1.7.12:7000 \
  10.1.7.13:7000 10.1.7.14:7000 10.1.7.15:7000 \
  --cluster-replicas 1 \
  -a nsrs_redis_2024
```

## Spring Boot Redis配置

### 1. 基础配置

```yaml
# application.yml
spring:
  redis:
    # 单机模式
    host: 10.1.7.10
    port: 6379
    password: nsrs_redis_2024
    database: 0
    timeout: 5000ms
    
    # 连接池配置
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5
        max-wait: 5000ms
      shutdown-timeout: 100ms
    
    # 哨兵模式配置
    sentinel:
      master: nsrs-master
      nodes:
        - 10.1.7.20:26379
        - 10.1.7.21:26379
        - 10.1.7.22:26379
      password: nsrs_redis_2024
    
    # 集群模式配置
    cluster:
      nodes:
        - 10.1.7.10:7000
        - 10.1.7.11:7000
        - 10.1.7.12:7000
        - 10.1.7.13:7000
        - 10.1.7.14:7000
        - 10.1.7.15:7000
      password: nsrs_redis_2024
      max-redirects: 3

# 缓存配置
cache:
  redis:
    default-ttl: 3600  # 默认过期时间（秒）
    key-prefix: "nsrs:"  # 键前缀
    enable-statistics: true  # 启用统计
  
  caffeine:
    maximum-size: 10000  # 最大缓存条目数
    expire-after-write: 300  # 写入后过期时间（秒）
    expire-after-access: 600  # 访问后过期时间（秒）
    initial-capacity: 100  # 初始容量
```

### 2. Redis配置类

```java
@Configuration
@EnableCaching
public class RedisConfig {
    
    @Value("${cache.redis.key-prefix}")
    private String keyPrefix;
    
    @Value("${cache.redis.default-ttl}")
    private long defaultTtl;
    
    /**
     * Redis连接工厂配置
     */
    @Bean
    @Primary
    public LettuceConnectionFactory redisConnectionFactory() {
        // 哨兵模式配置
        RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
            .master("nsrs-master")
            .sentinel("10.1.7.20", 26379)
            .sentinel("10.1.7.21", 26379)
            .sentinel("10.1.7.22", 26379);
        
        sentinelConfig.setPassword("nsrs_redis_2024");
        sentinelConfig.setDatabase(0);
        
        // 连接池配置
        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
        poolConfig.setMaxTotal(20);
        poolConfig.setMaxIdle(10);
        poolConfig.setMinIdle(5);
        poolConfig.setMaxWaitMillis(5000);
        poolConfig.setTestOnBorrow(true);
        poolConfig.setTestOnReturn(true);
        poolConfig.setTestWhileIdle(true);
        poolConfig.setTimeBetweenEvictionRunsMillis(30000);
        
        LettucePoolingClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(poolConfig)
            .commandTimeout(Duration.ofSeconds(5))
            .shutdownTimeout(Duration.ofSeconds(10))
            .build();
        
        return new LettuceConnectionFactory(sentinelConfig, clientConfig);
    }
    
    /**
     * Redis模板配置
     */
    @Bean
    @Primary
    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        // 序列化配置
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        serializer.setObjectMapper(objectMapper);
        
        // 键值序列化
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);
        template.setHashValueSerializer(serializer);
        
        template.afterPropertiesSet();
        return template;
    }
    
    /**
     * 字符串Redis模板
     */
    @Bean
    public StringRedisTemplate stringRedisTemplate(LettuceConnectionFactory connectionFactory) {
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(connectionFactory);
        return template;
    }
    
    /**
     * 缓存管理器配置
     */
    @Bean
    @Primary
    public CacheManager redisCacheManager(LettuceConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofSeconds(defaultTtl))
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()))
            .computePrefixWith(cacheName -> keyPrefix + cacheName + ":")
            .disableCachingNullValues();
        
        // 不同缓存的配置
        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
        
        // IMSI资源缓存 - 1小时过期
        cacheConfigurations.put("imsiResource", config.entryTtl(Duration.ofHours(1)));
        
        // 用户信息缓存 - 30分钟过期
        cacheConfigurations.put("userInfo", config.entryTtl(Duration.ofMinutes(30)));
        
        // 供应商信息缓存 - 2小时过期
        cacheConfigurations.put("supplierInfo", config.entryTtl(Duration.ofHours(2)));
        
        // 字典数据缓存 - 24小时过期
        cacheConfigurations.put("dictData", config.entryTtl(Duration.ofHours(24)));
        
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .withInitialCacheConfigurations(cacheConfigurations)
            .transactionAware()
            .build();
    }
}
```

## Caffeine本地缓存配置

### 1. Caffeine配置类

```java
@Configuration
public class CaffeineConfig {
    
    @Value("${cache.caffeine.maximum-size}")
    private long maximumSize;
    
    @Value("${cache.caffeine.expire-after-write}")
    private long expireAfterWrite;
    
    @Value("${cache.caffeine.expire-after-access}")
    private long expireAfterAccess;
    
    @Value("${cache.caffeine.initial-capacity}")
    private int initialCapacity;
    
    /**
     * Caffeine缓存管理器
     */
    @Bean("caffeineCacheManager")
    public CacheManager caffeineCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        
        // 默认缓存配置
        Caffeine<Object, Object> caffeine = Caffeine.newBuilder()
            .initialCapacity(initialCapacity)
            .maximumSize(maximumSize)
            .expireAfterWrite(Duration.ofSeconds(expireAfterWrite))
            .expireAfterAccess(Duration.ofSeconds(expireAfterAccess))
            .recordStats()  // 启用统计
            .removalListener((key, value, cause) -> {
                log.debug("Cache entry removed: key={}, cause={}", key, cause);
            });
        
        cacheManager.setCaffeine(caffeine);
        
        // 预定义缓存
        cacheManager.setCacheNames(Arrays.asList(
            "hotImsiResource",  // 热点IMSI资源
            "userSession",     // 用户会话
            "frequentQuery",   // 频繁查询结果
            "configData"       // 配置数据
        ));
        
        return cacheManager;
    }
    
    /**
     * 自定义Caffeine缓存
     */
    @Bean("customCaffeineCache")
    public Cache<String, Object> customCaffeineCache() {
        return Caffeine.newBuilder()
            .initialCapacity(100)
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(10))
            .expireAfterAccess(Duration.ofMinutes(5))
            .recordStats()
            .build();
    }
    
    /**
     * IMSI资源专用缓存
     */
    @Bean("imsiResourceCache")
    public Cache<String, ImsiResource> imsiResourceCache() {
        return Caffeine.newBuilder()
            .initialCapacity(500)
            .maximumSize(5000)
            .expireAfterWrite(Duration.ofMinutes(30))
            .expireAfterAccess(Duration.ofMinutes(15))
            .recordStats()
            .removalListener((String key, ImsiResource value, RemovalCause cause) -> {
                if (cause == RemovalCause.EXPIRED) {
                    log.debug("IMSI resource cache expired: {}", key);
                }
            })
            .build();
    }
}
```

### 2. 缓存统计监控

```java
@Component
public class CacheStatsMonitor {
    
    @Autowired
    @Qualifier("customCaffeineCache")
    private Cache<String, Object> customCache;
    
    @Autowired
    @Qualifier("imsiResourceCache")
    private Cache<String, ImsiResource> imsiResourceCache;
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @PostConstruct
    public void initMetrics() {
        // 注册Caffeine缓存指标
        CacheMetrics.monitor(meterRegistry, customCache, "custom_cache");
        CacheMetrics.monitor(meterRegistry, imsiResourceCache, "imsi_resource_cache");
    }
    
    /**
     * 定期输出缓存统计信息
     */
    @Scheduled(fixedRate = 60000)  // 每分钟执行一次
    public void logCacheStats() {
        // 自定义缓存统计
        CacheStats customStats = customCache.stats();
        log.info("Custom Cache Stats - Hit Rate: {:.2f}%, Miss Count: {}, Eviction Count: {}",
            customStats.hitRate() * 100, customStats.missCount(), customStats.evictionCount());
        
        // IMSI资源缓存统计
        CacheStats imsiStats = imsiResourceCache.stats();
        log.info("IMSI Resource Cache Stats - Hit Rate: {:.2f}%, Miss Count: {}, Eviction Count: {}",
            imsiStats.hitRate() * 100, imsiStats.missCount(), imsiStats.evictionCount());
    }
    
    /**
     * 获取缓存统计信息
     */
    public Map<String, Object> getCacheStatistics() {
        Map<String, Object> stats = new HashMap<>();
        
        // 自定义缓存统计
        CacheStats customStats = customCache.stats();
        Map<String, Object> customCacheStats = new HashMap<>();
        customCacheStats.put("hitRate", customStats.hitRate());
        customCacheStats.put("hitCount", customStats.hitCount());
        customCacheStats.put("missCount", customStats.missCount());
        customCacheStats.put("loadCount", customStats.loadCount());
        customCacheStats.put("evictionCount", customStats.evictionCount());
        customCacheStats.put("estimatedSize", customCache.estimatedSize());
        stats.put("customCache", customCacheStats);
        
        // IMSI资源缓存统计
        CacheStats imsiStats = imsiResourceCache.stats();
        Map<String, Object> imsiCacheStats = new HashMap<>();
        imsiCacheStats.put("hitRate", imsiStats.hitRate());
        imsiCacheStats.put("hitCount", imsiStats.hitCount());
        imsiCacheStats.put("missCount", imsiStats.missCount());
        imsiCacheStats.put("loadCount", imsiStats.loadCount());
        imsiCacheStats.put("evictionCount", imsiStats.evictionCount());
        imsiCacheStats.put("estimatedSize", imsiResourceCache.estimatedSize());
        stats.put("imsiResourceCache", imsiCacheStats);
        
        return stats;
    }
}
```

## 多级缓存服务

### 1. 多级缓存管理器

```java
@Service
public class MultiLevelCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    @Qualifier("imsiResourceCache")
    private Cache<String, ImsiResource> localCache;
    
    @Autowired
    private ImsiResourceMapper imsiResourceMapper;
    
    private static final String CACHE_PREFIX = "nsrs:imsi:";
    private static final Duration REDIS_TTL = Duration.ofHours(1);
    private static final Duration LOCAL_TTL = Duration.ofMinutes(15);
    
    /**
     * 多级缓存获取IMSI资源
     */
    public ImsiResource getImsiResource(String imsi) {
        // L1缓存：本地缓存
        ImsiResource resource = localCache.getIfPresent(imsi);
        if (resource != null) {
            log.debug("Hit L1 cache for IMSI: {}", imsi);
            return resource;
        }
        
        // L2缓存：Redis缓存
        String redisKey = CACHE_PREFIX + imsi;
        resource = (ImsiResource) redisTemplate.opsForValue().get(redisKey);
        if (resource != null) {
            log.debug("Hit L2 cache for IMSI: {}", imsi);
            // 回填L1缓存
            localCache.put(imsi, resource);
            return resource;
        }
        
        // L3：数据库查询
        resource = imsiResourceMapper.selectByImsi(imsi);
        if (resource != null) {
            log.debug("Hit L3 database for IMSI: {}", imsi);
            // 回填缓存
            redisTemplate.opsForValue().set(redisKey, resource, REDIS_TTL);
            localCache.put(imsi, resource);
        }
        
        return resource;
    }
    
    /**
     * 批量获取IMSI资源
     */
    public Map<String, ImsiResource> getImsiResourceBatch(List<String> imsiList) {
        Map<String, ImsiResource> result = new HashMap<>();
        List<String> missedKeys = new ArrayList<>();
        
        // L1缓存批量查询
        for (String imsi : imsiList) {
            ImsiResource resource = localCache.getIfPresent(imsi);
            if (resource != null) {
                result.put(imsi, resource);
            } else {
                missedKeys.add(imsi);
            }
        }
        
        if (missedKeys.isEmpty()) {
            return result;
        }
        
        // L2缓存批量查询
        List<String> redisKeys = missedKeys.stream()
            .map(imsi -> CACHE_PREFIX + imsi)
            .collect(Collectors.toList());
        
        List<Object> redisValues = redisTemplate.opsForValue().multiGet(redisKeys);
        List<String> dbMissedKeys = new ArrayList<>();
        
        for (int i = 0; i < missedKeys.size(); i++) {
            String imsi = missedKeys.get(i);
            Object value = redisValues.get(i);
            
            if (value != null) {
                ImsiResource resource = (ImsiResource) value;
                result.put(imsi, resource);
                // 回填L1缓存
                localCache.put(imsi, resource);
            } else {
                dbMissedKeys.add(imsi);
            }
        }
        
        if (dbMissedKeys.isEmpty()) {
            return result;
        }
        
        // L3数据库批量查询
        List<ImsiResource> dbResources = imsiResourceMapper.selectByImsiList(dbMissedKeys);
        
        for (ImsiResource resource : dbResources) {
            String imsi = resource.getImsi();
            result.put(imsi, resource);
            
            // 回填缓存
            String redisKey = CACHE_PREFIX + imsi;
            redisTemplate.opsForValue().set(redisKey, resource, REDIS_TTL);
            localCache.put(imsi, resource);
        }
        
        return result;
    }
    
    /**
     * 更新缓存
     */
    public void updateImsiResource(ImsiResource resource) {
        String imsi = resource.getImsi();
        String redisKey = CACHE_PREFIX + imsi;
        
        // 更新数据库
        imsiResourceMapper.updateByImsi(resource);
        
        // 更新缓存
        redisTemplate.opsForValue().set(redisKey, resource, REDIS_TTL);
        localCache.put(imsi, resource);
        
        log.debug("Updated cache for IMSI: {}", imsi);
    }
    
    /**
     * 删除缓存
     */
    public void evictImsiResource(String imsi) {
        String redisKey = CACHE_PREFIX + imsi;
        
        // 删除Redis缓存
        redisTemplate.delete(redisKey);
        
        // 删除本地缓存
        localCache.invalidate(imsi);
        
        log.debug("Evicted cache for IMSI: {}", imsi);
    }
    
    /**
     * 批量删除缓存
     */
    public void evictImsiResourceBatch(List<String> imsiList) {
        // 删除Redis缓存
        List<String> redisKeys = imsiList.stream()
            .map(imsi -> CACHE_PREFIX + imsi)
            .collect(Collectors.toList());
        redisTemplate.delete(redisKeys);
        
        // 删除本地缓存
        localCache.invalidateAll(imsiList);
        
        log.debug("Evicted cache for {} IMSI resources", imsiList.size());
    }
    
    /**
     * 缓存预热
     */
    @EventListener(ApplicationReadyEvent.class)
    public void warmupCache() {
        log.info("Starting cache warmup");
        
        try {
            // 预加载热点IMSI资源
            List<ImsiResource> hotResources = imsiResourceMapper.selectHotResources(1000);
            
            for (ImsiResource resource : hotResources) {
                String imsi = resource.getImsi();
                String redisKey = CACHE_PREFIX + imsi;
                
                // 预热Redis缓存
                redisTemplate.opsForValue().set(redisKey, resource, REDIS_TTL);
                
                // 预热本地缓存（只预热最热门的数据）
                if (hotResources.indexOf(resource) < 100) {
                    localCache.put(imsi, resource);
                }
            }
            
            log.info("Cache warmup completed, loaded {} resources", hotResources.size());
            
        } catch (Exception e) {
            log.error("Cache warmup failed", e);
        }
    }
}
```

### 2. 缓存注解使用

```java
@Service
public class ImsiResourceService {
    
    @Autowired
    private ImsiResourceMapper imsiResourceMapper;
    
    /**
     * 查询IMSI资源（使用Spring Cache注解）
     */
    @Cacheable(value = "imsiResource", key = "#imsi", unless = "#result == null")
    public ImsiResource getImsiResource(String imsi) {
        log.debug("Querying database for IMSI: {}", imsi);
        return imsiResourceMapper.selectByImsi(imsi);
    }
    
    /**
     * 更新IMSI资源
     */
    @CachePut(value = "imsiResource", key = "#resource.imsi")
    public ImsiResource updateImsiResource(ImsiResource resource) {
        imsiResourceMapper.updateByImsi(resource);
        return resource;
    }
    
    /**
     * 删除IMSI资源
     */
    @CacheEvict(value = "imsiResource", key = "#imsi")
    public void deleteImsiResource(String imsi) {
        imsiResourceMapper.deleteByImsi(imsi);
    }
    
    /**
     * 批量删除IMSI资源
     */
    @CacheEvict(value = "imsiResource", allEntries = true)
    public void deleteImsiResourceBatch(List<String> imsiList) {
        imsiResourceMapper.deleteByImsiList(imsiList);
    }
    
    /**
     * 条件缓存
     */
    @Cacheable(value = "imsiResource", key = "#imsi", condition = "#imsi.length() == 15")
    public ImsiResource getValidImsiResource(String imsi) {
        return imsiResourceMapper.selectByImsi(imsi);
    }
    
    /**
     * 自定义缓存键
     */
    @Cacheable(value = "supplierImsi", key = "#supplierId + ':' + #status")
    public List<ImsiResource> getImsiResourceBySupplier(Long supplierId, String status) {
        return imsiResourceMapper.selectBySupplierAndStatus(supplierId, status);
    }
}
```

## 缓存一致性策略

### 1. 缓存更新策略

```java
@Component
public class CacheConsistencyManager {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private MultiLevelCacheService multiLevelCacheService;
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    /**
     * Cache-Aside模式
     */
    public ImsiResource getImsiResourceCacheAside(String imsi) {
        // 先查缓存
        ImsiResource resource = multiLevelCacheService.getImsiResource(imsi);
        
        if (resource == null) {
            // 缓存未命中，查询数据库
            resource = imsiResourceMapper.selectByImsi(imsi);
            
            if (resource != null) {
                // 写入缓存
                multiLevelCacheService.updateImsiResource(resource);
            }
        }
        
        return resource;
    }
    
    /**
     * Write-Through模式
     */
    @Transactional
    public void updateImsiResourceWriteThrough(ImsiResource resource) {
        // 同时更新数据库和缓存
        imsiResourceMapper.updateByImsi(resource);
        multiLevelCacheService.updateImsiResource(resource);
        
        // 发布缓存更新事件
        eventPublisher.publishEvent(new CacheUpdateEvent("imsiResource", resource.getImsi(), resource));
    }
    
    /**
     * Write-Behind模式（异步写入）
     */
    public void updateImsiResourceWriteBehind(ImsiResource resource) {
        // 立即更新缓存
        multiLevelCacheService.updateImsiResource(resource);
        
        // 异步更新数据库
        CompletableFuture.runAsync(() -> {
            try {
                imsiResourceMapper.updateByImsi(resource);
                log.debug("Async database update completed for IMSI: {}", resource.getImsi());
            } catch (Exception e) {
                log.error("Async database update failed for IMSI: {}", resource.getImsi(), e);
                // 回滚缓存或重试
                handleAsyncUpdateFailure(resource);
            }
        });
    }
    
    /**
     * 处理异步更新失败
     */
    private void handleAsyncUpdateFailure(ImsiResource resource) {
        // 可以选择回滚缓存或者重试
        try {
            // 重试数据库更新
            imsiResourceMapper.updateByImsi(resource);
            log.info("Retry database update succeeded for IMSI: {}", resource.getImsi());
        } catch (Exception e) {
            // 重试失败，回滚缓存
            multiLevelCacheService.evictImsiResource(resource.getImsi());
            log.error("Database update retry failed, cache evicted for IMSI: {}", resource.getImsi(), e);
        }
    }
    
    /**
     * 分布式缓存失效
     */
    public void invalidateDistributedCache(String pattern) {
        // 发布缓存失效消息
        redisTemplate.convertAndSend("cache:invalidate", pattern);
    }
    
    /**
     * 监听缓存失效消息
     */
    @EventListener
    public void handleCacheInvalidateMessage(String pattern) {
        if (pattern.startsWith("imsi:")) {
            String imsi = pattern.substring(5);
            multiLevelCacheService.evictImsiResource(imsi);
            log.debug("Cache invalidated for IMSI: {}", imsi);
        }
    }
}
```

### 2. 缓存事件处理

```java
/**
 * 缓存更新事件
 */
public class CacheUpdateEvent extends ApplicationEvent {
    private final String cacheName;
    private final String key;
    private final Object value;
    
    public CacheUpdateEvent(Object source, String cacheName, String key, Object value) {
        super(source);
        this.cacheName = cacheName;
        this.key = key;
        this.value = value;
    }
    
    // getters...
}

/**
 * 缓存事件监听器
 */
@Component
public class CacheEventListener {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 处理缓存更新事件
     */
    @EventListener
    @Async
    public void handleCacheUpdateEvent(CacheUpdateEvent event) {
        try {
            // 通知其他节点更新缓存
            Map<String, Object> message = new HashMap<>();
            message.put("action", "update");
            message.put("cacheName", event.getCacheName());
            message.put("key", event.getKey());
            message.put("value", event.getValue());
            message.put("timestamp", System.currentTimeMillis());
            
            redisTemplate.convertAndSend("cache:sync", message);
            
            log.debug("Cache sync message sent for {}: {}", event.getCacheName(), event.getKey());
            
        } catch (Exception e) {
            log.error("Failed to send cache sync message", e);
        }
    }
    
    /**
     * 监听缓存同步消息
     */
    @RedisMessageListener("cache:sync")
    public void handleCacheSyncMessage(Map<String, Object> message) {
        try {
            String action = (String) message.get("action");
            String cacheName = (String) message.get("cacheName");
            String key = (String) message.get("key");
            
            if ("update".equals(action)) {
                Object value = message.get("value");
                // 更新本地缓存
                updateLocalCache(cacheName, key, value);
            } else if ("evict".equals(action)) {
                // 清除本地缓存
                evictLocalCache(cacheName, key);
            }
            
            log.debug("Processed cache sync message: {} for {}: {}", action, cacheName, key);
            
        } catch (Exception e) {
            log.error("Failed to process cache sync message", e);
        }
    }
    
    private void updateLocalCache(String cacheName, String key, Object value) {
        // 根据缓存名称更新对应的本地缓存
        if ("imsiResource".equals(cacheName) && value instanceof ImsiResource) {
            localCache.put(key, (ImsiResource) value);
        }
    }
    
    private void evictLocalCache(String cacheName, String key) {
        // 根据缓存名称清除对应的本地缓存
        if ("imsiResource".equals(cacheName)) {
            localCache.invalidate(key);
        }
    }
}
```

## 缓存监控和运维

### 1. 缓存监控指标

```java
@Component
public class CacheMonitoringService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    private final Timer cacheOperationTimer;
    private final Counter cacheHitCounter;
    private final Counter cacheMissCounter;
    private final Gauge cacheMemoryUsage;
    
    public CacheMonitoringService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // 缓存操作耗时
        this.cacheOperationTimer = Timer.builder("cache.operation.duration")
            .description("Cache operation duration")
            .register(meterRegistry);
        
        // 缓存命中计数
        this.cacheHitCounter = Counter.builder("cache.hit.total")
            .description("Cache hit count")
            .register(meterRegistry);
        
        // 缓存未命中计数
        this.cacheMissCounter = Counter.builder("cache.miss.total")
            .description("Cache miss count")
            .register(meterRegistry);
        
        // 缓存内存使用量
        this.cacheMemoryUsage = Gauge.builder("cache.memory.usage")
            .description("Cache memory usage")
            .register(meterRegistry, this, CacheMonitoringService::getRedisMemoryUsage);
    }
    
    /**
     * 记录缓存命中
     */
    public void recordCacheHit(String cacheName) {
        cacheHitCounter.increment(Tags.of("cache", cacheName));
    }
    
    /**
     * 记录缓存未命中
     */
    public void recordCacheMiss(String cacheName) {
        cacheMissCounter.increment(Tags.of("cache", cacheName));
    }
    
    /**
     * 记录缓存操作耗时
     */
    public Timer.Sample startCacheOperation(String operation) {
        return Timer.start(meterRegistry).tags("operation", operation);
    }
    
    /**
     * 获取Redis内存使用量
     */
    private double getRedisMemoryUsage() {
        try {
            Properties info = redisTemplate.getConnectionFactory().getConnection().info("memory");
            String usedMemory = info.getProperty("used_memory");
            return usedMemory != null ? Double.parseDouble(usedMemory) : 0.0;
        } catch (Exception e) {
            log.warn("Failed to get Redis memory usage", e);
            return 0.0;
        }
    }
    
    /**
     * 获取缓存统计信息
     */
    @Scheduled(fixedRate = 60000)
    public void collectCacheStatistics() {
        try {
            // Redis统计信息
            Properties info = redisTemplate.getConnectionFactory().getConnection().info();
            
            // 连接数
            String connectedClients = info.getProperty("connected_clients");
            if (connectedClients != null) {
                Gauge.builder("redis.connected.clients")
                    .register(meterRegistry)
                    .set(Double.parseDouble(connectedClients));
            }
            
            // 命令执行次数
            String totalCommandsProcessed = info.getProperty("total_commands_processed");
            if (totalCommandsProcessed != null) {
                Counter.builder("redis.commands.processed.total")
                    .register(meterRegistry)
                    .increment(Double.parseDouble(totalCommandsProcessed));
            }
            
            // 键空间命中率
            String keyspaceHits = info.getProperty("keyspace_hits");
            String keyspaceMisses = info.getProperty("keyspace_misses");
            if (keyspaceHits != null && keyspaceMisses != null) {
                double hits = Double.parseDouble(keyspaceHits);
                double misses = Double.parseDouble(keyspaceMisses);
                double hitRate = hits / (hits + misses);
                
                Gauge.builder("redis.keyspace.hit.rate")
                    .register(meterRegistry)
                    .set(hitRate);
            }
            
        } catch (Exception e) {
            log.error("Failed to collect cache statistics", e);
        }
    }
}
```

### 2. 缓存运维工具

```java
@RestController
@RequestMapping("/admin/cache")
public class CacheAdminController {
    
    @Autowired
    private MultiLevelCacheService multiLevelCacheService;
    
    @Autowired
    private CacheStatsMonitor cacheStatsMonitor;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 获取缓存统计信息
     */
    @GetMapping("/stats")
    public ResponseEntity<Map<String, Object>> getCacheStats() {
        Map<String, Object> stats = cacheStatsMonitor.getCacheStatistics();
        return ResponseEntity.ok(stats);
    }
    
    /**
     * 清空指定缓存
     */
    @DeleteMapping("/clear/{cacheName}")
    public ResponseEntity<String> clearCache(@PathVariable String cacheName) {
        try {
            if ("imsiResource".equals(cacheName)) {
                // 清空IMSI资源缓存
                Set<String> keys = redisTemplate.keys("nsrs:imsi:*");
                if (keys != null && !keys.isEmpty()) {
                    redisTemplate.delete(keys);
                }
                localCache.invalidateAll();
                return ResponseEntity.ok("Cache cleared: " + cacheName);
            } else {
                return ResponseEntity.badRequest().body("Unknown cache name: " + cacheName);
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Failed to clear cache: " + e.getMessage());
        }
    }
    
    /**
     * 预热缓存
     */
    @PostMapping("/warmup")
    public ResponseEntity<String> warmupCache() {
        try {
            multiLevelCacheService.warmupCache();
            return ResponseEntity.ok("Cache warmup initiated");
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Failed to warmup cache: " + e.getMessage());
        }
    }
    
    /**
     * 获取缓存键列表
     */
    @GetMapping("/keys")
    public ResponseEntity<Set<String>> getCacheKeys(@RequestParam String pattern) {
        try {
            Set<String> keys = redisTemplate.keys(pattern);
            return ResponseEntity.ok(keys);
        } catch (Exception e) {
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * 获取缓存值
     */
    @GetMapping("/value/{key}")
    public ResponseEntity<Object> getCacheValue(@PathVariable String key) {
        try {
            Object value = redisTemplate.opsForValue().get(key);
            return ResponseEntity.ok(value);
        } catch (Exception e) {
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * 删除缓存键
     */
    @DeleteMapping("/key/{key}")
    public ResponseEntity<String> deleteCacheKey(@PathVariable String key) {
        try {
            Boolean deleted = redisTemplate.delete(key);
            return ResponseEntity.ok("Key deleted: " + deleted);
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Failed to delete key: " + e.getMessage());
        }
    }
}
```

## 最佳实践

### 1. 缓存设计原则

- **缓存粒度**: 根据业务场景选择合适的缓存粒度，避免过大或过小的缓存对象
- **过期策略**: 设置合理的过期时间，避免缓存雪崩和缓存穿透
- **键命名规范**: 使用有意义的键名，包含业务前缀和版本信息
- **数据一致性**: 选择合适的缓存更新策略，平衡性能和一致性
- **容量规划**: 根据业务量和内存容量合理规划缓存大小

### 2. 性能优化建议

- **批量操作**: 使用批量读写操作减少网络开销
- **连接池优化**: 合理配置连接池参数，避免连接泄漏
- **序列化优化**: 选择高效的序列化方式，减少CPU和网络开销
- **监控告警**: 建立完善的监控体系，及时发现和解决问题
- **压力测试**: 定期进行压力测试，验证缓存系统的性能和稳定性

### 3. 故障处理策略

- **降级机制**: 缓存不可用时的降级策略
- **熔断保护**: 防止缓存故障影响整个系统
- **数据恢复**: 缓存数据丢失后的恢复机制
- **故障转移**: 主从切换和集群故障转移
- **备份策略**: 定期备份重要的缓存数据

## 总结

本缓存架构设计指南涵盖了NSRS号卡资源管理系统的完整缓存解决方案：

1. **Redis集群**: 主从复制、哨兵模式、集群模式的配置和使用
2. **本地缓存**: Caffeine缓存的配置、监控和统计
3. **多级缓存**: L1本地缓存 + L2Redis缓存 + L3数据库的多级缓存策略
4. **缓存一致性**: Cache-Aside、Write-Through、Write-Behind等一致性策略
5. **监控运维**: 完善的监控指标、统计信息和运维工具

通过这些技术方案的实施，可以显著提升NSRS系统的性能，减少数据库压力，提高用户体验。