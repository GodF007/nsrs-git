# 安全架构设计详解

## 概述

安全架构是NSRS号卡资源管理系统的重要保障，涵盖身份认证、权限控制、数据安全、网络安全等多个层面。本文档详细阐述了基于零信任架构的安全设计方案。

### 安全架构目标

- **身份安全**: 多因子认证、单点登录
- **访问控制**: 基于角色的权限管理
- **数据安全**: 数据加密、脱敏、审计
- **网络安全**: 防火墙、入侵检测、流量监控
- **应用安全**: 代码安全、API安全、漏洞防护

## 核心枚举定义

### 1. 安全等级枚举

```java
/**
 * 安全等级枚举
 */
public enum SecurityLevel {
    PUBLIC("公开", 0),
    INTERNAL("内部", 1),
    CONFIDENTIAL("机密", 2),
    SECRET("秘密", 3),
    TOP_SECRET("绝密", 4);
    
    private final String description;
    private final int level;
    
    SecurityLevel(String description, int level) {
        this.description = description;
        this.level = level;
    }
    
    // getters...
}
```

### 2. 认证方式枚举

```java
/**
 * 认证方式枚举
 */
public enum AuthenticationType {
    PASSWORD("密码认证"),
    SMS_CODE("短信验证码"),
    EMAIL_CODE("邮箱验证码"),
    TOTP("时间动态口令"),
    BIOMETRIC("生物识别"),
    CERTIFICATE("数字证书"),
    LDAP("LDAP认证"),
    OAUTH2("OAuth2认证"),
    SAML("SAML认证");
    
    private final String description;
    
    AuthenticationType(String description) {
        this.description = description;
    }
    
    // getters...
}
```

### 3. 权限类型枚举

```java
/**
 * 权限类型枚举
 */
public enum PermissionType {
    READ("读取"),
    WRITE("写入"),
    UPDATE("更新"),
    DELETE("删除"),
    EXECUTE("执行"),
    APPROVE("审批"),
    ADMIN("管理");
    
    private final String description;
    
    PermissionType(String description) {
        this.description = description;
    }
    
    // getters...
}
```

## 核心实体设计

### 1. 安全策略配置

```java
/**
 * 安全策略配置实体
 */
@Entity
@Table(name = "security_policy")
public class SecurityPolicy {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "policy_name", nullable = false)
    private String policyName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "security_level")
    private SecurityLevel securityLevel;
    
    @Column(name = "password_policy", columnDefinition = "JSON")
    private String passwordPolicy; // JSON格式存储密码策略
    
    @Column(name = "session_timeout")
    private Integer sessionTimeout; // 会话超时时间(分钟)
    
    @Column(name = "max_login_attempts")
    private Integer maxLoginAttempts; // 最大登录尝试次数
    
    @Column(name = "lockout_duration")
    private Integer lockoutDuration; // 锁定时长(分钟)
    
    @Column(name = "require_mfa")
    private Boolean requireMfa; // 是否要求多因子认证
    
    @Column(name = "ip_whitelist", columnDefinition = "TEXT")
    private String ipWhitelist; // IP白名单
    
    @Column(name = "created_time")
    private LocalDateTime createdTime;
    
    @Column(name = "updated_time")
    private LocalDateTime updatedTime;
    
    // constructors, getters, setters...
}
```

### 2. 用户认证信息

```java
/**
 * 用户认证信息实体
 */
@Entity
@Table(name = "user_authentication")
public class UserAuthentication {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "user_id", nullable = false)
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "auth_type")
    private AuthenticationType authType;
    
    @Column(name = "auth_value")
    private String authValue; // 加密后的认证值
    
    @Column(name = "salt")
    private String salt; // 盐值
    
    @Column(name = "is_primary")
    private Boolean isPrimary; // 是否为主要认证方式
    
    @Column(name = "is_enabled")
    private Boolean isEnabled;
    
    @Column(name = "last_used_time")
    private LocalDateTime lastUsedTime;
    
    @Column(name = "expires_time")
    private LocalDateTime expiresTime;
    
    @Column(name = "created_time")
    private LocalDateTime createdTime;
    
    // constructors, getters, setters...
}
```

### 3. 安全审计日志

```java
/**
 * 安全审计日志实体
 */
@Entity
@Table(name = "security_audit_log")
public class SecurityAuditLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "user_id")
    private Long userId;
    
    @Column(name = "username")
    private String username;
    
    @Column(name = "action")
    private String action; // 操作类型
    
    @Column(name = "resource")
    private String resource; // 操作资源
    
    @Column(name = "ip_address")
    private String ipAddress;
    
    @Column(name = "user_agent")
    private String userAgent;
    
    @Column(name = "request_id")
    private String requestId;
    
    @Column(name = "result")
    private String result; // SUCCESS/FAILURE
    
    @Column(name = "risk_level")
    private String riskLevel; // LOW/MEDIUM/HIGH
    
    @Column(name = "details", columnDefinition = "TEXT")
    private String details; // 详细信息
    
    @Column(name = "created_time")
    private LocalDateTime createdTime;
    
    // constructors, getters, setters...
}
```

## 安全服务实现

### 1. 身份认证服务

```java
/**
 * 身份认证服务
 */
@Service
@Slf4j
public class AuthenticationService {
    
    @Autowired
    private UserAuthenticationRepository authRepository;
    
    @Autowired
    private SecurityPolicyRepository policyRepository;
    
    @Autowired
    private SecurityAuditService auditService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 用户登录认证
     */
    public AuthenticationResult authenticate(AuthenticationRequest request) {
        try {
            // 1. 检查IP白名单
            if (!isIpAllowed(request.getIpAddress())) {
                auditService.logSecurityEvent(request.getUsername(), "LOGIN_BLOCKED", 
                    "IP not in whitelist: " + request.getIpAddress(), "HIGH");
                return AuthenticationResult.failure("IP地址不在白名单中");
            }
            
            // 2. 检查账户锁定状态
            if (isAccountLocked(request.getUsername())) {
                auditService.logSecurityEvent(request.getUsername(), "LOGIN_BLOCKED", 
                    "Account is locked", "MEDIUM");
                return AuthenticationResult.failure("账户已被锁定");
            }
            
            // 3. 验证主要认证方式
            UserAuthentication primaryAuth = authRepository
                .findByUserIdAndAuthTypeAndIsPrimary(request.getUserId(), 
                    AuthenticationType.PASSWORD, true);
            
            if (!verifyPassword(request.getPassword(), primaryAuth)) {
                handleFailedLogin(request.getUsername());
                return AuthenticationResult.failure("用户名或密码错误");
            }
            
            // 4. 检查是否需要多因子认证
            SecurityPolicy policy = getSecurityPolicy(request.getUserId());
            if (policy.getRequireMfa() && !request.hasMfaToken()) {
                return AuthenticationResult.requireMfa(generateMfaChallenge(request.getUserId()));
            }
            
            // 5. 验证多因子认证
            if (request.hasMfaToken() && !verifyMfaToken(request)) {
                return AuthenticationResult.failure("多因子认证失败");
            }
            
            // 6. 生成访问令牌
            String accessToken = generateAccessToken(request.getUserId());
            String refreshToken = generateRefreshToken(request.getUserId());
            
            // 7. 记录成功登录
            auditService.logSecurityEvent(request.getUsername(), "LOGIN_SUCCESS", 
                "Successful login", "LOW");
            
            clearFailedLoginAttempts(request.getUsername());
            
            return AuthenticationResult.success(accessToken, refreshToken);
            
        } catch (Exception e) {
            log.error("Authentication error for user: {}", request.getUsername(), e);
            auditService.logSecurityEvent(request.getUsername(), "LOGIN_ERROR", 
                e.getMessage(), "HIGH");
            return AuthenticationResult.failure("认证服务异常");
        }
    }
    
    /**
     * 验证访问令牌
     */
    public TokenValidationResult validateToken(String token) {
        try {
            // 1. 解析JWT令牌
            Claims claims = Jwts.parser()
                .setSigningKey(getSigningKey())
                .parseClaimsJws(token)
                .getBody();
            
            // 2. 检查令牌是否在黑名单中
            if (isTokenBlacklisted(token)) {
                return TokenValidationResult.invalid("令牌已被撤销");
            }
            
            // 3. 检查用户状态
            Long userId = claims.get("userId", Long.class);
            if (!isUserActive(userId)) {
                return TokenValidationResult.invalid("用户已被禁用");
            }
            
            // 4. 检查权限范围
            List<String> scopes = claims.get("scopes", List.class);
            
            return TokenValidationResult.valid(userId, scopes);
            
        } catch (ExpiredJwtException e) {
            return TokenValidationResult.expired();
        } catch (Exception e) {
            log.error("Token validation error", e);
            return TokenValidationResult.invalid("令牌验证失败");
        }
    }
    
    /**
     * 刷新访问令牌
     */
    public RefreshTokenResult refreshToken(String refreshToken) {
        try {
            // 1. 验证刷新令牌
            Claims claims = Jwts.parser()
                .setSigningKey(getSigningKey())
                .parseClaimsJws(refreshToken)
                .getBody();
            
            Long userId = claims.get("userId", Long.class);
            String tokenType = claims.get("type", String.class);
            
            if (!"refresh".equals(tokenType)) {
                return RefreshTokenResult.failure("无效的刷新令牌");
            }
            
            // 2. 生成新的访问令牌
            String newAccessToken = generateAccessToken(userId);
            String newRefreshToken = generateRefreshToken(userId);
            
            // 3. 将旧的刷新令牌加入黑名单
            blacklistToken(refreshToken);
            
            return RefreshTokenResult.success(newAccessToken, newRefreshToken);
            
        } catch (Exception e) {
            log.error("Refresh token error", e);
            return RefreshTokenResult.failure("令牌刷新失败");
        }
    }
    
    // 辅助方法
    private boolean isIpAllowed(String ipAddress) {
        // 检查IP白名单逻辑
        return true; // 简化实现
    }
    
    private boolean isAccountLocked(String username) {
        String lockKey = "account_lock:" + username;
        return redisTemplate.hasKey(lockKey);
    }
    
    private boolean verifyPassword(String password, UserAuthentication auth) {
        String hashedPassword = hashPassword(password, auth.getSalt());
        return hashedPassword.equals(auth.getAuthValue());
    }
    
    private void handleFailedLogin(String username) {
        String attemptKey = "login_attempts:" + username;
        Integer attempts = (Integer) redisTemplate.opsForValue().get(attemptKey);
        attempts = (attempts == null) ? 1 : attempts + 1;
        
        redisTemplate.opsForValue().set(attemptKey, attempts, Duration.ofMinutes(15));
        
        // 超过最大尝试次数则锁定账户
        if (attempts >= 5) {
            String lockKey = "account_lock:" + username;
            redisTemplate.opsForValue().set(lockKey, true, Duration.ofMinutes(30));
        }
    }
    
    private String generateAccessToken(Long userId) {
        return Jwts.builder()
            .setSubject(userId.toString())
            .claim("userId", userId)
            .claim("type", "access")
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + 3600000)) // 1小时
            .signWith(SignatureAlgorithm.HS256, getSigningKey())
            .compact();
    }
    
    private String generateRefreshToken(Long userId) {
        return Jwts.builder()
            .setSubject(userId.toString())
            .claim("userId", userId)
            .claim("type", "refresh")
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + 604800000)) // 7天
            .signWith(SignatureAlgorithm.HS256, getSigningKey())
            .compact();
    }
    
    private String getSigningKey() {
        return "your-secret-key"; // 实际应用中应从配置中获取
    }
}
```

### 2. 权限控制服务

```java
/**
 * 权限控制服务
 */
@Service
@Slf4j
public class AuthorizationService {
    
    @Autowired
    private UserRoleRepository userRoleRepository;
    
    @Autowired
    private RolePermissionRepository rolePermissionRepository;
    
    @Autowired
    private SecurityAuditService auditService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 检查用户权限
     */
    public AuthorizationResult checkPermission(Long userId, String resource, PermissionType permission) {
        try {
            // 1. 从缓存获取用户权限
            Set<String> userPermissions = getUserPermissions(userId);
            
            // 2. 构造权限标识
            String permissionKey = resource + ":" + permission.name();
            
            // 3. 检查权限
            if (userPermissions.contains(permissionKey) || userPermissions.contains("*:*")) {
                auditService.logSecurityEvent(userId, "PERMISSION_GRANTED", 
                    "Access granted to " + permissionKey, "LOW");
                return AuthorizationResult.granted();
            }
            
            // 4. 记录权限拒绝
            auditService.logSecurityEvent(userId, "PERMISSION_DENIED", 
                "Access denied to " + permissionKey, "MEDIUM");
            
            return AuthorizationResult.denied("权限不足");
            
        } catch (Exception e) {
            log.error("Authorization check error for user: {}", userId, e);
            return AuthorizationResult.denied("权限检查异常");
        }
    }
    
    /**
     * 获取用户权限列表
     */
    @Cacheable(value = "user_permissions", key = "#userId")
    public Set<String> getUserPermissions(Long userId) {
        Set<String> permissions = new HashSet<>();
        
        // 1. 获取用户角色
        List<UserRole> userRoles = userRoleRepository.findByUserId(userId);
        
        // 2. 获取角色权限
        for (UserRole userRole : userRoles) {
            List<RolePermission> rolePermissions = rolePermissionRepository
                .findByRoleId(userRole.getRoleId());
            
            for (RolePermission rolePermission : rolePermissions) {
                permissions.add(rolePermission.getResource() + ":" + rolePermission.getPermission());
            }
        }
        
        return permissions;
    }
    
    /**
     * 数据权限过滤
     */
    public DataPermissionFilter getDataPermissionFilter(Long userId, String dataType) {
        // 根据用户角色和数据类型构建数据权限过滤器
        List<UserRole> userRoles = userRoleRepository.findByUserId(userId);
        
        DataPermissionFilter filter = new DataPermissionFilter();
        
        for (UserRole userRole : userRoles) {
            switch (userRole.getRoleCode()) {
                case "ADMIN":
                    // 管理员可以访问所有数据
                    filter.setAccessAll(true);
                    break;
                case "DEPT_MANAGER":
                    // 部门经理可以访问本部门数据
                    filter.addDepartmentFilter(userRole.getDepartmentId());
                    break;
                case "USER":
                    // 普通用户只能访问自己的数据
                    filter.addUserFilter(userId);
                    break;
            }
        }
        
        return filter;
    }
}
```

### 3. 数据安全服务

```java
/**
 * 数据安全服务
 */
@Service
@Slf4j
public class DataSecurityService {
    
    @Autowired
    private AESUtil aesUtil;
    
    @Autowired
    private RSAUtil rsaUtil;
    
    /**
     * 敏感数据加密
     */
    public String encryptSensitiveData(String data, SecurityLevel level) {
        try {
            switch (level) {
                case PUBLIC:
                    return data; // 公开数据不加密
                case INTERNAL:
                case CONFIDENTIAL:
                    return aesUtil.encrypt(data); // AES加密
                case SECRET:
                case TOP_SECRET:
                    return rsaUtil.encrypt(data); // RSA加密
                default:
                    return aesUtil.encrypt(data);
            }
        } catch (Exception e) {
            log.error("Data encryption error", e);
            throw new SecurityException("数据加密失败");
        }
    }
    
    /**
     * 敏感数据解密
     */
    public String decryptSensitiveData(String encryptedData, SecurityLevel level) {
        try {
            switch (level) {
                case PUBLIC:
                    return encryptedData;
                case INTERNAL:
                case CONFIDENTIAL:
                    return aesUtil.decrypt(encryptedData);
                case SECRET:
                case TOP_SECRET:
                    return rsaUtil.decrypt(encryptedData);
                default:
                    return aesUtil.decrypt(encryptedData);
            }
        } catch (Exception e) {
            log.error("Data decryption error", e);
            throw new SecurityException("数据解密失败");
        }
    }
    
    /**
     * 数据脱敏
     */
    public String maskSensitiveData(String data, String dataType) {
        if (StringUtils.isEmpty(data)) {
            return data;
        }
        
        switch (dataType.toUpperCase()) {
            case "PHONE":
                // 手机号脱敏: 138****5678
                return data.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
            case "IMSI":
                // IMSI脱敏: 460****123456789
                return data.replaceAll("(\\d{3})\\d{4}(\\d+)", "$1****$2");
            case "ICCID":
                // ICCID脱敏: 8986****123456789
                return data.replaceAll("(\\d{4})\\d{8}(\\d+)", "$1****$2");
            case "ID_CARD":
                // 身份证脱敏: 110***********1234
                return data.replaceAll("(\\d{3})\\d{11}(\\d{4})", "$1***********$2");
            case "EMAIL":
                // 邮箱脱敏: abc***@example.com
                return data.replaceAll("(\\w{1,3})\\w*@", "$1***@");
            default:
                // 默认脱敏: 显示前3位和后3位
                if (data.length() <= 6) {
                    return "***";
                }
                return data.substring(0, 3) + "***" + data.substring(data.length() - 3);
        }
    }
    
    /**
     * 数据完整性校验
     */
    public boolean verifyDataIntegrity(String data, String signature) {
        try {
            String computedSignature = rsaUtil.sign(data);
            return signature.equals(computedSignature);
        } catch (Exception e) {
            log.error("Data integrity verification error", e);
            return false;
        }
    }
    
    /**
     * 生成数据签名
     */
    public String generateDataSignature(String data) {
        try {
            return rsaUtil.sign(data);
        } catch (Exception e) {
            log.error("Data signature generation error", e);
            throw new SecurityException("数据签名生成失败");
        }
    }
}
```

## 安全配置示例

### 1. Spring Security配置

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    
    @Autowired
    private JwtRequestFilter jwtRequestFilter;
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/auth/login", "/api/auth/refresh").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/actuator/health").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/sim-cards/**").hasRole("USER")
                .requestMatchers(HttpMethod.POST, "/api/sim-cards/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint)
            .and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .headers().frameOptions().deny()
            .contentTypeOptions().and()
            .httpStrictTransportSecurity(hstsConfig -> hstsConfig
                .maxAgeInSeconds(31536000)
                .includeSubdomains(true)
            );
        
        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

### 2. API安全配置

```yaml
# application-security.yml
security:
  jwt:
    secret: ${JWT_SECRET:your-secret-key}
    expiration: 3600000 # 1小时
    refresh-expiration: 604800000 # 7天
  
  rate-limit:
    enabled: true
    requests-per-minute: 100
    burst-capacity: 200
  
  cors:
    allowed-origins:
      - https://nsrs.example.com
      - https://admin.nsrs.example.com
    allowed-methods:
      - GET
      - POST
      - PUT
      - DELETE
    allowed-headers:
      - Authorization
      - Content-Type
      - X-Requested-With
    max-age: 3600
  
  encryption:
    aes:
      key: ${AES_KEY:your-aes-key}
      algorithm: AES/CBC/PKCS5Padding
    rsa:
      public-key: ${RSA_PUBLIC_KEY:classpath:keys/public.pem}
      private-key: ${RSA_PRIVATE_KEY:classpath:keys/private.pem}
      algorithm: RSA/ECB/PKCS1Padding
```

## 安全最佳实践

### 1. 密码安全策略
- **复杂度要求**: 至少8位，包含大小写字母、数字、特殊字符
- **历史密码**: 不能重复使用最近5次密码
- **定期更换**: 强制90天更换密码
- **加密存储**: 使用BCrypt加密存储

### 2. 会话管理
- **会话超时**: 30分钟无操作自动超时
- **并发控制**: 同一用户最多3个并发会话
- **安全注销**: 清除所有会话信息
- **会话固化**: 登录后重新生成会话ID

### 3. API安全
- **HTTPS强制**: 所有API必须使用HTTPS
- **请求签名**: 关键API使用请求签名验证
- **频率限制**: 防止API滥用和DDoS攻击
- **输入验证**: 严格的输入参数验证

### 4. 数据保护
- **分级加密**: 根据数据敏感级别选择加密算法
- **传输加密**: 数据传输过程中的端到端加密
- **存储加密**: 敏感数据落盘加密
- **访问审计**: 记录所有数据访问操作

通过以上安全架构设计和实施，NSRS系统可以建立完善的安全防护体系，确保系统和数据的安全性。