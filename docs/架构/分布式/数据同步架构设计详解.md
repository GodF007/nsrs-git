# 数据同步架构设计详解

基于Canal+RocketMQ的NSRS号卡资源管理系统数据同步解决方案

## 目录

- [数据同步概述](#数据同步概述)
- [核心组件设计](#核心组件设计)
- [Canal集成方案](#canal集成方案)
- [同步策略](#同步策略)
- [业务场景应用](#业务场景应用)
- [性能优化](#性能优化)
- [最佳实践](#最佳实践)

## 数据同步概述

### 设计目标

- **实时同步**: 毫秒级数据变更同步
- **高可靠**: 保证数据同步的可靠性和一致性
- **高性能**: 支持大数据量的高并发同步
- **灵活配置**: 支持多种同步策略和过滤规则
- **监控告警**: 完善的同步监控和异常告警

### 架构图

```
NSRS数据同步架构：

┌─────────────────────────────────────────────────────────────┐
│                    数据同步控制台                            │
│              (Canal Admin Console)                         │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────────┐
│                  Canal Server集群                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  Canal-1    │  │   Canal-2   │  │   Canal-3   │        │
│  │             │  │             │  │             │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │ Binlog解析
┌─────────────────────▼───────────────────────────────────────┐
│                   MySQL主库集群                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  Master-1   │  │  Master-2   │  │  Master-3   │        │
│  │   (IMSI)    │  │   (SIM)     │  │   (User)    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │ 数据变更事件
┌─────────────────────▼───────────────────────────────────────┐
│                  RocketMQ集群                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │NameServer-1 │  │NameServer-2 │  │NameServer-3 │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  Broker-1   │  │  Broker-2   │  │  Broker-3   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │ 消息消费
        ┌─────────────┼─────────────┐
        │             │             │
┌───────▼──────┐ ┌───▼────┐ ┌──────▼──────┐
│ 缓存同步服务  │ │搜索同步 │ │ 报表同步服务 │
│              │ │服务    │ │             │
│ ┌─────────┐  │ │┌──────┐│ │ ┌─────────┐ │
│ │ Redis   │  │ ││ES    ││ │ │ClickHouse│ │
│ │ 同步    │  │ ││同步  ││ │ │ 同步     │ │
│ └─────────┘  │ │└──────┘│ │ └─────────┘ │
└──────────────┘ └────────┘ └─────────────┘
       │             │             │
┌──────▼──────┐ ┌───▼────┐ ┌──────▼──────┐
│ Redis集群   │ │ES集群  │ │ClickHouse   │
│             │ │        │ │ 集群        │
└─────────────┘ └────────┘ └─────────────┘
```

## 核心组件设计

### 1. 同步枚举定义

```java
/**
 * 同步类型
 */
public enum SyncType {
    REAL_TIME("REAL_TIME", "实时同步"),
    BATCH("BATCH", "批量同步"),
    INCREMENTAL("INCREMENTAL", "增量同步"),
    FULL("FULL", "全量同步");
    
    private final String code;
    private final String description;
    
    SyncType(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}

/**
 * 同步状态
 */
public enum SyncStatus {
    RUNNING("RUNNING", "运行中"),
    STOPPED("STOPPED", "已停止"),
    ERROR("ERROR", "错误"),
    PAUSED("PAUSED", "已暂停"),
    COMPLETED("COMPLETED", "已完成");
    
    private final String code;
    private final String description;
    
    SyncStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}

/**
 * 数据变更类型
 */
public enum ChangeType {
    INSERT("INSERT", "新增"),
    UPDATE("UPDATE", "更新"),
    DELETE("DELETE", "删除");
    
    private final String code;
    private final String description;
    
    ChangeType(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

### 2. 同步实体设计

```java
/**
 * 数据变更事件
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DataChangeEvent {
    
    /**
     * 事件ID
     */
    private String eventId;
    
    /**
     * 数据库名
     */
    private String database;
    
    /**
     * 表名
     */
    private String table;
    
    /**
     * 变更类型
     */
    private ChangeType changeType;
    
    /**
     * 变更前数据
     */
    private Map<String, Object> beforeData;
    
    /**
     * 变更后数据
     */
    private Map<String, Object> afterData;
    
    /**
     * 主键值
     */
    private Map<String, Object> primaryKeys;
    
    /**
     * 变更时间
     */
    private LocalDateTime changeTime;
    
    /**
     * Binlog位置
     */
    private String binlogPosition;
    
    /**
     * 事务ID
     */
    private String transactionId;
    
    /**
     * 执行时间
     */
    private Long executeTime;
}

/**
 * 同步任务配置
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SyncTaskConfig {
    
    /**
     * 任务ID
     */
    private String taskId;
    
    /**
     * 任务名称
     */
    private String taskName;
    
    /**
     * 同步类型
     */
    private SyncType syncType;
    
    /**
     * 源数据库配置
     */
    private DataSourceConfig sourceConfig;
    
    /**
     * 目标数据库配置
     */
    private DataSourceConfig targetConfig;
    
    /**
     * 同步表配置
     */
    private List<TableSyncConfig> tableConfigs;
    
    /**
     * 过滤规则
     */
    private List<FilterRule> filterRules;
    
    /**
     * 同步状态
     */
    private SyncStatus status;
    
    /**
     * 是否启用
     */
    private Boolean enabled;
    
    /**
     * 创建时间
     */
    private LocalDateTime createTime;
    
    /**
     * 更新时间
     */
    private LocalDateTime updateTime;
}

/**
 * 表同步配置
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TableSyncConfig {
    
    /**
     * 源表名
     */
    private String sourceTable;
    
    /**
     * 目标表名
     */
    private String targetTable;
    
    /**
     * 字段映射
     */
    private Map<String, String> fieldMapping;
    
    /**
     * 主键字段
     */
    private List<String> primaryKeys;
    
    /**
     * 是否同步删除
     */
    private Boolean syncDelete;
    
    /**
     * 批量大小
     */
    private Integer batchSize;
    
    /**
     * 同步延迟(毫秒)
     */
    private Long syncDelay;
}
```

## Canal集成方案

### 1. Canal Server配置

```yaml
# docker-compose.yml
version: '3.8'
services:
  canal-server-1:
    image: canal/canal-server:v1.1.6
    hostname: canal-server-1
    ports:
      - "11111:11111"
    environment:
      - canal.destinations=nsrs-imsi,nsrs-sim,nsrs-user
      - canal.instance.master.address=mysql-master:3306
      - canal.instance.dbUsername=canal
      - canal.instance.dbPassword=canal123
      - canal.instance.filter.regex=nsrs_imsi\..*,nsrs_sim\..*,nsrs_user\..*
      - canal.serverMode=rocketMQ
      - rocketmq.producer.group=canal-producer
      - rocketmq.namesrv.addr=rocketmq-namesrv:9876
    volumes:
      - ./canal-config:/home/admin/canal-server/conf
    networks:
      - nsrs-network
    depends_on:
      - mysql-master
      - rocketmq-namesrv

  canal-server-2:
    image: canal/canal-server:v1.1.6
    hostname: canal-server-2
    ports:
      - "11112:11111"
    environment:
      - canal.destinations=nsrs-billing,nsrs-report
      - canal.instance.master.address=mysql-master:3306
      - canal.instance.dbUsername=canal
      - canal.instance.dbPassword=canal123
      - canal.instance.filter.regex=nsrs_billing\..*,nsrs_report\..*
      - canal.serverMode=rocketMQ
      - rocketmq.producer.group=canal-producer
      - rocketmq.namesrv.addr=rocketmq-namesrv:9876
    volumes:
      - ./canal-config:/home/admin/canal-server/conf
    networks:
      - nsrs-network
    depends_on:
      - mysql-master
      - rocketmq-namesrv

  canal-admin:
    image: canal/canal-admin:v1.1.6
    hostname: canal-admin
    ports:
      - "8089:8089"
    environment:
      - server.port=8089
      - canal.adminUser=admin
      - canal.adminPasswd=admin123
      - spring.datasource.address=mysql-master:3306
      - spring.datasource.database=canal_manager
      - spring.datasource.username=canal
      - spring.datasource.password=canal123
    networks:
      - nsrs-network
    depends_on:
      - mysql-master

networks:
  nsrs-network:
    driver: bridge
```

### 2. Canal实例配置

```properties
# canal.properties
canal.id = 1
canal.ip =
canal.port = 11111
canal.metrics.pull.port = 11112
canal.zkServers =

# tcp, kafka, rocketMQ, rabbitMQ
canal.serverMode = rocketMQ

# flush data to zk
canal.zookeeper.flush.period = 1000
canal.withoutNetty = false

# tcp configure
canal.tcp.no.ack = false
canal.tcp.batch.size = 16384
canal.tcp.flush.timeout = 100

# rocketMQ configure
rocketmq.producer.group = canal-producer
rocketmq.enable.message.trace = false
rocketmq.customized.trace.topic =
rocketmq.namespace =
rocketmq.namesrv.addr = rocketmq-namesrv:9876
rocketmq.retry.times.when.send.failed = 0
rocketmq.vip.channel.enabled = false
rocketmq.tag = 

# instance.properties
canal.instance.mysql.slaveId=20
canal.instance.master.address=mysql-master:3306
canal.instance.master.journal.name=
canal.instance.master.position=
canal.instance.master.timestamp=
canal.instance.master.gtid=

canal.instance.dbUsername=canal
canal.instance.dbPassword=canal123
canal.instance.connectionCharset = UTF-8
canal.instance.enableDruid=false

canal.instance.filter.druid.ddl=true
canal.instance.filter.query.dcl=false
canal.instance.filter.query.dml=false
canal.instance.filter.query.ddl=false
canal.instance.filter.table.error=false
canal.instance.filter.rows=false
canal.instance.filter.transaction.entry=false

canal.instance.filter.regex=nsrs_imsi\.imsi_resource,nsrs_sim\.sim_card,nsrs_user\.user_account

canal.instance.filter.black.regex=
canal.instance.get.ddl.isolation=false

canal.instance.parser.parallel=true
canal.instance.parser.parallelThreadSize=16
canal.instance.parser.parallelBufferSize=256

canal.instance.tsdb.enable=true
canal.instance.tsdb.dir=${canal.file.data.dir:../conf}/${canal.instance.destination:}
canal.instance.tsdb.url=jdbc:h2:${canal.instance.tsdb.dir}/h2;CACHE_SIZE=1000;MODE=MYSQL;
canal.instance.tsdb.dbUsername=canal
canal.instance.tsdb.dbPassword=canal
```

### 3. Canal客户端实现

```java
/**
 * Canal客户端服务
 */
@Service
@Slf4j
public class CanalClientService {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    @Autowired
    private DataSyncProcessor dataSyncProcessor;
    
    private CanalConnector connector;
    
    @PostConstruct
    public void init() {
        // 创建Canal连接器
        connector = CanalConnectors.newSingleConnector(
            new InetSocketAddress("canal-server", 11111),
            "nsrs-sync", "", ""
        );
        
        // 启动数据同步
        startSync();
    }
    
    @Async
    public void startSync() {
        try {
            connector.connect();
            connector.subscribe("nsrs_.*\\..*");
            connector.rollback();
            
            while (true) {
                Message message = connector.getWithoutAck(1000);
                long batchId = message.getBatchId();
                int size = message.getEntries().size();
                
                if (batchId == -1 || size == 0) {
                    Thread.sleep(1000);
                    continue;
                }
                
                log.info("接收到Canal消息: batchId={}, size={}", batchId, size);
                
                try {
                    processEntries(message.getEntries());
                    connector.ack(batchId);
                } catch (Exception e) {
                    log.error("处理Canal消息失败: batchId={}, error={}", batchId, e.getMessage(), e);
                    connector.rollback(batchId);
                }
            }
            
        } catch (Exception e) {
            log.error("Canal同步异常: {}", e.getMessage(), e);
        } finally {
            connector.disconnect();
        }
    }
    
    private void processEntries(List<Entry> entries) {
        for (Entry entry : entries) {
            if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || 
                entry.getEntryType() == EntryType.TRANSACTIONEND) {
                continue;
            }
            
            if (entry.getEntryType() == EntryType.ROWDATA) {
                processRowData(entry);
            }
        }
    }
    
    private void processRowData(Entry entry) {
        try {
            RowChange rowChange = RowChange.parseFrom(entry.getStoreValue());
            EventType eventType = rowChange.getEventType();
            
            if (eventType == EventType.INSERT || 
                eventType == EventType.UPDATE || 
                eventType == EventType.DELETE) {
                
                for (RowData rowData : rowChange.getRowDatasList()) {
                    DataChangeEvent changeEvent = buildChangeEvent(entry, eventType, rowData);
                    
                    // 发送到RocketMQ
                    String topic = getTopicByTable(entry.getHeader().getTableName());
                    rocketMQTemplate.convertAndSend(topic, changeEvent);
                    
                    log.debug("发送数据变更事件: table={}, eventType={}, eventId={}", 
                        entry.getHeader().getTableName(), eventType, changeEvent.getEventId());
                }
            }
            
        } catch (Exception e) {
            log.error("处理行数据失败: {}", e.getMessage(), e);
            throw new RuntimeException(e);
        }
    }
    
    private DataChangeEvent buildChangeEvent(Entry entry, EventType eventType, RowData rowData) {
        Header header = entry.getHeader();
        
        return DataChangeEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .database(header.getSchemaName())
            .table(header.getTableName())
            .changeType(convertChangeType(eventType))
            .beforeData(convertColumns(rowData.getBeforeColumnsList()))
            .afterData(convertColumns(rowData.getAfterColumnsList()))
            .primaryKeys(extractPrimaryKeys(rowData))
            .changeTime(LocalDateTime.ofEpochMilli(header.getExecuteTime()))
            .binlogPosition(header.getLogfileName() + ":" + header.getLogfileOffset())
            .transactionId(String.valueOf(header.getGtid()))
            .executeTime(header.getExecuteTime())
            .build();
    }
    
    private ChangeType convertChangeType(EventType eventType) {
        switch (eventType) {
            case INSERT:
                return ChangeType.INSERT;
            case UPDATE:
                return ChangeType.UPDATE;
            case DELETE:
                return ChangeType.DELETE;
            default:
                throw new IllegalArgumentException("Unsupported event type: " + eventType);
        }
    }
    
    private Map<String, Object> convertColumns(List<Column> columns) {
        Map<String, Object> data = new HashMap<>();
        for (Column column : columns) {
            data.put(column.getName(), column.getValue());
        }
        return data;
    }
    
    private Map<String, Object> extractPrimaryKeys(RowData rowData) {
        Map<String, Object> primaryKeys = new HashMap<>();
        
        List<Column> columns = rowData.getAfterColumnsList().isEmpty() ? 
            rowData.getBeforeColumnsList() : rowData.getAfterColumnsList();
        
        for (Column column : columns) {
            if (column.getIsKey()) {
                primaryKeys.put(column.getName(), column.getValue());
            }
        }
        
        return primaryKeys;
    }
    
    private String getTopicByTable(String tableName) {
        // 根据表名确定MQ主题
        if (tableName.contains("imsi")) {
            return "nsrs-imsi-sync";
        } else if (tableName.contains("sim")) {
            return "nsrs-sim-sync";
        } else if (tableName.contains("user")) {
            return "nsrs-user-sync";
        } else {
            return "nsrs-default-sync";
        }
    }
}
```

## 同步策略

### 1. 缓存同步服务

```java
/**
 * Redis缓存同步服务
 */
@Service
@Slf4j
public class RedisSyncService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ImsiResourceMapper imsiResourceMapper;
    
    /**
     * 处理IMSI资源变更
     */
    @RocketMQMessageListener(
        topic = "nsrs-imsi-sync",
        consumerGroup = "redis-sync-consumer"
    )
    @Component
    public class ImsiRedisSyncListener implements RocketMQListener<DataChangeEvent> {
        
        @Override
        public void onMessage(DataChangeEvent event) {
            log.info("接收到IMSI数据变更事件: {}", event.getEventId());
            
            try {
                switch (event.getChangeType()) {
                    case INSERT:
                    case UPDATE:
                        syncImsiToRedis(event);
                        break;
                    case DELETE:
                        deleteImsiFromRedis(event);
                        break;
                }
                
                log.info("IMSI缓存同步完成: eventId={}, table={}, changeType={}", 
                    event.getEventId(), event.getTable(), event.getChangeType());
                    
            } catch (Exception e) {
                log.error("IMSI缓存同步失败: eventId={}, error={}", 
                    event.getEventId(), e.getMessage(), e);
                throw e;
            }
        }
        
        private void syncImsiToRedis(DataChangeEvent event) {
            Map<String, Object> data = event.getAfterData();
            String imsi = (String) data.get("imsi");
            
            if (StringUtils.hasText(imsi)) {
                // 缓存IMSI基本信息
                String cacheKey = "imsi:" + imsi;
                redisTemplate.opsForHash().putAll(cacheKey, data);
                redisTemplate.expire(cacheKey, Duration.ofHours(24));
                
                // 更新IMSI状态索引
                String status = (String) data.get("status");
                if (StringUtils.hasText(status)) {
                    String statusKey = "imsi:status:" + status;
                    redisTemplate.opsForSet().add(statusKey, imsi);
                }
                
                // 更新运营商索引
                String operatorId = (String) data.get("operator_id");
                if (StringUtils.hasText(operatorId)) {
                    String operatorKey = "imsi:operator:" + operatorId;
                    redisTemplate.opsForSet().add(operatorKey, imsi);
                }
            }
        }
        
        private void deleteImsiFromRedis(DataChangeEvent event) {
            Map<String, Object> data = event.getBeforeData();
            String imsi = (String) data.get("imsi");
            
            if (StringUtils.hasText(imsi)) {
                // 删除IMSI基本信息
                String cacheKey = "imsi:" + imsi;
                redisTemplate.delete(cacheKey);
                
                // 从状态索引中移除
                String status = (String) data.get("status");
                if (StringUtils.hasText(status)) {
                    String statusKey = "imsi:status:" + status;
                    redisTemplate.opsForSet().remove(statusKey, imsi);
                }
                
                // 从运营商索引中移除
                String operatorId = (String) data.get("operator_id");
                if (StringUtils.hasText(operatorId)) {
                    String operatorKey = "imsi:operator:" + operatorId;
                    redisTemplate.opsForSet().remove(operatorKey, imsi);
                }
            }
        }
    }
}
```

### 2. 搜索引擎同步服务

```java
/**
 * Elasticsearch同步服务
 */
@Service
@Slf4j
public class ElasticsearchSyncService {
    
    @Autowired
    private ElasticsearchRestTemplate elasticsearchTemplate;
    
    /**
     * 处理IMSI资源搜索同步
     */
    @RocketMQMessageListener(
        topic = "nsrs-imsi-sync",
        consumerGroup = "es-sync-consumer"
    )
    @Component
    public class ImsiEsSyncListener implements RocketMQListener<DataChangeEvent> {
        
        @Override
        public void onMessage(DataChangeEvent event) {
            log.info("接收到IMSI搜索同步事件: {}", event.getEventId());
            
            try {
                switch (event.getChangeType()) {
                    case INSERT:
                    case UPDATE:
                        syncImsiToEs(event);
                        break;
                    case DELETE:
                        deleteImsiFromEs(event);
                        break;
                }
                
                log.info("IMSI搜索同步完成: eventId={}, changeType={}", 
                    event.getEventId(), event.getChangeType());
                    
            } catch (Exception e) {
                log.error("IMSI搜索同步失败: eventId={}, error={}", 
                    event.getEventId(), e.getMessage(), e);
                throw e;
            }
        }
        
        private void syncImsiToEs(DataChangeEvent event) {
            Map<String, Object> data = event.getAfterData();
            String imsi = (String) data.get("imsi");
            
            if (StringUtils.hasText(imsi)) {
                // 构建ES文档
                ImsiSearchDocument document = ImsiSearchDocument.builder()
                    .imsi(imsi)
                    .operatorId((String) data.get("operator_id"))
                    .operatorName((String) data.get("operator_name"))
                    .region((String) data.get("region"))
                    .status((String) data.get("status"))
                    .allocatedUserId((String) data.get("allocated_user_id"))
                    .allocatedTime(parseDateTime((String) data.get("allocated_time")))
                    .createTime(parseDateTime((String) data.get("create_time")))
                    .updateTime(parseDateTime((String) data.get("update_time")))
                    .build();
                
                // 索引到ES
                IndexQuery indexQuery = new IndexQueryBuilder()
                    .withId(imsi)
                    .withObject(document)
                    .build();
                
                elasticsearchTemplate.index(indexQuery, 
                    IndexCoordinates.of("nsrs-imsi-resource"));
            }
        }
        
        private void deleteImsiFromEs(DataChangeEvent event) {
            Map<String, Object> data = event.getBeforeData();
            String imsi = (String) data.get("imsi");
            
            if (StringUtils.hasText(imsi)) {
                elasticsearchTemplate.delete(imsi, 
                    IndexCoordinates.of("nsrs-imsi-resource"));
            }
        }
        
        private LocalDateTime parseDateTime(String dateTimeStr) {
            if (StringUtils.hasText(dateTimeStr)) {
                return LocalDateTime.parse(dateTimeStr, 
                    DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            }
            return null;
        }
    }
}
```

### 3. 数据仓库同步服务

```java
/**
 * ClickHouse数据仓库同步服务
 */
@Service
@Slf4j
public class ClickHouseSyncService {
    
    @Autowired
    private JdbcTemplate clickHouseJdbcTemplate;
    
    /**
     * 处理数据仓库同步
     */
    @RocketMQMessageListener(
        topic = "nsrs-imsi-sync",
        consumerGroup = "clickhouse-sync-consumer"
    )
    @Component
    public class ImsiClickHouseSyncListener implements RocketMQListener<DataChangeEvent> {
        
        @Override
        public void onMessage(DataChangeEvent event) {
            log.info("接收到IMSI数据仓库同步事件: {}", event.getEventId());
            
            try {
                // 只同步INSERT和UPDATE事件到数据仓库
                if (event.getChangeType() == ChangeType.INSERT || 
                    event.getChangeType() == ChangeType.UPDATE) {
                    syncImsiToClickHouse(event);
                }
                
                log.info("IMSI数据仓库同步完成: eventId={}, changeType={}", 
                    event.getEventId(), event.getChangeType());
                    
            } catch (Exception e) {
                log.error("IMSI数据仓库同步失败: eventId={}, error={}", 
                    event.getEventId(), e.getMessage(), e);
                throw e;
            }
        }
        
        private void syncImsiToClickHouse(DataChangeEvent event) {
            Map<String, Object> data = event.getAfterData();
            
            String sql = "INSERT INTO nsrs_dw.imsi_resource_log " +
                "(event_id, imsi, operator_id, operator_name, region, status, " +
                "allocated_user_id, allocated_time, change_type, change_time, " +
                "binlog_position, transaction_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
            
            clickHouseJdbcTemplate.update(sql,
                event.getEventId(),
                data.get("imsi"),
                data.get("operator_id"),
                data.get("operator_name"),
                data.get("region"),
                data.get("status"),
                data.get("allocated_user_id"),
                parseDateTime((String) data.get("allocated_time")),
                event.getChangeType().getCode(),
                event.getChangeTime(),
                event.getBinlogPosition(),
                event.getTransactionId()
            );
        }
        
        private Timestamp parseDateTime(String dateTimeStr) {
            if (StringUtils.hasText(dateTimeStr)) {
                LocalDateTime localDateTime = LocalDateTime.parse(dateTimeStr, 
                    DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
                return Timestamp.valueOf(localDateTime);
            }
            return null;
        }
    }
}
```

## 业务场景应用

### 1. 数据同步控制器

```java
/**
 * 数据同步管理控制器
 */
@RestController
@RequestMapping("/api/v1/sync")
@Slf4j
public class DataSyncController {
    
    @Autowired
    private DataSyncService dataSyncService;
    
    @Autowired
    private SyncTaskService syncTaskService;
    
    @Autowired
    private SyncMonitorService syncMonitorService;
    
    /**
     * 创建同步任务
     */
    @PostMapping("/tasks")
    public Result<String> createSyncTask(@RequestBody @Valid SyncTaskConfig config) {
        String taskId = syncTaskService.createTask(config);
        return Result.success(taskId);
    }
    
    /**
     * 启动同步任务
     */
    @PostMapping("/tasks/{taskId}/start")
    public Result<Void> startSyncTask(@PathVariable String taskId) {
        syncTaskService.startTask(taskId);
        return Result.success();
    }
    
    /**
     * 停止同步任务
     */
    @PostMapping("/tasks/{taskId}/stop")
    public Result<Void> stopSyncTask(@PathVariable String taskId) {
        syncTaskService.stopTask(taskId);
        return Result.success();
    }
    
    /**
     * 获取同步任务列表
     */
    @GetMapping("/tasks")
    public Result<List<SyncTaskConfig>> getSyncTasks(
            @RequestParam(defaultValue = "1") Integer page,
            @RequestParam(defaultValue = "20") Integer size) {
        
        List<SyncTaskConfig> tasks = syncTaskService.getTasks(page, size);
        return Result.success(tasks);
    }
    
    /**
     * 获取同步任务详情
     */
    @GetMapping("/tasks/{taskId}")
    public Result<SyncTaskConfig> getSyncTask(@PathVariable String taskId) {
        SyncTaskConfig task = syncTaskService.getTask(taskId);
        return Result.success(task);
    }
    
    /**
     * 获取同步统计信息
     */
    @GetMapping("/statistics")
    public Result<SyncStatistics> getSyncStatistics(
            @RequestParam(defaultValue = "1") Integer days) {
        
        SyncStatistics statistics = syncMonitorService.getSyncStatistics(days);
        return Result.success(statistics);
    }
    
    /**
     * 手动触发全量同步
     */
    @PostMapping("/tasks/{taskId}/full-sync")
    public Result<Void> triggerFullSync(@PathVariable String taskId) {
        dataSyncService.triggerFullSync(taskId);
        return Result.success();
    }
    
    /**
     * 重置同步位点
     */
    @PostMapping("/tasks/{taskId}/reset-position")
    public Result<Void> resetSyncPosition(@PathVariable String taskId,
                                        @RequestParam String position) {
        syncTaskService.resetPosition(taskId, position);
        return Result.success();
    }
}
```

### 2. 同步监控服务

```java
/**
 * 同步监控服务
 */
@Service
@Slf4j
public class SyncMonitorService {
    
    @Autowired
    private SyncTaskMapper syncTaskMapper;
    
    @Autowired
    private SyncLogMapper syncLogMapper;
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    private final Counter syncEventCounter;
    private final Timer syncLatencyTimer;
    private final Gauge syncLagGauge;
    
    public SyncMonitorService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.syncEventCounter = Counter.builder("data_sync_events_total")
            .description("数据同步事件总数")
            .register(meterRegistry);
        this.syncLatencyTimer = Timer.builder("data_sync_latency")
            .description("数据同步延迟")
            .register(meterRegistry);
        this.syncLagGauge = Gauge.builder("data_sync_lag_seconds")
            .description("数据同步滞后时间")
            .register(meterRegistry, this, SyncMonitorService::getCurrentSyncLag);
    }
    
    /**
     * 记录同步事件
     */
    public void recordSyncEvent(String taskId, String table, ChangeType changeType, 
                              boolean success, long latency) {
        syncEventCounter.increment(
            Tags.of(
                "task_id", taskId,
                "table", table,
                "change_type", changeType.getCode(),
                "success", String.valueOf(success)
            )
        );
        
        syncLatencyTimer.record(latency, TimeUnit.MILLISECONDS,
            Tags.of(
                "task_id", taskId,
                "table", table
            ));
    }
    
    /**
     * 获取同步统计信息
     */
    public SyncStatistics getSyncStatistics(Integer days) {
        LocalDateTime startTime = LocalDateTime.now().minusDays(days);
        
        // 统计同步事件数量
        Map<String, Long> eventCount = syncLogMapper.countEventsByTime(startTime);
        
        // 统计平均延迟
        Double avgLatency = syncLogMapper.avgLatencyByTime(startTime);
        
        // 统计成功率
        Long totalEvents = eventCount.values().stream().mapToLong(Long::longValue).sum();
        Long successEvents = eventCount.getOrDefault("success", 0L);
        Double successRate = totalEvents > 0 ? (double) successEvents / totalEvents * 100 : 0.0;
        
        // 获取当前同步滞后
        Double currentLag = getCurrentSyncLag();
        
        return SyncStatistics.builder()
            .totalEvents(totalEvents)
            .successEvents(successEvents)
            .failedEvents(eventCount.getOrDefault("failed", 0L))
            .avgLatency(avgLatency)
            .successRate(successRate)
            .currentLag(currentLag)
            .statisticsPeriod(days)
            .build();
    }
    
    /**
     * 获取当前同步滞后时间
     */
    public Double getCurrentSyncLag() {
        try {
            // 查询最新的binlog位置和时间
            String latestPosition = syncTaskMapper.getLatestBinlogPosition();
            LocalDateTime latestTime = syncTaskMapper.getLatestSyncTime();
            
            if (latestTime != null) {
                Duration lag = Duration.between(latestTime, LocalDateTime.now());
                return (double) lag.getSeconds();
            }
            
            return 0.0;
            
        } catch (Exception e) {
            log.warn("获取同步滞后时间失败: {}", e.getMessage());
            return 0.0;
        }
    }
    
    /**
     * 检查同步健康状态
     */
    @Scheduled(fixedDelay = 60000) // 每分钟检查一次
    public void checkSyncHealth() {
        List<SyncTaskConfig> tasks = syncTaskMapper.selectRunningTasks();
        
        for (SyncTaskConfig task : tasks) {
            checkTaskHealth(task);
        }
    }
    
    private void checkTaskHealth(SyncTaskConfig task) {
        try {
            // 检查任务是否正常运行
            LocalDateTime lastSyncTime = syncLogMapper.getLastSyncTime(task.getTaskId());
            
            if (lastSyncTime != null) {
                Duration timeSinceLastSync = Duration.between(lastSyncTime, LocalDateTime.now());
                
                // 如果超过5分钟没有同步，发送告警
                if (timeSinceLastSync.toMinutes() > 5) {
                    sendSyncAlert(task, "同步任务可能已停止", 
                        "任务 " + task.getTaskName() + " 超过5分钟没有同步数据");
                }
            }
            
            // 检查错误率
            Double errorRate = syncLogMapper.getErrorRate(task.getTaskId(), 
                LocalDateTime.now().minusMinutes(10));
            
            if (errorRate != null && errorRate > 10.0) {
                sendSyncAlert(task, "同步错误率过高", 
                    "任务 " + task.getTaskName() + " 错误率达到 " + errorRate + "%");
            }
            
        } catch (Exception e) {
            log.error("检查同步任务健康状态失败: taskId={}, error={}", 
                task.getTaskId(), e.getMessage(), e);
        }
    }
    
    private void sendSyncAlert(SyncTaskConfig task, String title, String message) {
        log.warn("同步告警: taskId={}, title={}, message={}", 
            task.getTaskId(), title, message);
        // 这里可以集成告警系统
    }
}
```

## 性能优化

### 1. 批量处理优化

```java
/**
 * 批量同步处理器
 */
@Component
@Slf4j
public class BatchSyncProcessor {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ElasticsearchRestTemplate elasticsearchTemplate;
    
    private final Map<String, List<DataChangeEvent>> batchBuffer = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(4);
    
    @PostConstruct
    public void init() {
        // 每秒执行一次批量处理
        scheduler.scheduleAtFixedRate(this::processBatch, 1, 1, TimeUnit.SECONDS);
    }
    
    /**
     * 添加事件到批量缓冲区
     */
    public void addToBatch(String target, DataChangeEvent event) {
        batchBuffer.computeIfAbsent(target, k -> new ArrayList<>()).add(event);
    }
    
    /**
     * 处理批量数据
     */
    private void processBatch() {
        for (Map.Entry<String, List<DataChangeEvent>> entry : batchBuffer.entrySet()) {
            String target = entry.getKey();
            List<DataChangeEvent> events = entry.getValue();
            
            if (!events.isEmpty()) {
                try {
                    // 清空缓冲区
                    List<DataChangeEvent> batchEvents = new ArrayList<>(events);
                    events.clear();
                    
                    // 批量处理
                    processBatchEvents(target, batchEvents);
                    
                } catch (Exception e) {
                    log.error("批量处理失败: target={}, size={}, error={}", 
                        target, events.size(), e.getMessage(), e);
                }
            }
        }
    }
    
    private void processBatchEvents(String target, List<DataChangeEvent> events) {
        switch (target) {
            case "redis":
                batchSyncToRedis(events);
                break;
            case "elasticsearch":
                batchSyncToElasticsearch(events);
                break;
            default:
                log.warn("未知的同步目标: {}", target);
        }
    }
    
    private void batchSyncToRedis(List<DataChangeEvent> events) {
        // Redis批量操作
        redisTemplate.executePipelined(new RedisCallback<Object>() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                for (DataChangeEvent event : events) {
                    processRedisEvent(connection, event);
                }
                return null;
            }
        });
        
        log.info("Redis批量同步完成: size={}", events.size());
    }
    
    private void batchSyncToElasticsearch(List<DataChangeEvent> events) {
        List<IndexQuery> indexQueries = new ArrayList<>();
        
        for (DataChangeEvent event : events) {
            if (event.getChangeType() != ChangeType.DELETE) {
                IndexQuery indexQuery = buildIndexQuery(event);
                if (indexQuery != null) {
                    indexQueries.add(indexQuery);
                }
            }
        }
        
        if (!indexQueries.isEmpty()) {
            elasticsearchTemplate.bulkIndex(indexQueries, 
                IndexCoordinates.of("nsrs-imsi-resource"));
        }
        
        log.info("Elasticsearch批量同步完成: size={}", indexQueries.size());
    }
    
    private void processRedisEvent(RedisConnection connection, DataChangeEvent event) {
        // 实现Redis单个事件处理逻辑
        // 这里简化处理
    }
    
    private IndexQuery buildIndexQuery(DataChangeEvent event) {
        // 构建ES索引查询
        // 这里简化处理
        return null;
    }
}
```

### 2. 同步性能监控

```yaml
# Prometheus告警规则
groups:
  - name: data-sync-alerts
    rules:
      - alert: HighSyncLatency
        expr: |
          histogram_quantile(0.95, 
            sum(rate(data_sync_latency_bucket[5m])) by (le, task_id)
          ) > 5000
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "数据同步延迟过高"
          description: "任务 {{ $labels.task_id }} 的95%同步延迟超过5秒"
      
      - alert: SyncLagTooHigh
        expr: data_sync_lag_seconds > 300
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "数据同步滞后过多"
          description: "数据同步滞后时间超过5分钟，当前滞后: {{ $value }}秒"
      
      - alert: SyncFailureRate
        expr: |
          (
            sum(rate(data_sync_events_total{success="false"}[5m])) /
            sum(rate(data_sync_events_total[5m]))
          ) * 100 > 5
        for: 3m
        labels:
          severity: warning
        annotations:
          summary: "数据同步失败率过高"
          description: "数据同步失败率超过5%，当前失败率: {{ $value }}%"
```

## 最佳实践

### 1. 同步设计原则

- **幂等性**: 确保重复同步不会产生副作用
- **顺序性**: 保证同一数据的变更顺序
- **完整性**: 确保数据同步的完整性
- **实时性**: 尽可能减少同步延迟

### 2. 性能优化

- **批量处理**: 使用批量操作提高吞吐量
- **并行处理**: 合理使用并行处理提高效率
- **缓存优化**: 减少重复的数据库查询
- **网络优化**: 优化网络传输和序列化

### 3. 监控运维

- **实时监控**: 监控同步延迟、吞吐量、错误率
- **告警机制**: 及时发现和处理同步异常
- **日志审计**: 完整记录同步操作日志
- **故障恢复**: 快速恢复同步服务

通过以上数据同步架构设计，NSRS系统实现了高效、可靠的数据同步能力，保障了各个存储系统之间的数据一致性。