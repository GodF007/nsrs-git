# 分布式事务架构设计详解

基于Seata的NSRS号卡资源管理系统分布式事务解决方案

## 目录

- [分布式事务概述](#分布式事务概述)
- [核心组件设计](#核心组件设计)
- [Seata集成方案](#seata集成方案)
- [事务模式](#事务模式)
- [业务场景应用](#业务场景应用)
- [性能优化](#性能优化)
- [最佳实践](#最佳实践)

## 分布式事务概述

### 设计目标

- **数据一致性**: 保证跨服务数据操作的一致性
- **高性能**: 最小化事务协调开销
- **高可用**: 事务协调器的高可用性
- **易用性**: 简化分布式事务的使用
- **可观测性**: 完整的事务监控和追踪

### 架构图

```
NSRS分布式事务架构：

┌─────────────────────────────────────────────────────────────┐
│                    Seata Server                            │
│              (事务协调器集群)                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   TC-1      │  │    TC-2     │  │    TC-3     │        │
│  │(Transaction │  │(Transaction │  │(Transaction │        │
│  │Coordinator) │  │Coordinator) │  │Coordinator) │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
┌───────▼──────┐ ┌───▼────┐ ┌──────▼──────┐
│ User Service │ │IMSI Svc│ │MSISDN Svc   │
│              │ │        │ │             │
│ ┌─────────┐  │ │┌──────┐│ │ ┌─────────┐ │
│ │   TM    │  │ ││  RM  ││ │ │   RM    │ │
│ │(事务管理)│  │ ││(资源管││ │ │ (资源管 │ │
│ │         │  │ ││理器) ││ │ │  理器)  │ │
│ └─────────┘  │ │└──────┘│ │ └─────────┘ │
│              │ │        │ │             │
│ ┌─────────┐  │ │┌──────┐│ │ ┌─────────┐ │
│ │ MySQL   │  │ ││MySQL ││ │ │ MySQL   │ │
│ │ DB      │  │ ││ DB   ││ │ │ DB      │ │
│ └─────────┘  │ │└──────┘│ │ └─────────┘ │
└──────────────┘ └────────┘ └─────────────┘
       │             │             │
┌──────▼──────┐ ┌───▼────┐ ┌──────▼──────┐
│ SIM Service │ │Bill Svc│ │Report Svc   │
│             │ │        │ │             │
│ ┌─────────┐ │ │┌──────┐│ │ ┌─────────┐ │
│ │   RM    │ │ ││  RM  ││ │ │   RM    │ │
│ │(资源管理)│ │ ││(资源管││ │ │ (资源管 │ │
│ │         │ │ ││理器) ││ │ │  理器)  │ │
│ └─────────┘ │ │└──────┘│ │ └─────────┘ │
│             │ │        │ │             │
│ ┌─────────┐ │ │┌──────┐│ │ ┌─────────┐ │
│ │ MySQL   │ │ ││MySQL ││ │ │ MySQL   │ │
│ │ DB      │ │ ││ DB   ││ │ │ DB      │ │
│ └─────────┘ │ │└──────┘│ │ └─────────┘ │
└─────────────┘ └────────┘ └─────────────┘

TM: Transaction Manager (事务管理器)
TC: Transaction Coordinator (事务协调器)
RM: Resource Manager (资源管理器)
```

## 核心组件设计

### 1. 事务枚举定义

```java
/**
 * 事务状态
 */
public enum TransactionStatus {
    BEGIN("BEGIN", "事务开始"),
    COMMITTING("COMMITTING", "提交中"),
    COMMITTED("COMMITTED", "已提交"),
    ROLLBACKING("ROLLBACKING", "回滚中"),
    ROLLBACKED("ROLLBACKED", "已回滚"),
    TIMEOUT("TIMEOUT", "超时"),
    UNKNOWN("UNKNOWN", "未知状态");
    
    private final String code;
    private final String description;
    
    TransactionStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}

/**
 * 事务模式
 */
public enum TransactionMode {
    AT("AT", "自动事务模式"),
    TCC("TCC", "Try-Confirm-Cancel模式"),
    SAGA("SAGA", "Saga长事务模式"),
    XA("XA", "XA两阶段提交模式");
    
    private final String code;
    private final String description;
    
    TransactionMode(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}

/**
 * 分支事务状态
 */
public enum BranchStatus {
    REGISTERED("REGISTERED", "已注册"),
    PHASE_ONE_DONE("PHASE_ONE_DONE", "一阶段完成"),
    PHASE_ONE_FAILED("PHASE_ONE_FAILED", "一阶段失败"),
    PHASE_ONE_TIMEOUT("PHASE_ONE_TIMEOUT", "一阶段超时"),
    PHASE_TWO_COMMITTED("PHASE_TWO_COMMITTED", "二阶段提交完成"),
    PHASE_TWO_COMMIT_FAILED_RETRYABLE("PHASE_TWO_COMMIT_FAILED_RETRYABLE", "二阶段提交失败可重试"),
    PHASE_TWO_COMMIT_FAILED_UNRETRYABLE("PHASE_TWO_COMMIT_FAILED_UNRETRYABLE", "二阶段提交失败不可重试"),
    PHASE_TWO_ROLLBACKED("PHASE_TWO_ROLLBACKED", "二阶段回滚完成"),
    PHASE_TWO_ROLLBACK_FAILED_RETRYABLE("PHASE_TWO_ROLLBACK_FAILED_RETRYABLE", "二阶段回滚失败可重试"),
    PHASE_TWO_ROLLBACK_FAILED_UNRETRYABLE("PHASE_TWO_ROLLBACK_FAILED_UNRETRYABLE", "二阶段回滚失败不可重试");
    
    private final String code;
    private final String description;
    
    BranchStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

### 2. 事务实体设计

```java
/**
 * 全局事务信息
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class GlobalTransaction {
    
    /**
     * 全局事务ID
     */
    private String xid;
    
    /**
     * 事务名称
     */
    private String transactionName;
    
    /**
     * 事务状态
     */
    private TransactionStatus status;
    
    /**
     * 事务模式
     */
    private TransactionMode mode;
    
    /**
     * 应用ID
     */
    private String applicationId;
    
    /**
     * 事务服务组
     */
    private String transactionServiceGroup;
    
    /**
     * 超时时间(毫秒)
     */
    private Integer timeout;
    
    /**
     * 开始时间
     */
    private LocalDateTime beginTime;
    
    /**
     * 结束时间
     */
    private LocalDateTime endTime;
    
    /**
     * 分支事务列表
     */
    private List<BranchTransaction> branches;
    
    /**
     * 业务数据
     */
    private Map<String, Object> businessData;
}

/**
 * 分支事务信息
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BranchTransaction {
    
    /**
     * 分支事务ID
     */
    private Long branchId;
    
    /**
     * 全局事务ID
     */
    private String xid;
    
    /**
     * 资源ID
     */
    private String resourceId;
    
    /**
     * 分支类型
     */
    private String branchType;
    
    /**
     * 分支状态
     */
    private BranchStatus status;
    
    /**
     * 客户端ID
     */
    private String clientId;
    
    /**
     * 应用数据
     */
    private String applicationData;
    
    /**
     * 注册时间
     */
    private LocalDateTime registerTime;
    
    /**
     * 更新时间
     */
    private LocalDateTime updateTime;
}
```

## Seata集成方案

### 1. Seata Server配置

```yaml
# docker-compose.yml
version: '3.8'
services:
  seata-server-1:
    image: seataio/seata-server:1.6.1
    hostname: seata-server-1
    ports:
      - "8091:8091"
    environment:
      - SEATA_PORT=8091
      - STORE_MODE=db
      - SEATA_CONFIG_NAME=file:/root/seata-config/registry
    volumes:
      - ./seata-config:/root/seata-config
    networks:
      - nsrs-network
    depends_on:
      - mysql
      - nacos

  seata-server-2:
    image: seataio/seata-server:1.6.1
    hostname: seata-server-2
    ports:
      - "8092:8091"
    environment:
      - SEATA_PORT=8091
      - STORE_MODE=db
      - SEATA_CONFIG_NAME=file:/root/seata-config/registry
    volumes:
      - ./seata-config:/root/seata-config
    networks:
      - nsrs-network
    depends_on:
      - mysql
      - nacos

  seata-server-3:
    image: seataio/seata-server:1.6.1
    hostname: seata-server-3
    ports:
      - "8093:8091"
    environment:
      - SEATA_PORT=8091
      - STORE_MODE=db
      - SEATA_CONFIG_NAME=file:/root/seata-config/registry
    volumes:
      - ./seata-config:/root/seata-config
    networks:
      - nsrs-network
    depends_on:
      - mysql
      - nacos

networks:
  nsrs-network:
    driver: bridge
```

### 2. Seata配置文件

```properties
# registry.conf
registry {
  type = "nacos"
  nacos {
    application = "seata-server"
    serverAddr = "nacos-cluster:8848"
    group = "SEATA_GROUP"
    namespace = "seata"
    cluster = "default"
    username = "nacos"
    password = "nacos"
  }
}

config {
  type = "nacos"
  nacos {
    serverAddr = "nacos-cluster:8848"
    namespace = "seata"
    group = "SEATA_GROUP"
    username = "nacos"
    password = "nacos"
    dataId = "seataServer.properties"
  }
}
```

### 3. 应用集成配置

```yaml
# application.yml
seata:
  enabled: true
  application-id: nsrs-imsi-service
  tx-service-group: nsrs-tx-group
  enable-auto-data-source-proxy: true
  data-source-proxy-mode: AT
  use-jdk-proxy: false
  excludes-for-auto-proxying: firstClassNameForExclude,secondClassNameForExclude
  client:
    rm:
      async-commit-buffer-limit: 10000
      report-retry-count: 5
      table-meta-check-enable: false
      report-success-enable: false
      saga-branch-register-enable: false
      saga-json-parser: fastjson
      saga-retry-persist-mode-update: false
      saga-compensate-persist-mode-update: false
      lock:
        retry-interval: 10
        retry-times: 30
        retry-policy-branch-rollback-on-conflict: true
    tm:
      commit-retry-count: 5
      rollback-retry-count: 5
      default-global-transaction-timeout: 60000
      degrade-check: false
      degrade-check-period: 2000
      degrade-check-allow-times: 10
      interceptor-order: -2147482648
    undo:
      data-validation: true
      log-serialization: jackson
      log-table: undo_log
      only-care-update-columns: true
      compress:
        enable: true
        type: zip
        threshold: 64k
    load-balance:
      type: RandomLoadBalance
      virtual-nodes: 10
  service:
    vgroup-mapping:
      nsrs-tx-group: default
    grouplist:
      default: seata-server-1:8091,seata-server-2:8092,seata-server-3:8093
    enable-degrade: false
    disable-global-transaction: false
  transport:
    shutdown:
      wait: 3
    thread-factory:
      boss-thread-prefix: NettyBoss
      worker-thread-prefix: NettyServerNIOWorker
      server-executor-thread-prefix: NettyServerBizHandler
      share-boss-worker: false
      client-selector-thread-prefix: NettyClientSelector
      client-selector-thread-size: 1
      client-worker-thread-prefix: NettyClientWorkerThread
      worker-thread-size: default
      boss-thread-size: 1
    type: TCP
    server: NIO
    heartbeat: true
    serialization: seata
    compressor: none
    enable-client-batch-send-request: true
  config:
    type: nacos
    nacos:
      namespace: seata
      serverAddr: nacos-cluster:8848
      group: SEATA_GROUP
      username: nacos
      password: nacos
      data-id: seataClient.properties
  registry:
    type: nacos
    nacos:
      application: seata-server
      server-addr: nacos-cluster:8848
      group: SEATA_GROUP
      namespace: seata
      username: nacos
      password: nacos
      cluster: default
```

## 事务模式

### 1. AT模式实现

```java
/**
 * AT模式事务服务
 */
@Service
@Slf4j
public class AtTransactionService {
    
    @Autowired
    private ImsiResourceService imsiResourceService;
    
    @Autowired
    private SimCardService simCardService;
    
    @Autowired
    private UserAccountService userAccountService;
    
    @Autowired
    private BillingService billingService;
    
    /**
     * IMSI资源分配事务(AT模式)
     */
    @GlobalTransactional(name = "imsi-allocation-transaction", rollbackFor = Exception.class)
    public ImsiAllocationResult allocateImsiWithAt(ImsiAllocationRequest request) {
        log.info("开始IMSI分配事务(AT模式): {}", request);
        
        try {
            // 1. 分配IMSI资源
            ImsiResource imsiResource = imsiResourceService.allocateImsi(request);
            log.info("IMSI资源分配成功: {}", imsiResource.getImsi());
            
            // 2. 创建SIM卡记录
            SimCard simCard = simCardService.createSimCard(imsiResource, request);
            log.info("SIM卡创建成功: {}", simCard.getIccid());
            
            // 3. 更新用户账户
            userAccountService.updateUserAccount(request.getUserId(), simCard);
            log.info("用户账户更新成功: {}", request.getUserId());
            
            // 4. 创建计费记录
            billingService.createBillingRecord(request.getUserId(), simCard);
            log.info("计费记录创建成功");
            
            return ImsiAllocationResult.builder()
                .success(true)
                .imsi(imsiResource.getImsi())
                .iccid(simCard.getIccid())
                .message("IMSI分配成功")
                .build();
                
        } catch (Exception e) {
            log.error("IMSI分配事务失败: {}", e.getMessage(), e);
            throw e; // 触发全局事务回滚
        }
    }
}
```

### 2. TCC模式实现

```java
/**
 * TCC模式事务服务
 */
@Service
@Slf4j
public class TccTransactionService {
    
    @Autowired
    private ImsiResourceTccService imsiResourceTccService;
    
    @Autowired
    private SimCardTccService simCardTccService;
    
    @Autowired
    private UserAccountTccService userAccountTccService;
    
    /**
     * IMSI资源分配事务(TCC模式)
     */
    @GlobalTransactional(name = "imsi-allocation-tcc-transaction")
    public ImsiAllocationResult allocateImsiWithTcc(ImsiAllocationRequest request) {
        log.info("开始IMSI分配事务(TCC模式): {}", request);
        
        try {
            // Try阶段：预留资源
            boolean imsiReserved = imsiResourceTccService.tryReserveImsi(request);
            if (!imsiReserved) {
                throw new BusinessException("IMSI资源预留失败");
            }
            
            boolean simCardReserved = simCardTccService.tryCreateSimCard(request);
            if (!simCardReserved) {
                throw new BusinessException("SIM卡预留失败");
            }
            
            boolean accountReserved = userAccountTccService.tryUpdateAccount(request);
            if (!accountReserved) {
                throw new BusinessException("账户更新预留失败");
            }
            
            return ImsiAllocationResult.builder()
                .success(true)
                .message("IMSI分配成功(TCC模式)")
                .build();
                
        } catch (Exception e) {
            log.error("IMSI分配TCC事务失败: {}", e.getMessage(), e);
            throw e;
        }
    }
}

/**
 * IMSI资源TCC服务
 */
@LocalTCC
@Service
@Slf4j
public class ImsiResourceTccService {
    
    @Autowired
    private ImsiResourceMapper imsiResourceMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * Try: 预留IMSI资源
     */
    @TwoPhaseBusinessAction(
        name = "imsiResourceTcc",
        commitMethod = "confirmReserveImsi",
        rollbackMethod = "cancelReserveImsi"
    )
    public boolean tryReserveImsi(ImsiAllocationRequest request) {
        log.info("Try: 预留IMSI资源, request: {}", request);
        
        try {
            // 查找可用的IMSI资源
            ImsiResource imsiResource = imsiResourceMapper.findAvailableImsi(
                request.getOperatorId(), request.getRegion());
            
            if (imsiResource == null) {
                log.warn("没有可用的IMSI资源");
                return false;
            }
            
            // 在Redis中预留资源
            String reserveKey = "imsi:reserve:" + imsiResource.getImsi();
            String reserveValue = request.getRequestId();
            
            Boolean reserved = redisTemplate.opsForValue()
                .setIfAbsent(reserveKey, reserveValue, Duration.ofMinutes(5));
            
            if (Boolean.TRUE.equals(reserved)) {
                log.info("IMSI资源预留成功: {}", imsiResource.getImsi());
                return true;
            } else {
                log.warn("IMSI资源预留失败，资源已被占用: {}", imsiResource.getImsi());
                return false;
            }
            
        } catch (Exception e) {
            log.error("IMSI资源预留异常: {}", e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Confirm: 确认预留的IMSI资源
     */
    public boolean confirmReserveImsi(ImsiAllocationRequest request) {
        log.info("Confirm: 确认IMSI资源预留, request: {}", request);
        
        try {
            // 从Redis获取预留的资源
            String pattern = "imsi:reserve:*";
            Set<String> keys = redisTemplate.keys(pattern);
            
            for (String key : keys) {
                String reserveValue = (String) redisTemplate.opsForValue().get(key);
                if (request.getRequestId().equals(reserveValue)) {
                    String imsi = key.substring("imsi:reserve:".length());
                    
                    // 更新数据库中的IMSI状态
                    int updated = imsiResourceMapper.allocateImsi(imsi, request.getUserId());
                    
                    if (updated > 0) {
                        // 删除预留记录
                        redisTemplate.delete(key);
                        log.info("IMSI资源分配确认成功: {}", imsi);
                        return true;
                    }
                }
            }
            
            log.warn("未找到对应的IMSI预留记录: {}", request.getRequestId());
            return false;
            
        } catch (Exception e) {
            log.error("IMSI资源确认异常: {}", e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Cancel: 取消预留的IMSI资源
     */
    public boolean cancelReserveImsi(ImsiAllocationRequest request) {
        log.info("Cancel: 取消IMSI资源预留, request: {}", request);
        
        try {
            // 删除Redis中的预留记录
            String pattern = "imsi:reserve:*";
            Set<String> keys = redisTemplate.keys(pattern);
            
            for (String key : keys) {
                String reserveValue = (String) redisTemplate.opsForValue().get(key);
                if (request.getRequestId().equals(reserveValue)) {
                    redisTemplate.delete(key);
                    log.info("IMSI资源预留取消成功: {}", key);
                    return true;
                }
            }
            
            log.info("未找到对应的IMSI预留记录，可能已被处理: {}", request.getRequestId());
            return true;
            
        } catch (Exception e) {
            log.error("IMSI资源取消异常: {}", e.getMessage(), e);
            return false;
        }
    }
}
```

### 3. Saga模式实现

```java
/**
 * Saga模式事务服务
 */
@Service
@Slf4j
public class SagaTransactionService {
    
    @Autowired
    private SagaManager sagaManager;
    
    /**
     * IMSI资源分配事务(Saga模式)
     */
    public ImsiAllocationResult allocateImsiWithSaga(ImsiAllocationRequest request) {
        log.info("开始IMSI分配事务(Saga模式): {}", request);
        
        // 构建Saga事务定义
        String sagaJson = buildImsiAllocationSaga(request);
        
        try {
            // 启动Saga事务
            String sagaTransId = sagaManager.startSaga(sagaJson);
            log.info("Saga事务启动成功: {}", sagaTransId);
            
            return ImsiAllocationResult.builder()
                .success(true)
                .transactionId(sagaTransId)
                .message("IMSI分配Saga事务启动成功")
                .build();
                
        } catch (Exception e) {
            log.error("Saga事务启动失败: {}", e.getMessage(), e);
            throw new BusinessException("IMSI分配失败", e);
        }
    }
    
    private String buildImsiAllocationSaga(ImsiAllocationRequest request) {
        // Saga事务定义JSON
        return "{"
            + "\"requestId\": \"" + request.getRequestId() + "\","
            + "\"startState\": \"AllocateImsi\","
            + "\"stateMachine\": {"
            + "  \"AllocateImsi\": {"
            + "    \"serviceTask\": {"
            + "      \"serviceName\": \"imsiResourceService\","
            + "      \"serviceMethod\": \"allocateImsi\","
            + "      \"compensateMethod\": \"releaseImsi\""
            + "    },"
            + "    \"next\": \"CreateSimCard\""
            + "  },"
            + "  \"CreateSimCard\": {"
            + "    \"serviceTask\": {"
            + "      \"serviceName\": \"simCardService\","
            + "      \"serviceMethod\": \"createSimCard\","
            + "      \"compensateMethod\": \"deleteSimCard\""
            + "    },"
            + "    \"next\": \"UpdateAccount\""
            + "  },"
            + "  \"UpdateAccount\": {"
            + "    \"serviceTask\": {"
            + "      \"serviceName\": \"userAccountService\","
            + "      \"serviceMethod\": \"updateUserAccount\","
            + "      \"compensateMethod\": \"revertUserAccount\""
            + "    },"
            + "    \"next\": \"CreateBilling\""
            + "  },"
            + "  \"CreateBilling\": {"
            + "    \"serviceTask\": {"
            + "      \"serviceName\": \"billingService\","
            + "      \"serviceMethod\": \"createBillingRecord\","
            + "      \"compensateMethod\": \"deleteBillingRecord\""
            + "    },"
            + "    \"isEnd\": true"
            + "  }"
            + "}"
            + "}";
    }
}
```

## 业务场景应用

### 1. 分布式事务控制器

```java
/**
 * 分布式事务管理控制器
 */
@RestController
@RequestMapping("/api/v1/transaction")
@Slf4j
public class DistributedTransactionController {
    
    @Autowired
    private AtTransactionService atTransactionService;
    
    @Autowired
    private TccTransactionService tccTransactionService;
    
    @Autowired
    private SagaTransactionService sagaTransactionService;
    
    @Autowired
    private TransactionMonitorService transactionMonitorService;
    
    /**
     * AT模式IMSI分配
     */
    @PostMapping("/imsi/allocate/at")
    public Result<ImsiAllocationResult> allocateImsiWithAt(
            @RequestBody @Valid ImsiAllocationRequest request) {
        
        ImsiAllocationResult result = atTransactionService.allocateImsiWithAt(request);
        return Result.success(result);
    }
    
    /**
     * TCC模式IMSI分配
     */
    @PostMapping("/imsi/allocate/tcc")
    public Result<ImsiAllocationResult> allocateImsiWithTcc(
            @RequestBody @Valid ImsiAllocationRequest request) {
        
        ImsiAllocationResult result = tccTransactionService.allocateImsiWithTcc(request);
        return Result.success(result);
    }
    
    /**
     * Saga模式IMSI分配
     */
    @PostMapping("/imsi/allocate/saga")
    public Result<ImsiAllocationResult> allocateImsiWithSaga(
            @RequestBody @Valid ImsiAllocationRequest request) {
        
        ImsiAllocationResult result = sagaTransactionService.allocateImsiWithSaga(request);
        return Result.success(result);
    }
    
    /**
     * 查询事务状态
     */
    @GetMapping("/status/{xid}")
    public Result<GlobalTransaction> getTransactionStatus(@PathVariable String xid) {
        GlobalTransaction transaction = transactionMonitorService.getTransactionStatus(xid);
        return Result.success(transaction);
    }
    
    /**
     * 获取事务统计信息
     */
    @GetMapping("/statistics")
    public Result<TransactionStatistics> getTransactionStatistics(
            @RequestParam(defaultValue = "1") Integer days) {
        
        TransactionStatistics statistics = transactionMonitorService
            .getTransactionStatistics(days);
        return Result.success(statistics);
    }
    
    /**
     * 手动回滚事务
     */
    @PostMapping("/rollback/{xid}")
    public Result<Void> rollbackTransaction(@PathVariable String xid) {
        transactionMonitorService.rollbackTransaction(xid);
        return Result.success();
    }
}
```

### 2. 事务监控服务

```java
/**
 * 事务监控服务
 */
@Service
@Slf4j
public class TransactionMonitorService {
    
    @Autowired
    private GlobalTransactionMapper globalTransactionMapper;
    
    @Autowired
    private BranchTransactionMapper branchTransactionMapper;
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    private final Counter transactionCounter;
    private final Timer transactionTimer;
    
    public TransactionMonitorService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.transactionCounter = Counter.builder("distributed_transaction_total")
            .description("分布式事务总数")
            .register(meterRegistry);
        this.transactionTimer = Timer.builder("distributed_transaction_duration")
            .description("分布式事务耗时")
            .register(meterRegistry);
    }
    
    /**
     * 获取事务状态
     */
    public GlobalTransaction getTransactionStatus(String xid) {
        GlobalTransaction transaction = globalTransactionMapper.selectByXid(xid);
        
        if (transaction != null) {
            List<BranchTransaction> branches = branchTransactionMapper.selectByXid(xid);
            transaction.setBranches(branches);
        }
        
        return transaction;
    }
    
    /**
     * 记录事务指标
     */
    public void recordTransactionMetrics(String xid, TransactionStatus status, 
                                       long duration) {
        transactionCounter.increment(
            Tags.of(
                "status", status.getCode(),
                "xid", xid
            )
        );
        
        transactionTimer.record(duration, TimeUnit.MILLISECONDS,
            Tags.of("status", status.getCode()));
    }
    
    /**
     * 获取事务统计信息
     */
    public TransactionStatistics getTransactionStatistics(Integer days) {
        LocalDateTime startTime = LocalDateTime.now().minusDays(days);
        
        // 统计各状态事务数量
        Map<TransactionStatus, Long> statusCount = globalTransactionMapper
            .countByStatusAndTime(startTime);
        
        // 统计平均耗时
        Double avgDuration = globalTransactionMapper.avgDurationByTime(startTime);
        
        // 统计成功率
        Long totalCount = statusCount.values().stream().mapToLong(Long::longValue).sum();
        Long successCount = statusCount.getOrDefault(TransactionStatus.COMMITTED, 0L);
        Double successRate = totalCount > 0 ? (double) successCount / totalCount * 100 : 0.0;
        
        return TransactionStatistics.builder()
            .totalCount(totalCount)
            .successCount(successCount)
            .failedCount(statusCount.getOrDefault(TransactionStatus.ROLLBACKED, 0L))
            .timeoutCount(statusCount.getOrDefault(TransactionStatus.TIMEOUT, 0L))
            .avgDuration(avgDuration)
            .successRate(successRate)
            .statisticsPeriod(days)
            .build();
    }
    
    /**
     * 手动回滚事务
     */
    public void rollbackTransaction(String xid) {
        try {
            GlobalTransactionContext.reload(xid).rollback();
            log.info("手动回滚事务成功: {}", xid);
        } catch (Exception e) {
            log.error("手动回滚事务失败: {}, error: {}", xid, e.getMessage(), e);
            throw new BusinessException("事务回滚失败", e);
        }
    }
}
```

## 性能优化

### 1. 事务优化配置

```java
/**
 * 事务性能优化配置
 */
@Configuration
@Slf4j
public class TransactionOptimizationConfig {
    
    /**
     * 自定义数据源代理
     */
    @Bean
    @Primary
    public DataSource dataSource(@Qualifier("actualDataSource") DataSource actualDataSource) {
        return new DataSourceProxy(actualDataSource);
    }
    
    /**
     * 事务模板配置
     */
    @Bean
    public TransactionTemplate transactionTemplate(PlatformTransactionManager transactionManager) {
        TransactionTemplate template = new TransactionTemplate(transactionManager);
        template.setTimeout(30); // 30秒超时
        template.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        template.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        return template;
    }
    
    /**
     * 异步事务处理器
     */
    @Bean
    public AsyncTransactionProcessor asyncTransactionProcessor() {
        return new AsyncTransactionProcessor();
    }
}

/**
 * 异步事务处理器
 */
@Component
@Slf4j
public class AsyncTransactionProcessor {
    
    @Autowired
    private ThreadPoolTaskExecutor taskExecutor;
    
    /**
     * 异步处理事务后续操作
     */
    @Async
    public CompletableFuture<Void> processTransactionAsync(String xid, 
                                                          TransactionStatus status) {
        return CompletableFuture.runAsync(() -> {
            try {
                // 异步处理事务相关的后续操作
                if (status == TransactionStatus.COMMITTED) {
                    processCommittedTransaction(xid);
                } else if (status == TransactionStatus.ROLLBACKED) {
                    processRollbackedTransaction(xid);
                }
            } catch (Exception e) {
                log.error("异步处理事务失败: xid={}, status={}, error={}", 
                    xid, status, e.getMessage(), e);
            }
        }, taskExecutor);
    }
    
    private void processCommittedTransaction(String xid) {
        // 处理事务提交后的操作
        log.info("处理已提交事务: {}", xid);
        // 发送成功通知、更新缓存、记录审计日志等
    }
    
    private void processRollbackedTransaction(String xid) {
        // 处理事务回滚后的操作
        log.info("处理已回滚事务: {}", xid);
        // 发送失败通知、清理缓存、记录错误日志等
    }
}
```

### 2. 事务监控告警

```yaml
# Prometheus告警规则
groups:
  - name: seata-transaction-alerts
    rules:
      - alert: HighTransactionFailureRate
        expr: |
          (
            sum(rate(distributed_transaction_total{status="ROLLBACKED"}[5m])) /
            sum(rate(distributed_transaction_total[5m]))
          ) * 100 > 10
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "分布式事务失败率过高"
          description: "分布式事务失败率超过10%，当前值: {{ $value }}%"
      
      - alert: TransactionTimeoutAlert
        expr: |
          sum(rate(distributed_transaction_total{status="TIMEOUT"}[5m])) > 0.1
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "分布式事务超时告警"
          description: "检测到分布式事务超时，超时率: {{ $value }}/秒"
      
      - alert: LongRunningTransaction
        expr: |
          histogram_quantile(0.95, 
            sum(rate(distributed_transaction_duration_bucket[5m])) by (le)
          ) > 30000
        for: 3m
        labels:
          severity: warning
        annotations:
          summary: "分布式事务耗时过长"
          description: "95%的分布式事务耗时超过30秒，当前P95: {{ $value }}ms"
```

## 最佳实践

### 1. 事务设计原则

- **最小化事务范围**: 只在必要时使用分布式事务
- **幂等性设计**: 确保所有操作都是幂等的
- **补偿机制**: 为每个操作设计对应的补偿操作
- **超时控制**: 设置合理的事务超时时间

### 2. 性能优化

- **批量操作**: 减少网络交互次数
- **异步处理**: 非关键操作异步执行
- **缓存优化**: 合理使用缓存减少数据库访问
- **连接池优化**: 优化数据库连接池配置

### 3. 监控运维

- **全链路监控**: 监控事务的完整生命周期
- **性能指标**: 关注事务成功率、耗时、吞吐量
- **告警机制**: 及时发现和处理事务异常
- **日志审计**: 完整记录事务操作日志

通过以上分布式事务架构设计，NSRS系统实现了跨服务的数据一致性保障，支持多种事务模式，满足不同业务场景的需求。