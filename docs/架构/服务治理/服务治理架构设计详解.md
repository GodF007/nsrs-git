# 服务治理架构设计详解

基于Spring Cloud Alibaba的NSRS号卡资源管理系统服务治理解决方案

## 目录

- [服务治理概述](#服务治理概述)
- [核心组件设计](#核心组件设计)
- [服务注册发现](#服务注册发现)
- [负载均衡](#负载均衡)
- [熔断降级](#熔断降级)
- [限流控制](#限流控制)
- [服务监控](#服务监控)
- [最佳实践](#最佳实践)

## 服务治理概述

### 设计目标

- **服务发现**: 自动化服务注册与发现机制
- **负载均衡**: 智能流量分发和负载均衡
- **故障隔离**: 熔断降级保护系统稳定性
- **流量控制**: 限流防护避免系统过载
- **监控告警**: 全面的服务健康监控

### 架构图

```
NSRS服务治理架构：

┌─────────────────────────────────────────────────────────────┐
│                    服务治理控制台                            │
│              (Nacos Console)                               │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────────┐
│                  服务注册中心                                │
│                 (Nacos Server)                             │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
┌───────▼──────┐ ┌───▼────┐ ┌──────▼──────┐
│ User Service │ │IMSI Svc│ │MSISDN Svc   │
│              │ │        │ │             │
│ ┌─────────┐  │ │┌──────┐│ │ ┌─────────┐ │
│ │Sentinel │  │ ││Sentinl││ │ │Sentinel │ │
│ │ 限流熔断 │  │ ││限流熔断││ │ │ 限流熔断 │ │
│ └─────────┘  │ │└──────┘│ │ └─────────┘ │
└──────┬───────┘ └───┬────┘ └──────┬──────┘
       │             │             │
┌──────▼──────┐ ┌───▼────┐ ┌──────▼──────┐
│ SIM Service │ │Bill Svc│ │Report Svc   │
│             │ │        │ │             │
│ ┌─────────┐ │ │┌──────┐│ │ ┌─────────┐ │
│ │Sentinel │ │ ││Sentinl││ │ │Sentinel │ │
│ │ 限流熔断 │ │ ││限流熔断││ │ │ 限流熔断 │ │
│ └─────────┘ │ │└──────┘│ │ └─────────┘ │
└─────────────┘ └────────┘ └─────────────┘
       │             │             │
┌──────▼─────────────▼─────────────▼──────┐
│              Sentinel Dashboard          │
│            (流量控制监控台)               │
└─────────────────────────────────────────┘
```

## 核心组件设计

### 1. 服务治理枚举

```java
/**
 * 服务状态
 */
public enum ServiceStatus {
    UP("UP", "服务正常"),
    DOWN("DOWN", "服务下线"),
    OUT_OF_SERVICE("OUT_OF_SERVICE", "服务停止"),
    UNKNOWN("UNKNOWN", "状态未知");
    
    private final String code;
    private final String description;
    
    ServiceStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}

/**
 * 负载均衡策略
 */
public enum LoadBalanceStrategy {
    ROUND_ROBIN("ROUND_ROBIN", "轮询"),
    RANDOM("RANDOM", "随机"),
    WEIGHTED_RANDOM("WEIGHTED_RANDOM", "加权随机"),
    LEAST_ACTIVE("LEAST_ACTIVE", "最少活跃"),
    CONSISTENT_HASH("CONSISTENT_HASH", "一致性哈希");
    
    private final String code;
    private final String description;
    
    LoadBalanceStrategy(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}

/**
 * 熔断状态
 */
public enum CircuitBreakerState {
    CLOSED("CLOSED", "关闭"),
    OPEN("OPEN", "开启"),
    HALF_OPEN("HALF_OPEN", "半开");
    
    private final String code;
    private final String description;
    
    CircuitBreakerState(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

### 2. 服务实例实体

```java
/**
 * 服务实例信息
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServiceInstance {
    
    /**
     * 服务名称
     */
    private String serviceName;
    
    /**
     * 实例ID
     */
    private String instanceId;
    
    /**
     * 主机地址
     */
    private String host;
    
    /**
     * 端口号
     */
    private Integer port;
    
    /**
     * 服务状态
     */
    private ServiceStatus status;
    
    /**
     * 权重
     */
    private Double weight;
    
    /**
     * 是否健康
     */
    private Boolean healthy;
    
    /**
     * 是否启用
     */
    private Boolean enabled;
    
    /**
     * 元数据
     */
    private Map<String, String> metadata;
    
    /**
     * 集群名称
     */
    private String clusterName;
    
    /**
     * 注册时间
     */
    private LocalDateTime registerTime;
    
    /**
     * 最后心跳时间
     */
    private LocalDateTime lastHeartbeat;
}

/**
 * 服务治理配置
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServiceGovernanceConfig {
    
    /**
     * 服务名称
     */
    private String serviceName;
    
    /**
     * 负载均衡策略
     */
    private LoadBalanceStrategy loadBalanceStrategy;
    
    /**
     * 熔断配置
     */
    private CircuitBreakerConfig circuitBreakerConfig;
    
    /**
     * 限流配置
     */
    private RateLimitConfig rateLimitConfig;
    
    /**
     * 重试配置
     */
    private RetryConfig retryConfig;
    
    /**
     * 超时配置
     */
    private TimeoutConfig timeoutConfig;
    
    /**
     * 是否启用
     */
    private Boolean enabled;
    
    /**
     * 创建时间
     */
    private LocalDateTime createTime;
    
    /**
     * 更新时间
     */
    private LocalDateTime updateTime;
}
```

## 服务注册发现

### 1. 服务注册配置

```yaml
# application.yml
spring:
  application:
    name: nsrs-imsi-service
  cloud:
    nacos:
      discovery:
        server-addr: nacos-cluster:8848
        namespace: nsrs-prod
        group: NSRS_GROUP
        cluster-name: beijing
        metadata:
          version: 1.0.0
          region: beijing
          zone: zone-a
          weight: 100
        heart-beat-interval: 5000
        heart-beat-timeout: 15000
        ip-delete-timeout: 30000
        instance-enabled: true
        ephemeral: true
        secure: false
```

### 2. 服务发现客户端

```java
/**
 * 服务发现客户端
 */
@Component
@Slf4j
public class ServiceDiscoveryClient {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @Autowired
    private NacosDiscoveryProperties nacosDiscoveryProperties;
    
    /**
     * 获取服务实例列表
     */
    public List<ServiceInstance> getServiceInstances(String serviceName) {
        List<org.springframework.cloud.client.ServiceInstance> instances = 
            discoveryClient.getInstances(serviceName);
        
        return instances.stream()
            .map(this::convertToServiceInstance)
            .collect(Collectors.toList());
    }
    
    /**
     * 获取健康的服务实例
     */
    public List<ServiceInstance> getHealthyInstances(String serviceName) {
        return getServiceInstances(serviceName).stream()
            .filter(ServiceInstance::getHealthy)
            .filter(ServiceInstance::getEnabled)
            .collect(Collectors.toList());
    }
    
    /**
     * 根据负载均衡策略选择实例
     */
    public ServiceInstance selectInstance(String serviceName, 
                                        LoadBalanceStrategy strategy) {
        List<ServiceInstance> instances = getHealthyInstances(serviceName);
        
        if (instances.isEmpty()) {
            throw new ServiceUnavailableException("No available instances for service: " + serviceName);
        }
        
        return selectByStrategy(instances, strategy);
    }
    
    private ServiceInstance selectByStrategy(List<ServiceInstance> instances, 
                                           LoadBalanceStrategy strategy) {
        switch (strategy) {
            case ROUND_ROBIN:
                return selectByRoundRobin(instances);
            case RANDOM:
                return selectByRandom(instances);
            case WEIGHTED_RANDOM:
                return selectByWeightedRandom(instances);
            case LEAST_ACTIVE:
                return selectByLeastActive(instances);
            case CONSISTENT_HASH:
                return selectByConsistentHash(instances);
            default:
                return selectByRoundRobin(instances);
        }
    }
    
    private ServiceInstance selectByRoundRobin(List<ServiceInstance> instances) {
        // 轮询算法实现
        int index = RoundRobinCounter.getAndIncrement() % instances.size();
        return instances.get(index);
    }
    
    private ServiceInstance selectByRandom(List<ServiceInstance> instances) {
        // 随机算法实现
        Random random = new Random();
        return instances.get(random.nextInt(instances.size()));
    }
    
    private ServiceInstance selectByWeightedRandom(List<ServiceInstance> instances) {
        // 加权随机算法实现
        double totalWeight = instances.stream()
            .mapToDouble(ServiceInstance::getWeight)
            .sum();
        
        double randomWeight = Math.random() * totalWeight;
        double currentWeight = 0;
        
        for (ServiceInstance instance : instances) {
            currentWeight += instance.getWeight();
            if (randomWeight <= currentWeight) {
                return instance;
            }
        }
        
        return instances.get(0);
    }
    
    private ServiceInstance selectByLeastActive(List<ServiceInstance> instances) {
        // 最少活跃算法实现
        return instances.stream()
            .min(Comparator.comparing(this::getActiveCount))
            .orElse(instances.get(0));
    }
    
    private ServiceInstance selectByConsistentHash(List<ServiceInstance> instances) {
        // 一致性哈希算法实现
        String key = getCurrentRequestKey();
        return ConsistentHashSelector.select(instances, key);
    }
    
    private ServiceInstance convertToServiceInstance(
            org.springframework.cloud.client.ServiceInstance instance) {
        return ServiceInstance.builder()
            .serviceName(instance.getServiceId())
            .instanceId(instance.getInstanceId())
            .host(instance.getHost())
            .port(instance.getPort())
            .metadata(instance.getMetadata())
            .healthy(true)
            .enabled(true)
            .weight(getWeight(instance.getMetadata()))
            .build();
    }
    
    private Double getWeight(Map<String, String> metadata) {
        String weight = metadata.get("weight");
        return weight != null ? Double.parseDouble(weight) : 1.0;
    }
    
    private int getActiveCount(ServiceInstance instance) {
        // 获取实例活跃连接数
        return ActiveCountManager.getActiveCount(instance.getInstanceId());
    }
    
    private String getCurrentRequestKey() {
        // 获取当前请求的哈希键
        return RequestContextHolder.getRequestId();
    }
}
```

## 负载均衡

### 1. 自定义负载均衡器

```java
/**
 * 自定义负载均衡器
 */
@Component
public class CustomLoadBalancer implements ReactorServiceInstanceLoadBalancer {
    
    @Autowired
    private ServiceDiscoveryClient serviceDiscoveryClient;
    
    @Autowired
    private ServiceGovernanceConfigService configService;
    
    private final String serviceId;
    
    public CustomLoadBalancer(String serviceId) {
        this.serviceId = serviceId;
    }
    
    @Override
    public Mono<Response<org.springframework.cloud.client.ServiceInstance>> choose(Request request) {
        return Mono.fromCallable(() -> {
            // 获取服务治理配置
            ServiceGovernanceConfig config = configService.getConfig(serviceId);
            LoadBalanceStrategy strategy = config != null ? 
                config.getLoadBalanceStrategy() : LoadBalanceStrategy.ROUND_ROBIN;
            
            // 选择服务实例
            ServiceInstance instance = serviceDiscoveryClient
                .selectInstance(serviceId, strategy);
            
            if (instance == null) {
                return new EmptyResponse();
            }
            
            // 转换为Spring Cloud ServiceInstance
            org.springframework.cloud.client.ServiceInstance serviceInstance = 
                convertToSpringCloudInstance(instance);
            
            return new DefaultResponse(serviceInstance);
        });
    }
    
    private org.springframework.cloud.client.ServiceInstance convertToSpringCloudInstance(
            ServiceInstance instance) {
        return new DefaultServiceInstance(
            instance.getInstanceId(),
            instance.getServiceName(),
            instance.getHost(),
            instance.getPort(),
            false,
            instance.getMetadata()
        );
    }
}

/**
 * 负载均衡配置
 */
@Configuration
public class LoadBalancerConfiguration {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    @Bean
    public ReactorLoadBalancer<org.springframework.cloud.client.ServiceInstance> 
            customLoadBalancer(Environment environment) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        return new CustomLoadBalancer(name);
    }
}
```

## 熔断降级

### 1. Sentinel熔断配置

```java
/**
 * Sentinel熔断配置
 */
@Configuration
public class SentinelConfiguration {
    
    @PostConstruct
    public void initFlowRules() {
        // 限流规则
        List<FlowRule> flowRules = new ArrayList<>();
        
        FlowRule flowRule = new FlowRule();
        flowRule.setResource("nsrs-imsi-service");
        flowRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        flowRule.setCount(100); // QPS限制为100
        flowRule.setStrategy(RuleConstant.STRATEGY_DIRECT);
        flowRule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);
        flowRules.add(flowRule);
        
        FlowRuleManager.loadRules(flowRules);
    }
    
    @PostConstruct
    public void initDegradeRules() {
        // 熔断规则
        List<DegradeRule> degradeRules = new ArrayList<>();
        
        DegradeRule degradeRule = new DegradeRule();
        degradeRule.setResource("nsrs-imsi-service");
        degradeRule.setGrade(RuleConstant.DEGRADE_GRADE_RT);
        degradeRule.setCount(1000); // 平均响应时间超过1000ms
        degradeRule.setTimeWindow(10); // 熔断时长10秒
        degradeRule.setMinRequestAmount(5); // 最小请求数
        degradeRules.add(degradeRule);
        
        DegradeRuleManager.loadRules(degradeRules);
    }
}

/**
 * 熔断降级服务
 */
@Service
@Slf4j
public class CircuitBreakerService {
    
    /**
     * IMSI分配服务熔断
     */
    @SentinelResource(
        value = "allocateImsi",
        fallback = "allocateImsiFallback",
        blockHandler = "allocateImsiBlockHandler"
    )
    public ImsiAllocationResult allocateImsi(ImsiAllocationRequest request) {
        // 正常业务逻辑
        return imsiAllocationService.allocateImsi(request);
    }
    
    /**
     * 降级处理
     */
    public ImsiAllocationResult allocateImsiFallback(ImsiAllocationRequest request, 
                                                   Throwable throwable) {
        log.warn("IMSI分配服务降级, request: {}, error: {}", request, throwable.getMessage());
        
        return ImsiAllocationResult.builder()
            .success(false)
            .errorCode("SERVICE_DEGRADED")
            .errorMessage("服务暂时不可用，请稍后重试")
            .build();
    }
    
    /**
     * 限流处理
     */
    public ImsiAllocationResult allocateImsiBlockHandler(ImsiAllocationRequest request, 
                                                       BlockException blockException) {
        log.warn("IMSI分配服务限流, request: {}, block: {}", request, blockException.getMessage());
        
        return ImsiAllocationResult.builder()
            .success(false)
            .errorCode("RATE_LIMITED")
            .errorMessage("请求过于频繁，请稍后重试")
            .build();
    }
}
```

## 限流控制

### 1. 自定义限流器

```java
/**
 * 自定义限流器
 */
@Component
@Slf4j
public class CustomRateLimiter {
    
    private final Map<String, RateLimiter> rateLimiters = new ConcurrentHashMap<>();
    
    @Autowired
    private ServiceGovernanceConfigService configService;
    
    /**
     * 检查是否允许请求
     */
    public boolean tryAcquire(String serviceName, String operation) {
        String key = serviceName + ":" + operation;
        RateLimiter rateLimiter = getRateLimiter(key, serviceName);
        
        boolean acquired = rateLimiter.tryAcquire();
        
        if (!acquired) {
            log.warn("请求被限流: service={}, operation={}", serviceName, operation);
        }
        
        return acquired;
    }
    
    /**
     * 获取限流器
     */
    private RateLimiter getRateLimiter(String key, String serviceName) {
        return rateLimiters.computeIfAbsent(key, k -> {
            ServiceGovernanceConfig config = configService.getConfig(serviceName);
            RateLimitConfig rateLimitConfig = config != null ? 
                config.getRateLimitConfig() : getDefaultRateLimitConfig();
            
            return RateLimiter.create(rateLimitConfig.getPermitsPerSecond());
        });
    }
    
    private RateLimitConfig getDefaultRateLimitConfig() {
        return RateLimitConfig.builder()
            .permitsPerSecond(100.0)
            .build();
    }
    
    /**
     * 更新限流配置
     */
    public void updateRateLimit(String serviceName, String operation, double permitsPerSecond) {
        String key = serviceName + ":" + operation;
        RateLimiter rateLimiter = rateLimiters.get(key);
        
        if (rateLimiter != null) {
            rateLimiter.setRate(permitsPerSecond);
            log.info("更新限流配置: key={}, rate={}", key, permitsPerSecond);
        }
    }
}

/**
 * 限流切面
 */
@Aspect
@Component
@Slf4j
public class RateLimitAspect {
    
    @Autowired
    private CustomRateLimiter rateLimiter;
    
    @Around("@annotation(rateLimit)")
    public Object rateLimit(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        String serviceName = rateLimit.serviceName();
        String operation = rateLimit.operation();
        
        if (!rateLimiter.tryAcquire(serviceName, operation)) {
            throw new RateLimitException("请求过于频繁，请稍后重试");
        }
        
        return joinPoint.proceed();
    }
}

/**
 * 限流注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    String serviceName();
    String operation();
}
```

## 服务监控

### 1. 服务健康检查

```java
/**
 * 服务健康检查
 */
@Component
@Slf4j
public class ServiceHealthChecker {
    
    @Autowired
    private ServiceDiscoveryClient serviceDiscoveryClient;
    
    @Autowired
    private RestTemplate restTemplate;
    
    /**
     * 检查服务健康状态
     */
    @Scheduled(fixedDelay = 30000) // 每30秒检查一次
    public void checkServiceHealth() {
        List<String> services = serviceDiscoveryClient.getServices();
        
        for (String serviceName : services) {
            checkServiceHealth(serviceName);
        }
    }
    
    private void checkServiceHealth(String serviceName) {
        List<ServiceInstance> instances = serviceDiscoveryClient
            .getServiceInstances(serviceName);
        
        for (ServiceInstance instance : instances) {
            boolean healthy = performHealthCheck(instance);
            
            if (!healthy && instance.getHealthy()) {
                log.warn("服务实例不健康: {}:{}", instance.getHost(), instance.getPort());
                // 标记实例为不健康
                markInstanceUnhealthy(instance);
            } else if (healthy && !instance.getHealthy()) {
                log.info("服务实例恢复健康: {}:{}", instance.getHost(), instance.getPort());
                // 标记实例为健康
                markInstanceHealthy(instance);
            }
        }
    }
    
    private boolean performHealthCheck(ServiceInstance instance) {
        try {
            String healthUrl = String.format("http://%s:%d/actuator/health", 
                instance.getHost(), instance.getPort());
            
            ResponseEntity<Map> response = restTemplate.getForEntity(healthUrl, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                Map<String, Object> body = response.getBody();
                return "UP".equals(body.get("status"));
            }
            
            return false;
            
        } catch (Exception e) {
            log.debug("健康检查失败: {}:{}, error: {}", 
                instance.getHost(), instance.getPort(), e.getMessage());
            return false;
        }
    }
    
    private void markInstanceUnhealthy(ServiceInstance instance) {
        // 更新实例健康状态
        instance.setHealthy(false);
        // 发送告警通知
        sendHealthAlert(instance, false);
    }
    
    private void markInstanceHealthy(ServiceInstance instance) {
        // 更新实例健康状态
        instance.setHealthy(true);
        // 发送恢复通知
        sendHealthAlert(instance, true);
    }
    
    private void sendHealthAlert(ServiceInstance instance, boolean healthy) {
        // 发送告警或恢复通知
        String message = String.format("服务实例 %s:%d %s", 
            instance.getHost(), instance.getPort(), 
            healthy ? "恢复健康" : "变为不健康");
        
        log.info(message);
        // 这里可以集成告警系统
    }
}

/**
 * 服务监控指标
 */
@Component
@Slf4j
public class ServiceMetricsCollector {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    private final Gauge serviceInstanceCount;
    private final Counter serviceCallCount;
    private final Timer serviceCallDuration;
    
    public ServiceMetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.serviceInstanceCount = Gauge.builder("service_instance_count")
            .description("服务实例数量")
            .register(meterRegistry, this, ServiceMetricsCollector::getInstanceCount);
        this.serviceCallCount = Counter.builder("service_call_total")
            .description("服务调用总数")
            .register(meterRegistry);
        this.serviceCallDuration = Timer.builder("service_call_duration")
            .description("服务调用耗时")
            .register(meterRegistry);
    }
    
    /**
     * 记录服务调用
     */
    public void recordServiceCall(String serviceName, String operation, 
                                long duration, boolean success) {
        serviceCallCount.increment(
            Tags.of(
                "service", serviceName,
                "operation", operation,
                "success", String.valueOf(success)
            )
        );
        
        serviceCallDuration.record(duration, TimeUnit.MILLISECONDS,
            Tags.of(
                "service", serviceName,
                "operation", operation
            ));
    }
    
    private double getInstanceCount() {
        // 获取当前服务实例总数
        return ServiceInstanceManager.getTotalInstanceCount();
    }
}
```

### 2. 服务治理控制器

```java
/**
 * 服务治理管理控制器
 */
@RestController
@RequestMapping("/api/v1/governance")
@Slf4j
public class ServiceGovernanceController {
    
    @Autowired
    private ServiceDiscoveryClient serviceDiscoveryClient;
    
    @Autowired
    private ServiceGovernanceConfigService configService;
    
    @Autowired
    private CustomRateLimiter rateLimiter;
    
    /**
     * 获取所有服务列表
     */
    @GetMapping("/services")
    public Result<List<String>> getServices() {
        List<String> services = serviceDiscoveryClient.getServices();
        return Result.success(services);
    }
    
    /**
     * 获取服务实例列表
     */
    @GetMapping("/services/{serviceName}/instances")
    public Result<List<ServiceInstance>> getServiceInstances(@PathVariable String serviceName) {
        List<ServiceInstance> instances = serviceDiscoveryClient
            .getServiceInstances(serviceName);
        return Result.success(instances);
    }
    
    /**
     * 获取服务治理配置
     */
    @GetMapping("/services/{serviceName}/config")
    public Result<ServiceGovernanceConfig> getServiceConfig(@PathVariable String serviceName) {
        ServiceGovernanceConfig config = configService.getConfig(serviceName);
        return Result.success(config);
    }
    
    /**
     * 更新服务治理配置
     */
    @PutMapping("/services/{serviceName}/config")
    public Result<Void> updateServiceConfig(@PathVariable String serviceName,
                                          @RequestBody ServiceGovernanceConfig config) {
        config.setServiceName(serviceName);
        configService.updateConfig(config);
        return Result.success();
    }
    
    /**
     * 更新限流配置
     */
    @PutMapping("/services/{serviceName}/rate-limit")
    public Result<Void> updateRateLimit(@PathVariable String serviceName,
                                       @RequestParam String operation,
                                       @RequestParam double permitsPerSecond) {
        rateLimiter.updateRateLimit(serviceName, operation, permitsPerSecond);
        return Result.success();
    }
    
    /**
     * 服务实例上线
     */
    @PostMapping("/services/{serviceName}/instances/{instanceId}/enable")
    public Result<Void> enableInstance(@PathVariable String serviceName,
                                     @PathVariable String instanceId) {
        configService.enableInstance(serviceName, instanceId);
        return Result.success();
    }
    
    /**
     * 服务实例下线
     */
    @PostMapping("/services/{serviceName}/instances/{instanceId}/disable")
    public Result<Void> disableInstance(@PathVariable String serviceName,
                                      @PathVariable String instanceId) {
        configService.disableInstance(serviceName, instanceId);
        return Result.success();
    }
}
```

## 最佳实践

### 1. 服务拆分原则

- **单一职责**: 每个服务只负责一个业务领域
- **高内聚低耦合**: 服务内部高内聚，服务间低耦合
- **数据独立**: 每个服务拥有独立的数据存储
- **接口稳定**: 保持服务接口的向后兼容性

### 2. 服务通信

- **同步调用**: 使用HTTP/REST进行同步通信
- **异步消息**: 使用消息队列进行异步通信
- **事件驱动**: 基于事件的松耦合架构
- **超时控制**: 设置合理的超时时间

### 3. 容错设计

- **熔断器**: 防止故障传播
- **重试机制**: 处理临时故障
- **降级策略**: 保证核心功能可用
- **隔离机制**: 资源隔离和故障隔离

### 4. 监控告警

- **健康检查**: 定期检查服务健康状态
- **性能监控**: 监控服务性能指标
- **日志聚合**: 集中收集和分析日志
- **链路追踪**: 跟踪请求调用链路

通过以上服务治理架构设计，NSRS系统实现了完整的微服务治理能力，保障了系统的稳定性、可用性和可扩展性。