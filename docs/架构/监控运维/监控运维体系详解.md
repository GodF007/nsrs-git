# 监控运维体系详解

## 概述

监控运维体系是保障NSRS号卡资源管理系统稳定运行的重要基础设施。本文档详细阐述了基于Prometheus、Grafana、ELK Stack的全方位监控运维解决方案。

### 监控运维目标

- **全链路监控**: 应用、基础设施、业务指标全覆盖
- **实时告警**: 快速发现和响应系统异常
- **性能优化**: 基于监控数据进行性能调优
- **故障定位**: 快速定位和解决系统故障
- **容量规划**: 基于历史数据进行容量预测

## 核心枚举定义

### 1. 监控指标类型

```java
/**
 * 监控指标类型枚举
 */
public enum MetricType {
    COUNTER("计数器", "累计值，只增不减"),
    GAUGE("仪表盘", "瞬时值，可增可减"),
    HISTOGRAM("直方图", "分布统计"),
    SUMMARY("摘要", "分位数统计"),
    TIMER("计时器", "时间统计");
    
    private final String name;
    private final String description;
    
    MetricType(String name, String description) {
        this.name = name;
        this.description = description;
    }
    
    // getters...
}
```

### 2. 告警级别枚举

```java
/**
 * 告警级别枚举
 */
public enum AlertLevel {
    INFO("信息", 0, "#36C5F0"),
    WARNING("警告", 1, "#ECB22E"),
    ERROR("错误", 2, "#E01E5A"),
    CRITICAL("严重", 3, "#FF0000"),
    FATAL("致命", 4, "#8B0000");
    
    private final String name;
    private final int level;
    private final String color;
    
    AlertLevel(String name, int level, String color) {
        this.name = name;
        this.level = level;
        this.color = color;
    }
    
    // getters...
}
```

### 3. 监控状态枚举

```java
/**
 * 监控状态枚举
 */
public enum MonitorStatus {
    HEALTHY("健康", "green"),
    WARNING("警告", "yellow"),
    CRITICAL("严重", "red"),
    UNKNOWN("未知", "gray"),
    MAINTENANCE("维护中", "blue");
    
    private final String description;
    private final String color;
    
    MonitorStatus(String description, String color) {
        this.description = description;
        this.color = color;
    }
    
    // getters...
}
```

## 核心实体设计

### 1. 监控指标配置

```java
/**
 * 监控指标配置实体
 */
@Entity
@Table(name = "monitor_metric_config")
public class MonitorMetricConfig {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "metric_name", nullable = false)
    private String metricName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "metric_type")
    private MetricType metricType;
    
    @Column(name = "description")
    private String description;
    
    @Column(name = "unit")
    private String unit; // 单位：ms, %, count等
    
    @Column(name = "collection_interval")
    private Integer collectionInterval; // 采集间隔(秒)
    
    @Column(name = "retention_period")
    private Integer retentionPeriod; // 保留期(天)
    
    @Column(name = "labels", columnDefinition = "JSON")
    private String labels; // 标签配置
    
    @Column(name = "threshold_config", columnDefinition = "JSON")
    private String thresholdConfig; // 阈值配置
    
    @Column(name = "is_enabled")
    private Boolean isEnabled;
    
    @Column(name = "created_time")
    private LocalDateTime createdTime;
    
    @Column(name = "updated_time")
    private LocalDateTime updatedTime;
    
    // constructors, getters, setters...
}
```

### 2. 告警规则配置

```java
/**
 * 告警规则配置实体
 */
@Entity
@Table(name = "alert_rule_config")
public class AlertRuleConfig {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "rule_name", nullable = false)
    private String ruleName;
    
    @Column(name = "metric_name")
    private String metricName;
    
    @Column(name = "condition_expr", columnDefinition = "TEXT")
    private String conditionExpr; // 告警条件表达式
    
    @Enumerated(EnumType.STRING)
    @Column(name = "alert_level")
    private AlertLevel alertLevel;
    
    @Column(name = "duration")
    private Integer duration; // 持续时间(秒)
    
    @Column(name = "notification_channels", columnDefinition = "JSON")
    private String notificationChannels; // 通知渠道配置
    
    @Column(name = "recovery_notification")
    private Boolean recoveryNotification; // 是否发送恢复通知
    
    @Column(name = "silence_duration")
    private Integer silenceDuration; // 静默期(分钟)
    
    @Column(name = "is_enabled")
    private Boolean isEnabled;
    
    @Column(name = "created_time")
    private LocalDateTime createdTime;
    
    @Column(name = "updated_time")
    private LocalDateTime updatedTime;
    
    // constructors, getters, setters...
}
```

### 3. 告警事件记录

```java
/**
 * 告警事件记录实体
 */
@Entity
@Table(name = "alert_event")
public class AlertEvent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "alert_id")
    private String alertId; // 告警唯一标识
    
    @Column(name = "rule_id")
    private Long ruleId;
    
    @Column(name = "rule_name")
    private String ruleName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "alert_level")
    private AlertLevel alertLevel;
    
    @Column(name = "metric_name")
    private String metricName;
    
    @Column(name = "metric_value")
    private Double metricValue;
    
    @Column(name = "threshold_value")
    private Double thresholdValue;
    
    @Column(name = "labels", columnDefinition = "JSON")
    private String labels;
    
    @Column(name = "message", columnDefinition = "TEXT")
    private String message;
    
    @Column(name = "status")
    private String status; // FIRING, RESOLVED
    
    @Column(name = "start_time")
    private LocalDateTime startTime;
    
    @Column(name = "end_time")
    private LocalDateTime endTime;
    
    @Column(name = "duration")
    private Long duration; // 持续时间(毫秒)
    
    @Column(name = "notification_sent")
    private Boolean notificationSent;
    
    @Column(name = "acknowledged")
    private Boolean acknowledged;
    
    @Column(name = "acknowledged_by")
    private String acknowledgedBy;
    
    @Column(name = "acknowledged_time")
    private LocalDateTime acknowledgedTime;
    
    @Column(name = "created_time")
    private LocalDateTime createdTime;
    
    // constructors, getters, setters...
}
```

## 监控服务实现

### 1. 指标收集服务

```java
/**
 * 指标收集服务
 */
@Service
@Slf4j
public class MetricsCollectionService {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Autowired
    private MonitorMetricConfigRepository metricConfigRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 业务指标
    private final Counter simCardCreatedCounter;
    private final Counter imsiAllocatedCounter;
    private final Gauge activeSimCardsGauge;
    private final Timer simCardQueryTimer;
    
    public MetricsCollectionService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // 初始化业务指标
        this.simCardCreatedCounter = Counter.builder("nsrs.sim_card.created.total")
            .description("SIM卡创建总数")
            .register(meterRegistry);
            
        this.imsiAllocatedCounter = Counter.builder("nsrs.imsi.allocated.total")
            .description("IMSI分配总数")
            .register(meterRegistry);
            
        this.activeSimCardsGauge = Gauge.builder("nsrs.sim_card.active.count")
            .description("活跃SIM卡数量")
            .register(meterRegistry, this, MetricsCollectionService::getActiveSimCardCount);
            
        this.simCardQueryTimer = Timer.builder("nsrs.sim_card.query.duration")
            .description("SIM卡查询耗时")
            .register(meterRegistry);
    }
    
    /**
     * 记录SIM卡创建事件
     */
    public void recordSimCardCreated(String supplier, String cardType) {
        simCardCreatedCounter.increment(
            Tags.of(
                "supplier", supplier,
                "card_type", cardType
            )
        );
    }
    
    /**
     * 记录IMSI分配事件
     */
    public void recordImsiAllocated(String mcc, String mnc) {
        imsiAllocatedCounter.increment(
            Tags.of(
                "mcc", mcc,
                "mnc", mnc
            )
        );
    }
    
    /**
     * 记录查询耗时
     */
    public void recordQueryDuration(String operation, long duration) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("nsrs.query.duration")
            .tag("operation", operation)
            .register(meterRegistry));
    }
    
    /**
     * 记录系统资源使用情况
     */
    @Scheduled(fixedRate = 30000) // 每30秒采集一次
    public void collectSystemMetrics() {
        try {
            // CPU使用率
            double cpuUsage = getCpuUsage();
            Gauge.builder("nsrs.system.cpu.usage")
                .description("CPU使用率")
                .register(meterRegistry, () -> cpuUsage);
            
            // 内存使用情况
            MemoryUsage memoryUsage = getMemoryUsage();
            Gauge.builder("nsrs.system.memory.used")
                .description("已使用内存")
                .register(meterRegistry, () -> memoryUsage.getUsed());
            
            Gauge.builder("nsrs.system.memory.max")
                .description("最大内存")
                .register(meterRegistry, () -> memoryUsage.getMax());
            
            // 数据库连接池
            int activeConnections = getActiveDbConnections();
            Gauge.builder("nsrs.db.connections.active")
                .description("活跃数据库连接数")
                .register(meterRegistry, () -> activeConnections);
            
            // Redis连接
            int redisConnections = getRedisConnections();
            Gauge.builder("nsrs.redis.connections.active")
                .description("活跃Redis连接数")
                .register(meterRegistry, () -> redisConnections);
            
        } catch (Exception e) {
            log.error("Failed to collect system metrics", e);
        }
    }
    
    /**
     * 收集业务指标
     */
    @Scheduled(fixedRate = 60000) // 每分钟采集一次
    public void collectBusinessMetrics() {
        try {
            // SIM卡状态分布
            Map<String, Long> simCardStatusCount = getSimCardStatusCount();
            simCardStatusCount.forEach((status, count) -> {
                Gauge.builder("nsrs.sim_card.status.count")
                    .tag("status", status)
                    .description("SIM卡状态分布")
                    .register(meterRegistry, () -> count);
            });
            
            // IMSI资源使用率
            double imsiUsageRate = getImsiUsageRate();
            Gauge.builder("nsrs.imsi.usage.rate")
                .description("IMSI资源使用率")
                .register(meterRegistry, () -> imsiUsageRate);
            
            // 供应商分布
            Map<String, Long> supplierCount = getSupplierDistribution();
            supplierCount.forEach((supplier, count) -> {
                Gauge.builder("nsrs.sim_card.supplier.count")
                    .tag("supplier", supplier)
                    .description("供应商SIM卡分布")
                    .register(meterRegistry, () -> count);
            });
            
        } catch (Exception e) {
            log.error("Failed to collect business metrics", e);
        }
    }
    
    // 辅助方法
    private double getActiveSimCardCount() {
        // 查询活跃SIM卡数量
        return 1000.0; // 示例值
    }
    
    private double getCpuUsage() {
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        if (osBean instanceof com.sun.management.OperatingSystemMXBean) {
            return ((com.sun.management.OperatingSystemMXBean) osBean).getProcessCpuLoad() * 100;
        }
        return 0.0;
    }
    
    private MemoryUsage getMemoryUsage() {
        return ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
    }
    
    private int getActiveDbConnections() {
        // 获取数据库连接池活跃连接数
        return 10; // 示例值
    }
    
    private int getRedisConnections() {
        // 获取Redis连接数
        return 5; // 示例值
    }
    
    private Map<String, Long> getSimCardStatusCount() {
        // 查询SIM卡状态分布
        Map<String, Long> statusCount = new HashMap<>();
        statusCount.put("ACTIVE", 800L);
        statusCount.put("INACTIVE", 150L);
        statusCount.put("SUSPENDED", 50L);
        return statusCount;
    }
    
    private double getImsiUsageRate() {
        // 计算IMSI资源使用率
        return 75.5; // 示例值
    }
    
    private Map<String, Long> getSupplierDistribution() {
        // 查询供应商分布
        Map<String, Long> supplierCount = new HashMap<>();
        supplierCount.put("中国移动", 400L);
        supplierCount.put("中国联通", 350L);
        supplierCount.put("中国电信", 250L);
        return supplierCount;
    }
}
```

### 2. 告警管理服务

```java
/**
 * 告警管理服务
 */
@Service
@Slf4j
public class AlertManagementService {
    
    @Autowired
    private AlertRuleConfigRepository alertRuleRepository;
    
    @Autowired
    private AlertEventRepository alertEventRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 处理告警事件
     */
    public void processAlert(AlertData alertData) {
        try {
            // 1. 查找对应的告警规则
            AlertRuleConfig rule = alertRuleRepository.findByMetricName(alertData.getMetricName());
            if (rule == null || !rule.getIsEnabled()) {
                return;
            }
            
            // 2. 检查是否在静默期
            if (isInSilencePeriod(alertData.getAlertId())) {
                log.debug("Alert {} is in silence period", alertData.getAlertId());
                return;
            }
            
            // 3. 创建或更新告警事件
            AlertEvent alertEvent = createOrUpdateAlertEvent(alertData, rule);
            
            // 4. 发送通知
            if (shouldSendNotification(alertEvent, rule)) {
                sendAlertNotification(alertEvent, rule);
            }
            
            // 5. 设置静默期
            if (rule.getSilenceDuration() != null && rule.getSilenceDuration() > 0) {
                setSilencePeriod(alertData.getAlertId(), rule.getSilenceDuration());
            }
            
        } catch (Exception e) {
            log.error("Failed to process alert: {}", alertData.getAlertId(), e);
        }
    }
    
    /**
     * 确认告警
     */
    public void acknowledgeAlert(String alertId, String acknowledgedBy) {
        AlertEvent alertEvent = alertEventRepository.findByAlertId(alertId);
        if (alertEvent != null && !alertEvent.getAcknowledged()) {
            alertEvent.setAcknowledged(true);
            alertEvent.setAcknowledgedBy(acknowledgedBy);
            alertEvent.setAcknowledgedTime(LocalDateTime.now());
            alertEventRepository.save(alertEvent);
            
            // 发送确认通知
            notificationService.sendAcknowledgmentNotification(alertEvent);
        }
    }
    
    /**
     * 解决告警
     */
    public void resolveAlert(String alertId) {
        AlertEvent alertEvent = alertEventRepository.findByAlertId(alertId);
        if (alertEvent != null && "FIRING".equals(alertEvent.getStatus())) {
            alertEvent.setStatus("RESOLVED");
            alertEvent.setEndTime(LocalDateTime.now());
            alertEvent.setDuration(Duration.between(alertEvent.getStartTime(), 
                alertEvent.getEndTime()).toMillis());
            alertEventRepository.save(alertEvent);
            
            // 发送恢复通知
            AlertRuleConfig rule = alertRuleRepository.findById(alertEvent.getRuleId()).orElse(null);
            if (rule != null && rule.getRecoveryNotification()) {
                notificationService.sendRecoveryNotification(alertEvent);
            }
        }
    }
    
    /**
     * 获取活跃告警列表
     */
    public List<AlertEvent> getActiveAlerts() {
        return alertEventRepository.findByStatusAndEndTimeIsNull("FIRING");
    }
    
    /**
     * 获取告警统计信息
     */
    public AlertStatistics getAlertStatistics(LocalDateTime startTime, LocalDateTime endTime) {
        List<AlertEvent> alerts = alertEventRepository
            .findByCreatedTimeBetween(startTime, endTime);
        
        AlertStatistics statistics = new AlertStatistics();
        statistics.setTotalAlerts(alerts.size());
        
        Map<AlertLevel, Long> levelCount = alerts.stream()
            .collect(Collectors.groupingBy(AlertEvent::getAlertLevel, Collectors.counting()));
        statistics.setLevelDistribution(levelCount);
        
        long resolvedCount = alerts.stream()
            .mapToLong(alert -> "RESOLVED".equals(alert.getStatus()) ? 1 : 0)
            .sum();
        statistics.setResolvedAlerts(resolvedCount);
        statistics.setActiveAlerts(alerts.size() - resolvedCount);
        
        // 平均解决时间
        OptionalDouble avgResolutionTime = alerts.stream()
            .filter(alert -> alert.getDuration() != null)
            .mapToLong(AlertEvent::getDuration)
            .average();
        statistics.setAverageResolutionTime(avgResolutionTime.orElse(0));
        
        return statistics;
    }
    
    // 辅助方法
    private boolean isInSilencePeriod(String alertId) {
        String silenceKey = "alert_silence:" + alertId;
        return redisTemplate.hasKey(silenceKey);
    }
    
    private void setSilencePeriod(String alertId, int minutes) {
        String silenceKey = "alert_silence:" + alertId;
        redisTemplate.opsForValue().set(silenceKey, true, Duration.ofMinutes(minutes));
    }
    
    private AlertEvent createOrUpdateAlertEvent(AlertData alertData, AlertRuleConfig rule) {
        AlertEvent existingEvent = alertEventRepository.findByAlertId(alertData.getAlertId());
        
        if (existingEvent != null && "FIRING".equals(existingEvent.getStatus())) {
            // 更新现有告警
            existingEvent.setMetricValue(alertData.getValue());
            existingEvent.setMessage(alertData.getMessage());
            return alertEventRepository.save(existingEvent);
        } else {
            // 创建新告警
            AlertEvent newEvent = new AlertEvent();
            newEvent.setAlertId(alertData.getAlertId());
            newEvent.setRuleId(rule.getId());
            newEvent.setRuleName(rule.getRuleName());
            newEvent.setAlertLevel(rule.getAlertLevel());
            newEvent.setMetricName(alertData.getMetricName());
            newEvent.setMetricValue(alertData.getValue());
            newEvent.setThresholdValue(alertData.getThreshold());
            newEvent.setLabels(alertData.getLabels());
            newEvent.setMessage(alertData.getMessage());
            newEvent.setStatus("FIRING");
            newEvent.setStartTime(LocalDateTime.now());
            newEvent.setNotificationSent(false);
            newEvent.setAcknowledged(false);
            newEvent.setCreatedTime(LocalDateTime.now());
            
            return alertEventRepository.save(newEvent);
        }
    }
    
    private boolean shouldSendNotification(AlertEvent alertEvent, AlertRuleConfig rule) {
        // 检查是否已发送通知
        if (alertEvent.getNotificationSent()) {
            return false;
        }
        
        // 检查告警级别是否需要通知
        return rule.getAlertLevel().getLevel() >= AlertLevel.WARNING.getLevel();
    }
    
    private void sendAlertNotification(AlertEvent alertEvent, AlertRuleConfig rule) {
        try {
            notificationService.sendAlertNotification(alertEvent, rule);
            alertEvent.setNotificationSent(true);
            alertEventRepository.save(alertEvent);
        } catch (Exception e) {
            log.error("Failed to send alert notification for: {}", alertEvent.getAlertId(), e);
        }
    }
}
```

### 3. 日志分析服务

```java
/**
 * 日志分析服务
 */
@Service
@Slf4j
public class LogAnalysisService {
    
    @Autowired
    private ElasticsearchRestTemplate elasticsearchTemplate;
    
    @Autowired
    private AlertManagementService alertManagementService;
    
    /**
     * 分析错误日志
     */
    @Scheduled(fixedRate = 300000) // 每5分钟分析一次
    public void analyzeErrorLogs() {
        try {
            LocalDateTime endTime = LocalDateTime.now();
            LocalDateTime startTime = endTime.minusMinutes(5);
            
            // 1. 查询错误日志
            List<LogEntry> errorLogs = queryErrorLogs(startTime, endTime);
            
            // 2. 分析错误模式
            Map<String, Long> errorPatterns = analyzeErrorPatterns(errorLogs);
            
            // 3. 检查是否需要告警
            for (Map.Entry<String, Long> entry : errorPatterns.entrySet()) {
                String pattern = entry.getKey();
                Long count = entry.getValue();
                
                // 如果5分钟内同类错误超过10次，触发告警
                if (count > 10) {
                    AlertData alertData = AlertData.builder()
                        .alertId("error_pattern_" + pattern.hashCode())
                        .metricName("error_log_count")
                        .value(count.doubleValue())
                        .threshold(10.0)
                        .message(String.format("错误模式 '%s' 在5分钟内出现 %d 次", pattern, count))
                        .labels(Map.of("pattern", pattern, "timeframe", "5m"))
                        .build();
                    
                    alertManagementService.processAlert(alertData);
                }
            }
            
        } catch (Exception e) {
            log.error("Failed to analyze error logs", e);
        }
    }
    
    /**
     * 分析性能日志
     */
    @Scheduled(fixedRate = 600000) // 每10分钟分析一次
    public void analyzePerformanceLogs() {
        try {
            LocalDateTime endTime = LocalDateTime.now();
            LocalDateTime startTime = endTime.minusMinutes(10);
            
            // 1. 查询慢查询日志
            List<LogEntry> slowQueries = querySlowQueries(startTime, endTime);
            
            // 2. 分析慢查询模式
            Map<String, Double> avgResponseTimes = analyzeResponseTimes(slowQueries);
            
            // 3. 检查响应时间告警
            for (Map.Entry<String, Double> entry : avgResponseTimes.entrySet()) {
                String endpoint = entry.getKey();
                Double avgTime = entry.getValue();
                
                // 如果平均响应时间超过2秒，触发告警
                if (avgTime > 2000) {
                    AlertData alertData = AlertData.builder()
                        .alertId("slow_response_" + endpoint.hashCode())
                        .metricName("response_time_avg")
                        .value(avgTime)
                        .threshold(2000.0)
                        .message(String.format("接口 '%s' 平均响应时间 %.2f ms", endpoint, avgTime))
                        .labels(Map.of("endpoint", endpoint, "timeframe", "10m"))
                        .build();
                    
                    alertManagementService.processAlert(alertData);
                }
            }
            
        } catch (Exception e) {
            log.error("Failed to analyze performance logs", e);
        }
    }
    
    /**
     * 生成日志分析报告
     */
    public LogAnalysisReport generateAnalysisReport(LocalDateTime startTime, LocalDateTime endTime) {
        LogAnalysisReport report = new LogAnalysisReport();
        report.setStartTime(startTime);
        report.setEndTime(endTime);
        
        // 1. 日志量统计
        Map<String, Long> logCounts = getLogCounts(startTime, endTime);
        report.setLogCounts(logCounts);
        
        // 2. 错误统计
        Map<String, Long> errorCounts = getErrorCounts(startTime, endTime);
        report.setErrorCounts(errorCounts);
        
        // 3. 性能统计
        Map<String, Double> performanceStats = getPerformanceStats(startTime, endTime);
        report.setPerformanceStats(performanceStats);
        
        // 4. 热点分析
        List<String> hotspots = analyzeHotspots(startTime, endTime);
        report.setHotspots(hotspots);
        
        return report;
    }
    
    // 辅助方法
    private List<LogEntry> queryErrorLogs(LocalDateTime startTime, LocalDateTime endTime) {
        // 从Elasticsearch查询错误日志
        return new ArrayList<>(); // 简化实现
    }
    
    private Map<String, Long> analyzeErrorPatterns(List<LogEntry> errorLogs) {
        return errorLogs.stream()
            .collect(Collectors.groupingBy(
                log -> extractErrorPattern(log.getMessage()),
                Collectors.counting()
            ));
    }
    
    private String extractErrorPattern(String message) {
        // 提取错误模式，去除具体的参数值
        return message.replaceAll("\\d+", "[NUMBER]")
                     .replaceAll("'[^']*'", "'[STRING]'")
                     .replaceAll("\"[^\"]*\"", "\"[STRING]\"");
    }
    
    private List<LogEntry> querySlowQueries(LocalDateTime startTime, LocalDateTime endTime) {
        // 查询慢查询日志
        return new ArrayList<>(); // 简化实现
    }
    
    private Map<String, Double> analyzeResponseTimes(List<LogEntry> logs) {
        return logs.stream()
            .collect(Collectors.groupingBy(
                LogEntry::getEndpoint,
                Collectors.averagingDouble(LogEntry::getResponseTime)
            ));
    }
}
```

## 监控配置示例

### 1. Prometheus配置

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "nsrs_alerts.yml"
  - "system_alerts.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  # NSRS应用监控
  - job_name: 'nsrs-app'
    static_configs:
      - targets: ['nsrs-app:8080']
    metrics_path: '/actuator/prometheus'
    scrape_interval: 30s
    
  # 系统监控
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']
    
  # MySQL监控
  - job_name: 'mysql-exporter'
    static_configs:
      - targets: ['mysql-exporter:9104']
    
  # Redis监控
  - job_name: 'redis-exporter'
    static_configs:
      - targets: ['redis-exporter:9121']
```

### 2. 告警规则配置

```yaml
# nsrs_alerts.yml
groups:
  - name: nsrs.rules
    rules:
      # 应用可用性告警
      - alert: NSRSApplicationDown
        expr: up{job="nsrs-app"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "NSRS应用不可用"
          description: "NSRS应用已停止响应超过1分钟"
      
      # 响应时间告警
      - alert: HighResponseTime
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "响应时间过高"
          description: "95%的请求响应时间超过2秒"
      
      # 错误率告警
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.05
        for: 3m
        labels:
          severity: critical
        annotations:
          summary: "错误率过高"
          description: "5分钟内错误率超过5%"
      
      # 数据库连接告警
      - alert: DatabaseConnectionHigh
        expr: nsrs_db_connections_active / nsrs_db_connections_max > 0.8
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "数据库连接数过高"
          description: "数据库连接使用率超过80%"
      
      # SIM卡创建异常
      - alert: SimCardCreationAnomaly
        expr: rate(nsrs_sim_card_created_total[1h]) < 0.1
        for: 30m
        labels:
          severity: warning
        annotations:
          summary: "SIM卡创建异常"
          description: "1小时内SIM卡创建速率异常低"
```

### 3. Grafana仪表板配置

```json
{
  "dashboard": {
    "title": "NSRS监控仪表板",
    "panels": [
      {
        "title": "应用状态",
        "type": "stat",
        "targets": [
          {
            "expr": "up{job=\"nsrs-app\"}",
            "legendFormat": "应用状态"
          }
        ]
      },
      {
        "title": "请求QPS",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[1m])",
            "legendFormat": "{{method}} {{uri}}"
          }
        ]
      },
      {
        "title": "响应时间分布",
        "type": "heatmap",
        "targets": [
          {
            "expr": "rate(http_request_duration_seconds_bucket[5m])",
            "legendFormat": "{{le}}"
          }
        ]
      },
      {
        "title": "SIM卡业务指标",
        "type": "graph",
        "targets": [
          {
            "expr": "nsrs_sim_card_active_count",
            "legendFormat": "活跃SIM卡"
          },
          {
            "expr": "rate(nsrs_sim_card_created_total[1h])",
            "legendFormat": "创建速率"
          }
        ]
      }
    ]
  }
}
```

## 运维最佳实践

### 1. 监控策略
- **分层监控**: 基础设施、应用、业务三层监控
- **关键指标**: 重点关注可用性、性能、错误率、容量
- **告警分级**: 根据影响程度设置不同告警级别
- **降噪处理**: 避免告警风暴，合理设置静默期

### 2. 日志管理
- **结构化日志**: 使用JSON格式，便于检索分析
- **日志分级**: 合理设置日志级别，避免日志过多
- **日志轮转**: 定期清理历史日志，控制存储空间
- **敏感信息**: 避免在日志中记录敏感信息

### 3. 性能优化
- **指标优化**: 定期清理无用指标，减少存储压力
- **查询优化**: 优化Prometheus查询语句，提高查询效率
- **存储优化**: 合理设置数据保留期，平衡存储和查询需求
- **网络优化**: 优化监控数据传输，减少网络开销

### 4. 故障处理
- **快速响应**: 建立7x24小时值班制度
- **故障定位**: 利用链路追踪快速定位问题
- **应急预案**: 制定详细的故障处理流程
- **事后复盘**: 分析故障原因，持续改进

通过以上监控运维体系的建设，NSRS系统可以实现全方位的监控覆盖，确保系统稳定运行和快速故障响应。