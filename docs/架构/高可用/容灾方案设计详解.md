# 容灾方案设计详解

## 概述

容灾方案是保障NSRS号卡资源管理系统在面临各种灾难性事件时能够快速恢复业务连续性的关键技术方案。本文档详细阐述了多层次的容灾架构设计，包括数据中心级容灾、应用级容灾、数据库容灾等核心组件。

## 容灾等级定义

### 容灾等级枚举
```java
/**
 * 容灾等级枚举
 */
public enum DisasterRecoveryLevel {
    LEVEL_0("数据备份", "定期数据备份，手动恢复", 72, 24),
    LEVEL_1("冷备份", "备用设备，手动切换", 24, 4),
    LEVEL_2("热备份", "实时数据同步，自动切换", 4, 1),
    LEVEL_3("双活", "双中心同时提供服务", 1, 0.1),
    LEVEL_4("多活", "多中心同时提供服务", 0.5, 0.05),
    LEVEL_5("零停机", "无感知故障切换", 0.1, 0.01);
    
    private final String name;
    private final String description;
    private final double rtoHours; // 恢复时间目标（小时）
    private final double rpoHours; // 恢复点目标（小时）
    
    DisasterRecoveryLevel(String name, String description, double rtoHours, double rpoHours) {
        this.name = name;
        this.description = description;
        this.rtoHours = rtoHours;
        this.rpoHours = rpoHours;
    }
    
    public String getName() { return name; }
    public String getDescription() { return description; }
    public double getRtoHours() { return rtoHours; }
    public double getRpoHours() { return rpoHours; }
}

/**
 * 灾难类型枚举
 */
public enum DisasterType {
    HARDWARE_FAILURE("硬件故障", "服务器、存储、网络设备故障", DisasterRecoveryLevel.LEVEL_2),
    SOFTWARE_FAILURE("软件故障", "应用程序、操作系统故障", DisasterRecoveryLevel.LEVEL_1),
    NETWORK_FAILURE("网络故障", "网络中断、带宽不足", DisasterRecoveryLevel.LEVEL_2),
    POWER_OUTAGE("电力中断", "机房停电、UPS故障", DisasterRecoveryLevel.LEVEL_2),
    NATURAL_DISASTER("自然灾害", "地震、火灾、洪水等", DisasterRecoveryLevel.LEVEL_3),
    CYBER_ATTACK("网络攻击", "DDoS、病毒、黑客攻击", DisasterRecoveryLevel.LEVEL_2),
    HUMAN_ERROR("人为错误", "误操作、配置错误", DisasterRecoveryLevel.LEVEL_1),
    DATA_CORRUPTION("数据损坏", "数据库损坏、文件系统错误", DisasterRecoveryLevel.LEVEL_2);
    
    private final String name;
    private final String description;
    private final DisasterRecoveryLevel recommendedLevel;
    
    DisasterType(String name, String description, DisasterRecoveryLevel recommendedLevel) {
        this.name = name;
        this.description = description;
        this.recommendedLevel = recommendedLevel;
    }
    
    public String getName() { return name; }
    public String getDescription() { return description; }
    public DisasterRecoveryLevel getRecommendedLevel() { return recommendedLevel; }
}
```

## 容灾架构设计

### 多中心容灾架构
```java
/**
 * 数据中心实体
 */
@Entity
@Table(name = "data_center")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DataCenter {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long centerId;
    
    @Column(unique = true, nullable = false)
    private String centerCode; // 数据中心编码
    
    @Column(nullable = false)
    private String centerName; // 数据中心名称
    
    @Enumerated(EnumType.STRING)
    private DataCenterType centerType; // 数据中心类型
    
    @Enumerated(EnumType.STRING)
    private DataCenterStatus status; // 数据中心状态
    
    // 地理位置信息
    private String region; // 区域
    private String city; // 城市
    private String address; // 详细地址
    private Double latitude; // 纬度
    private Double longitude; // 经度
    
    // 网络配置
    private String primaryIp; // 主IP地址
    private String secondaryIp; // 备用IP地址
    private String vipAddress; // 虚拟IP地址
    private Integer bandwidth; // 带宽（Mbps）
    
    // 容量信息
    private Integer cpuCores; // CPU核心数
    private Integer memoryGb; // 内存容量（GB）
    private Integer storageGb; // 存储容量（GB）
    private Integer maxConnections; // 最大连接数
    
    // 容灾配置
    @Enumerated(EnumType.STRING)
    private DisasterRecoveryLevel drLevel; // 容灾等级
    private String primaryCenterCode; // 主中心编码
    private String backupCenterCode; // 备份中心编码
    private Integer syncDelayMs; // 同步延迟（毫秒）
    
    // 健康检查
    private LocalDateTime lastHealthCheck; // 最后健康检查时间
    private Boolean isHealthy; // 是否健康
    private String healthCheckUrl; // 健康检查URL
    
    // 时间信息
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}

/**
 * 数据中心类型枚举
 */
public enum DataCenterType {
    PRIMARY("主中心", "主要生产中心"),
    SECONDARY("备中心", "备份生产中心"),
    DISASTER_RECOVERY("容灾中心", "专用容灾中心"),
    EDGE("边缘中心", "边缘计算中心"),
    CLOUD("云中心", "云服务中心");
    
    private final String name;
    private final String description;
    
    DataCenterType(String name, String description) {
        this.name = name;
        this.description = description;
    }
    
    public String getName() { return name; }
    public String getDescription() { return description; }
}

/**
 * 数据中心状态枚举
 */
public enum DataCenterStatus {
    ACTIVE("活跃", "正常提供服务"),
    STANDBY("待机", "待机状态，可快速切换"),
    MAINTENANCE("维护", "维护状态，暂停服务"),
    FAILED("故障", "故障状态，无法提供服务"),
    RECOVERING("恢复中", "故障恢复中"),
    DECOMMISSIONED("已下线", "已停用");
    
    private final String name;
    private final String description;
    
    DataCenterStatus(String name, String description) {
        this.name = name;
        this.description = description;
    }
    
    public String getName() { return name; }
    public String getDescription() { return description; }
}
```

## 容灾管理服务

### 核心容灾服务
```java
/**
 * 容灾管理服务
 */
@Service
@Slf4j
public class DisasterRecoveryService {
    
    @Autowired
    private DataCenterRepository dataCenterRepository;
    
    @Autowired
    private FailoverService failoverService;
    
    @Autowired
    private DataSyncService dataSyncService;
    
    @Autowired
    private HealthCheckService healthCheckService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private LoadBalancerService loadBalancerService;
    
    /**
     * 初始化容灾环境
     */
    @PostConstruct
    public void initializeDisasterRecovery() {
        log.info("Initializing disaster recovery environment...");
        
        // 加载所有数据中心配置
        List<DataCenter> dataCenters = dataCenterRepository.findAll();
        
        // 验证容灾配置
        validateDisasterRecoveryConfiguration(dataCenters);
        
        // 启动健康检查
        startHealthCheckMonitoring();
        
        // 启动数据同步
        startDataSynchronization();
        
        log.info("Disaster recovery environment initialized successfully");
    }
    
    /**
     * 执行故障切换
     */
    @Transactional
    public FailoverResult executeFailover(String failedCenterCode, String targetCenterCode) {
        log.warn("Executing failover from {} to {}", failedCenterCode, targetCenterCode);
        
        try {
            // 1. 验证故障中心状态
            DataCenter failedCenter = dataCenterRepository.findByCenterCode(failedCenterCode)
                .orElseThrow(() -> new DataCenterNotFoundException(
                    "Failed center not found: " + failedCenterCode));
            
            // 2. 验证目标中心状态
            DataCenter targetCenter = dataCenterRepository.findByCenterCode(targetCenterCode)
                .orElseThrow(() -> new DataCenterNotFoundException(
                    "Target center not found: " + targetCenterCode));
            
            if (targetCenter.getStatus() != DataCenterStatus.STANDBY && 
                targetCenter.getStatus() != DataCenterStatus.ACTIVE) {
                throw new InvalidDataCenterStatusException(
                    "Target center is not available for failover: " + targetCenter.getStatus());
            }
            
            // 3. 执行故障切换步骤
            FailoverResult result = performFailoverSteps(failedCenter, targetCenter);
            
            // 4. 更新数据中心状态
            updateDataCenterStatusAfterFailover(failedCenter, targetCenter);
            
            // 5. 发送故障切换通知
            notificationService.sendFailoverNotification(failedCenter, targetCenter, result);
            
            log.info("Failover completed successfully from {} to {}", 
                failedCenterCode, targetCenterCode);
            
            return result;
            
        } catch (Exception e) {
            log.error("Failover failed from {} to {}", failedCenterCode, targetCenterCode, e);
            throw new FailoverException("Failover execution failed", e);
        }
    }
    
    /**
     * 自动故障检测和切换
     */
    @Async
    public void performAutomaticFailover() {
        log.info("Starting automatic failover detection...");
        
        List<DataCenter> activeCenters = dataCenterRepository
            .findByStatusAndCenterType(DataCenterStatus.ACTIVE, DataCenterType.PRIMARY);
        
        for (DataCenter center : activeCenters) {
            try {
                // 执行健康检查
                HealthCheckResult healthResult = healthCheckService.checkDataCenterHealth(center);
                
                if (!healthResult.isHealthy()) {
                    log.warn("Data center {} is unhealthy: {}", 
                        center.getCenterCode(), healthResult.getErrorMessage());
                    
                    // 查找备用中心
                    Optional<DataCenter> backupCenter = findBestBackupCenter(center);
                    
                    if (backupCenter.isPresent()) {
                        // 执行自动故障切换
                        executeFailover(center.getCenterCode(), backupCenter.get().getCenterCode());
                    } else {
                        log.error("No available backup center found for {}", center.getCenterCode());
                        notificationService.sendCriticalAlert(
                            "No backup center available for " + center.getCenterCode());
                    }
                }
                
            } catch (Exception e) {
                log.error("Error during automatic failover detection for center {}", 
                    center.getCenterCode(), e);
            }
        }
    }
    
    /**
     * 数据同步监控
     */
    @Scheduled(fixedDelay = 30000) // 每30秒检查一次
    public void monitorDataSynchronization() {
        List<DataCenter> centers = dataCenterRepository.findByStatusIn(
            Arrays.asList(DataCenterStatus.ACTIVE, DataCenterStatus.STANDBY));
        
        for (DataCenter center : centers) {
            try {
                // 检查数据同步状态
                DataSyncStatus syncStatus = dataSyncService.checkSyncStatus(center);
                
                if (syncStatus.getDelayMs() > center.getSyncDelayMs() * 2) {
                    log.warn("Data sync delay detected for center {}: {}ms", 
                        center.getCenterCode(), syncStatus.getDelayMs());
                    
                    // 发送同步延迟告警
                    notificationService.sendSyncDelayAlert(center, syncStatus);
                }
                
                // 更新同步延迟
                center.setSyncDelayMs(syncStatus.getDelayMs());
                center.setUpdateTime(LocalDateTime.now());
                dataCenterRepository.save(center);
                
            } catch (Exception e) {
                log.error("Error monitoring data sync for center {}", 
                    center.getCenterCode(), e);
            }
        }
    }
    
    /**
     * 容灾演练
     */
    @Transactional
    public DrillResult performDisasterRecoveryDrill(DisasterRecoveryDrillRequest request) {
        log.info("Starting disaster recovery drill: {}", request.getDrillName());
        
        DrillResult result = DrillResult.builder()
            .drillId(UUID.randomUUID().toString())
            .drillName(request.getDrillName())
            .drillType(request.getDrillType())
            .startTime(LocalDateTime.now())
            .build();
        
        try {
            switch (request.getDrillType()) {
                case FAILOVER_DRILL:
                    result = performFailoverDrill(request, result);
                    break;
                case DATA_RECOVERY_DRILL:
                    result = performDataRecoveryDrill(request, result);
                    break;
                case FULL_DISASTER_DRILL:
                    result = performFullDisasterDrill(request, result);
                    break;
                default:
                    throw new UnsupportedDrillTypeException(
                        "Unsupported drill type: " + request.getDrillType());
            }
            
            result.setEndTime(LocalDateTime.now());
            result.setSuccess(true);
            result.setDurationMs(Duration.between(result.getStartTime(), result.getEndTime()).toMillis());
            
            log.info("Disaster recovery drill completed successfully: {}", request.getDrillName());
            
        } catch (Exception e) {
            log.error("Disaster recovery drill failed: {}", request.getDrillName(), e);
            result.setEndTime(LocalDateTime.now());
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
        }
        
        // 生成演练报告
        generateDrillReport(result);
        
        return result;
    }
    
    /**
     * 容灾能力评估
     */
    public DisasterRecoveryAssessment assessDisasterRecoveryCapability() {
        log.info("Assessing disaster recovery capability...");
        
        DisasterRecoveryAssessment assessment = DisasterRecoveryAssessment.builder()
            .assessmentId(UUID.randomUUID().toString())
            .assessmentTime(LocalDateTime.now())
            .build();
        
        // 评估数据中心分布
        assessDataCenterDistribution(assessment);
        
        // 评估数据同步能力
        assessDataSyncCapability(assessment);
        
        // 评估故障切换能力
        assessFailoverCapability(assessment);
        
        // 评估恢复时间目标
        assessRecoveryTimeObjective(assessment);
        
        // 评估恢复点目标
        assessRecoveryPointObjective(assessment);
        
        // 计算总体评分
        calculateOverallScore(assessment);
        
        log.info("Disaster recovery capability assessment completed. Score: {}", 
            assessment.getOverallScore());
        
        return assessment;
    }
    
    // 私有辅助方法
    private void validateDisasterRecoveryConfiguration(List<DataCenter> dataCenters) {
        // 验证至少有一个主中心和一个备中心
        boolean hasPrimary = dataCenters.stream()
            .anyMatch(dc -> dc.getCenterType() == DataCenterType.PRIMARY);
        boolean hasBackup = dataCenters.stream()
            .anyMatch(dc -> dc.getCenterType() == DataCenterType.SECONDARY || 
                          dc.getCenterType() == DataCenterType.DISASTER_RECOVERY);
        
        if (!hasPrimary) {
            throw new InvalidConfigurationException("No primary data center configured");
        }
        if (!hasBackup) {
            throw new InvalidConfigurationException("No backup data center configured");
        }
        
        // 验证地理分布
        Set<String> regions = dataCenters.stream()
            .map(DataCenter::getRegion)
            .collect(Collectors.toSet());
        
        if (regions.size() < 2) {
            log.warn("Data centers are not geographically distributed across multiple regions");
        }
    }
    
    private void startHealthCheckMonitoring() {
        log.info("Starting health check monitoring...");
        // 启动定时健康检查任务
        healthCheckService.startContinuousHealthCheck();
    }
    
    private void startDataSynchronization() {
        log.info("Starting data synchronization...");
        // 启动数据同步服务
        dataSyncService.startContinuousSync();
    }
    
    private FailoverResult performFailoverSteps(DataCenter failedCenter, DataCenter targetCenter) {
        FailoverResult result = FailoverResult.builder()
            .failoverId(UUID.randomUUID().toString())
            .sourceCenter(failedCenter.getCenterCode())
            .targetCenter(targetCenter.getCenterCode())
            .startTime(LocalDateTime.now())
            .build();
        
        List<FailoverStep> steps = new ArrayList<>();
        
        try {
            // 步骤1: 停止故障中心流量
            steps.add(executeFailoverStep("STOP_TRAFFIC", 
                () -> loadBalancerService.removeFromLoadBalancer(failedCenter)));
            
            // 步骤2: 验证数据同步状态
            steps.add(executeFailoverStep("VERIFY_DATA_SYNC", 
                () -> dataSyncService.verifyDataConsistency(failedCenter, targetCenter)));
            
            // 步骤3: 启动目标中心服务
            steps.add(executeFailoverStep("START_TARGET_SERVICES", 
                () -> failoverService.startServices(targetCenter)));
            
            // 步骤4: 切换DNS和负载均衡
            steps.add(executeFailoverStep("SWITCH_DNS_LB", 
                () -> loadBalancerService.switchToTarget(targetCenter)));
            
            // 步骤5: 验证服务可用性
            steps.add(executeFailoverStep("VERIFY_SERVICES", 
                () -> healthCheckService.verifyServiceAvailability(targetCenter)));
            
            result.setSteps(steps);
            result.setEndTime(LocalDateTime.now());
            result.setSuccess(true);
            
        } catch (Exception e) {
            result.setSteps(steps);
            result.setEndTime(LocalDateTime.now());
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
            throw e;
        }
        
        return result;
    }
    
    private FailoverStep executeFailoverStep(String stepName, Runnable action) {
        FailoverStep step = FailoverStep.builder()
            .stepName(stepName)
            .startTime(LocalDateTime.now())
            .build();
        
        try {
            action.run();
            step.setEndTime(LocalDateTime.now());
            step.setSuccess(true);
            log.info("Failover step '{}' completed successfully", stepName);
        } catch (Exception e) {
            step.setEndTime(LocalDateTime.now());
            step.setSuccess(false);
            step.setErrorMessage(e.getMessage());
            log.error("Failover step '{}' failed", stepName, e);
            throw e;
        }
        
        return step;
    }
    
    private void updateDataCenterStatusAfterFailover(DataCenter failedCenter, DataCenter targetCenter) {
        // 更新故障中心状态
        failedCenter.setStatus(DataCenterStatus.FAILED);
        failedCenter.setUpdateTime(LocalDateTime.now());
        dataCenterRepository.save(failedCenter);
        
        // 更新目标中心状态
        targetCenter.setStatus(DataCenterStatus.ACTIVE);
        targetCenter.setUpdateTime(LocalDateTime.now());
        dataCenterRepository.save(targetCenter);
    }
    
    private Optional<DataCenter> findBestBackupCenter(DataCenter failedCenter) {
        return dataCenterRepository.findByStatusAndCenterTypeIn(
            DataCenterStatus.STANDBY, 
            Arrays.asList(DataCenterType.SECONDARY, DataCenterType.DISASTER_RECOVERY))
            .stream()
            .filter(dc -> !dc.getRegion().equals(failedCenter.getRegion())) // 不同地区
            .min(Comparator.comparing(dc -> calculateDistance(failedCenter, dc))); // 选择最近的
    }
    
    private double calculateDistance(DataCenter center1, DataCenter center2) {
        // 简化的距离计算（实际应使用地理距离计算）
        double lat1 = center1.getLatitude();
        double lon1 = center1.getLongitude();
        double lat2 = center2.getLatitude();
        double lon2 = center2.getLongitude();
        
        return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lon2 - lon1, 2));
    }
    
    private DrillResult performFailoverDrill(DisasterRecoveryDrillRequest request, DrillResult result) {
        // 模拟故障切换演练
        log.info("Performing failover drill...");
        
        // 选择演练的数据中心
        DataCenter primaryCenter = dataCenterRepository
            .findByCenterCode(request.getPrimaryCenterCode())
            .orElseThrow(() -> new DataCenterNotFoundException(
                "Primary center not found: " + request.getPrimaryCenterCode()));
        
        DataCenter backupCenter = dataCenterRepository
            .findByCenterCode(request.getBackupCenterCode())
            .orElseThrow(() -> new DataCenterNotFoundException(
                "Backup center not found: " + request.getBackupCenterCode()));
        
        // 执行模拟故障切换（不影响生产环境）
        FailoverResult failoverResult = simulateFailover(primaryCenter, backupCenter);
        
        result.setFailoverResult(failoverResult);
        return result;
    }
    
    private DrillResult performDataRecoveryDrill(DisasterRecoveryDrillRequest request, DrillResult result) {
        // 模拟数据恢复演练
        log.info("Performing data recovery drill...");
        
        // 执行数据恢复测试
        DataRecoveryResult recoveryResult = dataSyncService.performRecoveryTest(
            request.getRecoveryPointTime());
        
        result.setDataRecoveryResult(recoveryResult);
        return result;
    }
    
    private DrillResult performFullDisasterDrill(DisasterRecoveryDrillRequest request, DrillResult result) {
        // 执行完整容灾演练
        log.info("Performing full disaster drill...");
        
        // 组合故障切换和数据恢复演练
        result = performFailoverDrill(request, result);
        result = performDataRecoveryDrill(request, result);
        
        return result;
    }
    
    private FailoverResult simulateFailover(DataCenter primaryCenter, DataCenter backupCenter) {
        // 模拟故障切换过程（测试环境）
        return FailoverResult.builder()
            .failoverId("DRILL_" + UUID.randomUUID().toString())
            .sourceCenter(primaryCenter.getCenterCode())
            .targetCenter(backupCenter.getCenterCode())
            .startTime(LocalDateTime.now())
            .endTime(LocalDateTime.now().plusSeconds(30)) // 模拟30秒切换时间
            .success(true)
            .build();
    }
    
    private void generateDrillReport(DrillResult result) {
        // 生成演练报告
        log.info("Generating drill report for: {}", result.getDrillName());
        // 实际实现中会生成详细的PDF报告
    }
    
    private void assessDataCenterDistribution(DisasterRecoveryAssessment assessment) {
        List<DataCenter> centers = dataCenterRepository.findAll();
        
        // 评估地理分布
        Set<String> regions = centers.stream().map(DataCenter::getRegion).collect(Collectors.toSet());
        assessment.setGeographicDistributionScore(Math.min(regions.size() * 20, 100));
        
        // 评估中心数量
        assessment.setDataCenterCount(centers.size());
        assessment.setDataCenterCountScore(Math.min(centers.size() * 10, 100));
    }
    
    private void assessDataSyncCapability(DisasterRecoveryAssessment assessment) {
        // 评估数据同步能力
        List<DataCenter> activeCenters = dataCenterRepository
            .findByStatusIn(Arrays.asList(DataCenterStatus.ACTIVE, DataCenterStatus.STANDBY));
        
        double avgSyncDelay = activeCenters.stream()
            .mapToInt(DataCenter::getSyncDelayMs)
            .average()
            .orElse(0);
        
        // 同步延迟越低分数越高
        int syncScore = (int) Math.max(100 - (avgSyncDelay / 1000), 0);
        assessment.setDataSyncScore(syncScore);
    }
    
    private void assessFailoverCapability(DisasterRecoveryAssessment assessment) {
        // 评估故障切换能力
        // 基于历史故障切换成功率
        assessment.setFailoverCapabilityScore(85); // 示例分数
    }
    
    private void assessRecoveryTimeObjective(DisasterRecoveryAssessment assessment) {
        // 评估RTO
        assessment.setRtoMinutes(15); // 示例：15分钟RTO
        assessment.setRtoScore(90);
    }
    
    private void assessRecoveryPointObjective(DisasterRecoveryAssessment assessment) {
        // 评估RPO
        assessment.setRpoMinutes(5); // 示例：5分钟RPO
        assessment.setRpoScore(95);
    }
    
    private void calculateOverallScore(DisasterRecoveryAssessment assessment) {
        // 计算总体评分
        double overallScore = (
            assessment.getGeographicDistributionScore() * 0.2 +
            assessment.getDataCenterCountScore() * 0.1 +
            assessment.getDataSyncScore() * 0.2 +
            assessment.getFailoverCapabilityScore() * 0.2 +
            assessment.getRtoScore() * 0.15 +
            assessment.getRpoScore() * 0.15
        );
        
        assessment.setOverallScore((int) overallScore);
        
        // 确定评级
        if (overallScore >= 90) {
            assessment.setGrade("A");
        } else if (overallScore >= 80) {
            assessment.setGrade("B");
        } else if (overallScore >= 70) {
            assessment.setGrade("C");
        } else {
            assessment.setGrade("D");
        }
    }
}
```

## 数据同步服务

### 实时数据同步
```java
/**
 * 数据同步服务
 */
@Service
@Slf4j
public class DataSyncService {
    
    @Autowired
    private DataCenterRepository dataCenterRepository;
    
    @Autowired
    private DatabaseSyncService databaseSyncService;
    
    @Autowired
    private FileSyncService fileSyncService;
    
    @Autowired
    private ConfigSyncService configSyncService;
    
    @Value("${disaster.recovery.sync.batch.size:1000}")
    private int syncBatchSize;
    
    @Value("${disaster.recovery.sync.interval.ms:5000}")
    private long syncIntervalMs;
    
    private final ScheduledExecutorService syncExecutor = 
        Executors.newScheduledThreadPool(10);
    
    /**
     * 启动持续数据同步
     */
    public void startContinuousSync() {
        log.info("Starting continuous data synchronization...");
        
        List<DataCenter> primaryCenters = dataCenterRepository
            .findByCenterType(DataCenterType.PRIMARY);
        
        for (DataCenter primaryCenter : primaryCenters) {
            List<DataCenter> backupCenters = findBackupCenters(primaryCenter);
            
            for (DataCenter backupCenter : backupCenters) {
                startSyncTask(primaryCenter, backupCenter);
            }
        }
    }
    
    /**
     * 启动同步任务
     */
    private void startSyncTask(DataCenter sourceCenter, DataCenter targetCenter) {
        syncExecutor.scheduleWithFixedDelay(() -> {
            try {
                performDataSync(sourceCenter, targetCenter);
            } catch (Exception e) {
                log.error("Data sync failed from {} to {}", 
                    sourceCenter.getCenterCode(), targetCenter.getCenterCode(), e);
            }
        }, 0, syncIntervalMs, TimeUnit.MILLISECONDS);
        
        log.info("Started sync task from {} to {}", 
            sourceCenter.getCenterCode(), targetCenter.getCenterCode());
    }
    
    /**
     * 执行数据同步
     */
    @Transactional
    public DataSyncResult performDataSync(DataCenter sourceCenter, DataCenter targetCenter) {
        log.debug("Performing data sync from {} to {}", 
            sourceCenter.getCenterCode(), targetCenter.getCenterCode());
        
        DataSyncResult result = DataSyncResult.builder()
            .syncId(UUID.randomUUID().toString())
            .sourceCenter(sourceCenter.getCenterCode())
            .targetCenter(targetCenter.getCenterCode())
            .startTime(LocalDateTime.now())
            .build();
        
        try {
            // 1. 同步数据库数据
            DatabaseSyncResult dbResult = databaseSyncService.syncDatabase(
                sourceCenter, targetCenter, syncBatchSize);
            result.setDatabaseSyncResult(dbResult);
            
            // 2. 同步文件数据
            FileSyncResult fileResult = fileSyncService.syncFiles(
                sourceCenter, targetCenter);
            result.setFileSyncResult(fileResult);
            
            // 3. 同步配置数据
            ConfigSyncResult configResult = configSyncService.syncConfigurations(
                sourceCenter, targetCenter);
            result.setConfigSyncResult(configResult);
            
            result.setEndTime(LocalDateTime.now());
            result.setSuccess(true);
            result.setTotalRecords(dbResult.getSyncedRecords() + fileResult.getSyncedFiles());
            
            // 更新同步延迟
            long delayMs = Duration.between(result.getStartTime(), result.getEndTime()).toMillis();
            targetCenter.setSyncDelayMs((int) delayMs);
            dataCenterRepository.save(targetCenter);
            
            log.debug("Data sync completed successfully from {} to {}, records: {}", 
                sourceCenter.getCenterCode(), targetCenter.getCenterCode(), result.getTotalRecords());
            
        } catch (Exception e) {
            result.setEndTime(LocalDateTime.now());
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
            log.error("Data sync failed from {} to {}", 
                sourceCenter.getCenterCode(), targetCenter.getCenterCode(), e);
            throw new DataSyncException("Data synchronization failed", e);
        }
        
        return result;
    }
    
    /**
     * 检查同步状态
     */
    public DataSyncStatus checkSyncStatus(DataCenter dataCenter) {
        try {
            // 检查最后同步时间
            LocalDateTime lastSyncTime = getLastSyncTime(dataCenter);
            long delayMs = Duration.between(lastSyncTime, LocalDateTime.now()).toMillis();
            
            // 检查数据一致性
            boolean isConsistent = verifyDataConsistency(dataCenter);
            
            return DataSyncStatus.builder()
                .centerCode(dataCenter.getCenterCode())
                .lastSyncTime(lastSyncTime)
                .delayMs((int) delayMs)
                .isConsistent(isConsistent)
                .checkTime(LocalDateTime.now())
                .build();
            
        } catch (Exception e) {
            log.error("Failed to check sync status for center {}", 
                dataCenter.getCenterCode(), e);
            return DataSyncStatus.builder()
                .centerCode(dataCenter.getCenterCode())
                .delayMs(Integer.MAX_VALUE)
                .isConsistent(false)
                .errorMessage(e.getMessage())
                .checkTime(LocalDateTime.now())
                .build();
        }
    }
    
    /**
     * 验证数据一致性
     */
    public boolean verifyDataConsistency(DataCenter sourceCenter, DataCenter targetCenter) {
        try {
            // 验证关键业务表的数据一致性
            boolean simCardConsistent = databaseSyncService.verifyTableConsistency(
                sourceCenter, targetCenter, "sim_card");
            boolean msisdnConsistent = databaseSyncService.verifyTableConsistency(
                sourceCenter, targetCenter, "msisdn_pool");
            boolean customerConsistent = databaseSyncService.verifyTableConsistency(
                sourceCenter, targetCenter, "customer");
            
            return simCardConsistent && msisdnConsistent && customerConsistent;
            
        } catch (Exception e) {
            log.error("Failed to verify data consistency between {} and {}", 
                sourceCenter.getCenterCode(), targetCenter.getCenterCode(), e);
            return false;
        }
    }
    
    /**
     * 执行数据恢复测试
     */
    public DataRecoveryResult performRecoveryTest(LocalDateTime recoveryPointTime) {
        log.info("Performing data recovery test to point: {}", recoveryPointTime);
        
        DataRecoveryResult result = DataRecoveryResult.builder()
            .recoveryId(UUID.randomUUID().toString())
            .recoveryPointTime(recoveryPointTime)
            .startTime(LocalDateTime.now())
            .build();
        
        try {
            // 1. 创建测试环境
            String testEnvironment = createTestEnvironment();
            result.setTestEnvironment(testEnvironment);
            
            // 2. 恢复数据到指定时间点
            DatabaseRecoveryResult dbRecovery = databaseSyncService
                .recoverToPointInTime(testEnvironment, recoveryPointTime);
            result.setDatabaseRecoveryResult(dbRecovery);
            
            // 3. 验证恢复的数据
            DataValidationResult validation = validateRecoveredData(testEnvironment);
            result.setValidationResult(validation);
            
            // 4. 清理测试环境
            cleanupTestEnvironment(testEnvironment);
            
            result.setEndTime(LocalDateTime.now());
            result.setSuccess(validation.isValid());
            
            log.info("Data recovery test completed. Success: {}", result.isSuccess());
            
        } catch (Exception e) {
            result.setEndTime(LocalDateTime.now());
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
            log.error("Data recovery test failed", e);
        }
        
        return result;
    }
    
    // 私有辅助方法
    private List<DataCenter> findBackupCenters(DataCenter primaryCenter) {
        return dataCenterRepository.findByCenterTypeIn(
            Arrays.asList(DataCenterType.SECONDARY, DataCenterType.DISASTER_RECOVERY))
            .stream()
            .filter(dc -> dc.getStatus() == DataCenterStatus.STANDBY || 
                         dc.getStatus() == DataCenterStatus.ACTIVE)
            .collect(Collectors.toList());
    }
    
    private LocalDateTime getLastSyncTime(DataCenter dataCenter) {
        // 从同步日志中获取最后同步时间
        return dataCenter.getUpdateTime(); // 简化实现
    }
    
    private boolean verifyDataConsistency(DataCenter dataCenter) {
        // 验证单个数据中心的数据一致性
        return databaseSyncService.checkDataIntegrity(dataCenter);
    }
    
    private String createTestEnvironment() {
        // 创建隔离的测试环境
        String testEnvId = "TEST_ENV_" + System.currentTimeMillis();
        log.info("Created test environment: {}", testEnvId);
        return testEnvId;
    }
    
    private DataValidationResult validateRecoveredData(String testEnvironment) {
        // 验证恢复的数据完整性和正确性
        return DataValidationResult.builder()
            .isValid(true)
            .validatedRecords(10000)
            .errorCount(0)
            .build();
    }
    
    private void cleanupTestEnvironment(String testEnvironment) {
        // 清理测试环境
        log.info("Cleaned up test environment: {}", testEnvironment);
    }
}
```

## Demo脚本示例

### 容灾方案Demo
```bash
#!/bin/bash
# 容灾方案Demo脚本

echo "=== NSRS容灾方案Demo ==="

# 1. 初始化数据中心配置
echo "1. 初始化数据中心配置..."

# 注册主数据中心（北京）
curl -X POST http://localhost:8080/api/v1/disaster-recovery/data-centers \
  -H "Content-Type: application/json" \
  -d '{
    "centerCode": "DC_BJ_PRIMARY",
    "centerName": "北京主数据中心",
    "centerType": "PRIMARY",
    "status": "ACTIVE",
    "region": "华北",
    "city": "北京",
    "address": "北京市海淀区中关村软件园",
    "latitude": 39.9042,
    "longitude": 116.4074,
    "primaryIp": "10.1.1.100",
    "vipAddress": "10.1.1.200",
    "bandwidth": 10000,
    "cpuCores": 128,
    "memoryGb": 512,
    "storageGb": 10240,
    "maxConnections": 10000,
    "drLevel": "LEVEL_3",
    "healthCheckUrl": "http://10.1.1.100:8080/health"
  }'

# 注册备数据中心（上海）
curl -X POST http://localhost:8080/api/v1/disaster-recovery/data-centers \
  -H "Content-Type: application/json" \
  -d '{
    "centerCode": "DC_SH_SECONDARY",
    "centerName": "上海备数据中心",
    "centerType": "SECONDARY",
    "status": "STANDBY",
    "region": "华东",
    "city": "上海",
    "address": "上海市浦东新区张江高科技园区",
    "latitude": 31.2304,
    "longitude": 121.4737,
    "primaryIp": "10.2.1.100",
    "vipAddress": "10.2.1.200",
    "bandwidth": 8000,
    "cpuCores": 96,
    "memoryGb": 384,
    "storageGb": 8192,
    "maxConnections": 8000,
    "drLevel": "LEVEL_3",
    "primaryCenterCode": "DC_BJ_PRIMARY",
    "healthCheckUrl": "http://10.2.1.100:8080/health"
  }'

# 注册容灾中心（深圳）
curl -X POST http://localhost:8080/api/v1/disaster-recovery/data-centers \
  -H "Content-Type: application/json" \
  -d '{
    "centerCode": "DC_SZ_DR",
    "centerName": "深圳容灾中心",
    "centerType": "DISASTER_RECOVERY",
    "status": "STANDBY",
    "region": "华南",
    "city": "深圳",
    "address": "深圳市南山区科技园",
    "latitude": 22.5431,
    "longitude": 114.0579,
    "primaryIp": "10.3.1.100",
    "vipAddress": "10.3.1.200",
    "bandwidth": 6000,
    "cpuCores": 64,
    "memoryGb": 256,
    "storageGb": 6144,
    "maxConnections": 6000,
    "drLevel": "LEVEL_2",
    "primaryCenterCode": "DC_BJ_PRIMARY",
    "healthCheckUrl": "http://10.3.1.100:8080/health"
  }'

# 2. 启动数据同步
echo "\n2. 启动数据同步..."
curl -X POST http://localhost:8080/api/v1/disaster-recovery/sync/start

# 3. 检查数据中心健康状态
echo "\n3. 检查数据中心健康状态..."
curl -X GET http://localhost:8080/api/v1/disaster-recovery/data-centers/health

# 4. 检查数据同步状态
echo "\n4. 检查数据同步状态..."
curl -X GET http://localhost:8080/api/v1/disaster-recovery/sync/status

# 5. 模拟主中心故障
echo "\n5. 模拟主中心故障..."
curl -X POST http://localhost:8080/api/v1/disaster-recovery/simulate-failure \
  -H "Content-Type: application/json" \
  -d '{
    "centerCode": "DC_BJ_PRIMARY",
    "failureType": "HARDWARE_FAILURE",
    "description": "模拟服务器硬件故障"
  }'

# 6. 执行自动故障切换
echo "\n6. 执行自动故障切换..."
curl -X POST http://localhost:8080/api/v1/disaster-recovery/failover \
  -H "Content-Type: application/json" \
  -d '{
    "failedCenterCode": "DC_BJ_PRIMARY",
    "targetCenterCode": "DC_SH_SECONDARY",
    "failoverType": "AUTOMATIC",
    "reason": "主中心硬件故障"
  }'

# 7. 验证故障切换结果
echo "\n7. 验证故障切换结果..."
curl -X GET http://localhost:8080/api/v1/disaster-recovery/failover/status

# 8. 检查服务可用性
echo "\n8. 检查服务可用性..."
curl -X GET http://localhost:8080/api/v1/health
curl -X GET http://localhost:8080/api/v1/sim-cards/count

# 9. 执行容灾演练
echo "\n9. 执行容灾演练..."
curl -X POST http://localhost:8080/api/v1/disaster-recovery/drill \
  -H "Content-Type: application/json" \
  -d '{
    "drillName": "月度容灾演练",
    "drillType": "FAILOVER_DRILL",
    "primaryCenterCode": "DC_SH_SECONDARY",
    "backupCenterCode": "DC_SZ_DR",
    "description": "测试从上海到深圳的故障切换"
  }'

# 10. 容灾能力评估
echo "\n10. 容灾能力评估..."
curl -X GET http://localhost:8080/api/v1/disaster-recovery/assessment

# 11. 模拟主中心恢复
echo "\n11. 模拟主中心恢复..."
curl -X POST http://localhost:8080/api/v1/disaster-recovery/recover \
  -H "Content-Type: application/json" \
  -d '{
    "centerCode": "DC_BJ_PRIMARY",
    "recoveryType": "FULL_RECOVERY",
    "description": "硬件故障已修复，恢复服务"
  }'

# 12. 执行回切操作
echo "\n12. 执行回切操作..."
curl -X POST http://localhost:8080/api/v1/disaster-recovery/failback \
  -H "Content-Type: application/json" \
  -d '{
    "currentActiveCenterCode": "DC_SH_SECONDARY",
    "targetCenterCode": "DC_BJ_PRIMARY",
    "failbackType": "PLANNED",
    "reason": "主中心已恢复正常"
  }'

echo "\n=== 容灾方案Demo完成 ==="
echo "主要功能验证："
echo "✓ 多数据中心配置"
echo "✓ 实时数据同步"
echo "✓ 自动故障检测"
echo "✓ 自动故障切换"
echo "✓ 服务可用性验证"
echo "✓ 容灾演练"
echo "✓ 容灾能力评估"
echo "✓ 故障恢复和回切"
```

### 数据库容灾Demo
```bash
#!/bin/bash
# 数据库容灾Demo脚本

echo "=== 数据库容灾Demo ==="

# 1. 配置主从数据库
echo "1. 配置主从数据库..."

# 配置主数据库（北京）
docker run -d --name mysql-primary-bj \
  -e MYSQL_ROOT_PASSWORD=nsrs123456 \
  -e MYSQL_DATABASE=nsrs \
  -e MYSQL_USER=nsrs \
  -e MYSQL_PASSWORD=nsrs123 \
  -p 3306:3306 \
  -v mysql-primary-data:/var/lib/mysql \
  -v ./mysql-primary.cnf:/etc/mysql/conf.d/mysql.cnf \
  mysql:8.0

# 配置从数据库（上海）
docker run -d --name mysql-secondary-sh \
  -e MYSQL_ROOT_PASSWORD=nsrs123456 \
  -e MYSQL_DATABASE=nsrs \
  -e MYSQL_USER=nsrs \
  -e MYSQL_PASSWORD=nsrs123 \
  -p 3307:3306 \
  -v mysql-secondary-data:/var/lib/mysql \
  -v ./mysql-secondary.cnf:/etc/mysql/conf.d/mysql.cnf \
  mysql:8.0

# 配置容灾数据库（深圳）
docker run -d --name mysql-dr-sz \
  -e MYSQL_ROOT_PASSWORD=nsrs123456 \
  -e MYSQL_DATABASE=nsrs \
  -e MYSQL_USER=nsrs \
  -e MYSQL_PASSWORD=nsrs123 \
  -p 3308:3306 \
  -v mysql-dr-data:/var/lib/mysql \
  -v ./mysql-dr.cnf:/etc/mysql/conf.d/mysql.cnf \
  mysql:8.0

# 2. 初始化数据库结构
echo "\n2. 初始化数据库结构..."
mysql -h localhost -P 3306 -u root -pnsrs123456 nsrs < ../../../sql/NSRS_TABLE_SQL.sql

# 3. 配置主从复制
echo "\n3. 配置主从复制..."

# 在主数据库创建复制用户
mysql -h localhost -P 3306 -u root -pnsrs123456 -e "
CREATE USER 'repl'@'%' IDENTIFIED BY 'repl123456';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;
SHOW MASTER STATUS;
"

# 配置从数据库
mysql -h localhost -P 3307 -u root -pnsrs123456 -e "
CHANGE MASTER TO
  MASTER_HOST='host.docker.internal',
  MASTER_PORT=3306,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123456',
  MASTER_AUTO_POSITION=1;
START SLAVE;
SHOW SLAVE STATUS\G;
"

# 配置容灾数据库
mysql -h localhost -P 3308 -u root -pnsrs123456 -e "
CHANGE MASTER TO
  MASTER_HOST='host.docker.internal',
  MASTER_PORT=3306,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123456',
  MASTER_AUTO_POSITION=1;
START SLAVE;
SHOW SLAVE STATUS\G;
"

# 4. 测试数据同步
echo "\n4. 测试数据同步..."

# 在主数据库插入测试数据
mysql -h localhost -P 3306 -u root -pnsrs123456 nsrs -e "
INSERT INTO sim_card (iccid, imsi, msisdn, status, operator_id, create_time) VALUES
('89860000000000000001', '460000000000001', '13800000001', 'ACTIVE', 'CMCC', NOW()),
('89860000000000000002', '460000000000002', '13800000002', 'ACTIVE', 'CUCC', NOW()),
('89860000000000000003', '460000000000003', '13800000003', 'ACTIVE', 'CTCC', NOW());
"

# 等待同步
sleep 5

# 验证从数据库同步
echo "验证上海从数据库同步："
mysql -h localhost -P 3307 -u root -pnsrs123456 nsrs -e "SELECT COUNT(*) as sync_count FROM sim_card;"

echo "验证深圳容灾数据库同步："
mysql -h localhost -P 3308 -u root -pnsrs123456 nsrs -e "SELECT COUNT(*) as sync_count FROM sim_card;"

# 5. 模拟主数据库故障
echo "\n5. 模拟主数据库故障..."
docker stop mysql-primary-bj

# 6. 提升从数据库为主数据库
echo "\n6. 提升从数据库为主数据库..."
mysql -h localhost -P 3307 -u root -pnsrs123456 -e "
STOP SLAVE;
RESET SLAVE ALL;
SET GLOBAL read_only = OFF;
SHOW MASTER STATUS;
"

# 7. 重新配置容灾数据库指向新主数据库
echo "\n7. 重新配置容灾数据库..."
mysql -h localhost -P 3308 -u root -pnsrs123456 -e "
STOP SLAVE;
CHANGE MASTER TO
  MASTER_HOST='host.docker.internal',
  MASTER_PORT=3307,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123456',
  MASTER_AUTO_POSITION=1;
START SLAVE;
SHOW SLAVE STATUS\G;
"

# 8. 测试新主数据库写入
echo "\n8. 测试新主数据库写入..."
mysql -h localhost -P 3307 -u root -pnsrs123456 nsrs -e "
INSERT INTO sim_card (iccid, imsi, msisdn, status, operator_id, create_time) VALUES
('89860000000000000004', '460000000000004', '13800000004', 'ACTIVE', 'CMCC', NOW());
"

# 验证容灾数据库同步
sleep 3
echo "验证容灾数据库同步："
mysql -h localhost -P 3308 -u root -pnsrs123456 nsrs -e "SELECT COUNT(*) as total_count FROM sim_card;"

# 9. 数据一致性检查
echo "\n9. 数据一致性检查..."
curl -X POST http://localhost:8080/api/v1/disaster-recovery/data-consistency-check \
  -H "Content-Type: application/json" \
  -d '{
    "sourceCenterCode": "DC_SH_SECONDARY",
    "targetCenterCode": "DC_SZ_DR",
    "tables": ["sim_card", "msisdn_pool", "customer"]
  }'

# 10. 恢复原主数据库
echo "\n10. 恢复原主数据库..."
docker start mysql-primary-bj

# 等待数据库启动
sleep 10

# 将原主数据库配置为从数据库
mysql -h localhost -P 3306 -u root -pnsrs123456 -e "
CHANGE MASTER TO
  MASTER_HOST='host.docker.internal',
  MASTER_PORT=3307,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123456',
  MASTER_AUTO_POSITION=1;
START SLAVE;
SHOW SLAVE STATUS\G;
"

# 11. 数据备份和恢复测试
echo "\n11. 数据备份和恢复测试..."

# 创建全量备份
mysqldump -h localhost -P 3307 -u root -pnsrs123456 --single-transaction --routines --triggers nsrs > nsrs_backup_$(date +%Y%m%d_%H%M%S).sql

# 模拟数据恢复
echo "测试数据恢复..."
mysql -h localhost -P 3308 -u root -pnsrs123456 -e "CREATE DATABASE nsrs_recovery;"
mysql -h localhost -P 3308 -u root -pnsrs123456 nsrs_recovery < nsrs_backup_*.sql

# 验证恢复结果
echo "验证恢复结果："
mysql -h localhost -P 3308 -u root -pnsrs123456 nsrs_recovery -e "SELECT COUNT(*) as recovered_count FROM sim_card;"

echo "\n=== 数据库容灾Demo完成 ==="
echo "主要功能验证："
echo "✓ 主从数据库配置"
echo "✓ 实时数据复制"
echo "✓ 主数据库故障切换"
echo "✓ 从数据库提升为主"
echo "✓ 数据一致性检查"
echo "✓ 数据备份和恢复"
```

## 最佳实践总结

### 1. 容灾架构设计原则
- **地理分布**: 数据中心应分布在不同地理区域
- **多层冗余**: 应用层、数据层、网络层都要有冗余
- **自动化程度**: 尽可能实现自动故障检测和切换
- **可扩展性**: 容灾架构应支持水平扩展

### 2. 数据同步策略
- **实时同步**: 关键业务数据实现实时同步
- **批量同步**: 非关键数据可采用批量同步
- **一致性保证**: 确保数据在各中心间的一致性
- **冲突解决**: 建立数据冲突的解决机制

### 3. 故障切换管理
- **自动检测**: 建立完善的健康检查机制
- **快速切换**: 最小化故障切换时间
- **状态同步**: 确保切换后状态的一致性
- **回切策略**: 制定故障恢复后的回切方案

### 4. 容灾演练规范
- **定期演练**: 定期进行容灾演练
- **场景覆盖**: 覆盖各种可能的故障场景
- **结果评估**: 对演练结果进行详细评估
- **持续改进**: 根据演练结果持续改进方案

### 5. 监控和告警
- **全面监控**: 监控所有关键指标
- **及时告警**: 建立多层次告警机制
- **自动响应**: 对常见故障实现自动响应
- **人工干预**: 为复杂故障保留人工干预能力

通过实施以上容灾方案，NSRS号卡资源管理系统能够在面临各种灾难性事件时快速恢复，确保业务连续性和数据安全。