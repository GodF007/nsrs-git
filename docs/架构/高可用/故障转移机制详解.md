# NSRS号卡资源管理系统 - 故障转移机制详解

## 概述

故障转移机制是NSRS号卡资源管理系统高可用架构的核心组件，通过自动检测系统故障并快速切换到备用系统，确保业务连续性和服务可用性。本文档详细阐述了故障转移的设计原理、实现方案和最佳实践。

## 故障转移类型定义

### 故障转移级别枚举

```java
/**
 * 故障转移级别枚举
 * 定义不同级别的故障转移策略
 */
public enum FailoverLevel {
    /**
     * 应用级故障转移
     * 在同一数据中心内的不同应用实例间切换
     */
    APPLICATION_LEVEL("APPLICATION", "应用级故障转移", 1),
    
    /**
     * 服务级故障转移
     * 在不同服务节点间进行切换
     */
    SERVICE_LEVEL("SERVICE", "服务级故障转移", 2),
    
    /**
     * 数据中心级故障转移
     * 在不同数据中心间进行切换
     */
    DATACENTER_LEVEL("DATACENTER", "数据中心级故障转移", 3),
    
    /**
     * 区域级故障转移
     * 在不同地理区域间进行切换
     */
    REGION_LEVEL("REGION", "区域级故障转移", 4);
    
    private final String code;
    private final String description;
    private final int priority;
    
    FailoverLevel(String code, String description, int priority) {
        this.code = code;
        this.description = description;
        this.priority = priority;
    }
    
    // getters...
}
```

### 故障类型枚举

```java
/**
 * 故障类型枚举
 * 定义系统可能遇到的各种故障类型
 */
public enum FailureType {
    /**
     * 硬件故障
     */
    HARDWARE_FAILURE("HARDWARE", "硬件故障", true),
    
    /**
     * 网络故障
     */
    NETWORK_FAILURE("NETWORK", "网络故障", true),
    
    /**
     * 应用程序故障
     */
    APPLICATION_FAILURE("APPLICATION", "应用程序故障", true),
    
    /**
     * 数据库故障
     */
    DATABASE_FAILURE("DATABASE", "数据库故障", true),
    
    /**
     * 存储故障
     */
    STORAGE_FAILURE("STORAGE", "存储故障", true),
    
    /**
     * 电力故障
     */
    POWER_FAILURE("POWER", "电力故障", true),
    
    /**
     * 人为错误
     */
    HUMAN_ERROR("HUMAN", "人为错误", false),
    
    /**
     * 安全攻击
     */
    SECURITY_ATTACK("SECURITY", "安全攻击", true);
    
    private final String code;
    private final String description;
    private final boolean autoFailover;
    
    FailureType(String code, String description, boolean autoFailover) {
        this.code = code;
        this.description = description;
        this.autoFailover = autoFailover;
    }
    
    // getters...
}
```

## 故障转移核心实体

### 故障转移配置实体

```java
/**
 * 故障转移配置实体
 * 定义故障转移的配置参数
 */
@Entity
@Table(name = "failover_config")
public class FailoverConfig {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * 配置名称
     */
    @Column(name = "config_name", nullable = false, length = 100)
    private String configName;
    
    /**
     * 故障转移级别
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "failover_level", nullable = false)
    private FailoverLevel failoverLevel;
    
    /**
     * 主节点标识
     */
    @Column(name = "primary_node", nullable = false, length = 100)
    private String primaryNode;
    
    /**
     * 备用节点列表（JSON格式）
     */
    @Column(name = "backup_nodes", columnDefinition = "TEXT")
    private String backupNodes;
    
    /**
     * 健康检查间隔（秒）
     */
    @Column(name = "health_check_interval")
    private Integer healthCheckInterval = 30;
    
    /**
     * 故障检测阈值
     */
    @Column(name = "failure_threshold")
    private Integer failureThreshold = 3;
    
    /**
     * 自动故障转移开关
     */
    @Column(name = "auto_failover_enabled")
    private Boolean autoFailoverEnabled = true;
    
    /**
     * 故障转移超时时间（秒）
     */
    @Column(name = "failover_timeout")
    private Integer failoverTimeout = 300;
    
    /**
     * 创建时间
     */
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    /**
     * 更新时间
     */
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // constructors, getters, setters...
}
```

### 故障转移记录实体

```java
/**
 * 故障转移记录实体
 * 记录故障转移的历史信息
 */
@Entity
@Table(name = "failover_record")
public class FailoverRecord {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * 故障转移配置ID
     */
    @Column(name = "config_id", nullable = false)
    private Long configId;
    
    /**
     * 故障类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "failure_type", nullable = false)
    private FailureType failureType;
    
    /**
     * 源节点
     */
    @Column(name = "source_node", nullable = false, length = 100)
    private String sourceNode;
    
    /**
     * 目标节点
     */
    @Column(name = "target_node", nullable = false, length = 100)
    private String targetNode;
    
    /**
     * 故障转移状态
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "failover_status", nullable = false)
    private FailoverStatus failoverStatus;
    
    /**
     * 开始时间
     */
    @Column(name = "start_time")
    private LocalDateTime startTime;
    
    /**
     * 结束时间
     */
    @Column(name = "end_time")
    private LocalDateTime endTime;
    
    /**
     * 故障转移耗时（毫秒）
     */
    @Column(name = "duration_ms")
    private Long durationMs;
    
    /**
     * 错误信息
     */
    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;
    
    /**
     * 是否自动触发
     */
    @Column(name = "auto_triggered")
    private Boolean autoTriggered = true;
    
    // constructors, getters, setters...
}
```

### 故障转移状态枚举

```java
/**
 * 故障转移状态枚举
 */
public enum FailoverStatus {
    /**
     * 初始化
     */
    INITIALIZING("INITIALIZING", "初始化"),
    
    /**
     * 进行中
     */
    IN_PROGRESS("IN_PROGRESS", "进行中"),
    
    /**
     * 成功
     */
    SUCCESS("SUCCESS", "成功"),
    
    /**
     * 失败
     */
    FAILED("FAILED", "失败"),
    
    /**
     * 已回滚
     */
    ROLLED_BACK("ROLLED_BACK", "已回滚");
    
    private final String code;
    private final String description;
    
    FailoverStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

## 故障转移管理服务

### 核心故障转移服务

```java
/**
 * 故障转移管理服务
 * 负责故障检测、转移决策和执行
 */
@Service
@Slf4j
public class FailoverManagementService {
    
    @Autowired
    private FailoverConfigRepository failoverConfigRepository;
    
    @Autowired
    private FailoverRecordRepository failoverRecordRepository;
    
    @Autowired
    private HealthCheckService healthCheckService;
    
    @Autowired
    private LoadBalancerService loadBalancerService;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 执行故障转移
     * 
     * @param configId 故障转移配置ID
     * @param failureType 故障类型
     * @param sourceNode 源节点
     * @return 故障转移记录
     */
    @Transactional
    public FailoverRecord executeFailover(Long configId, FailureType failureType, String sourceNode) {
        log.info("开始执行故障转移: configId={}, failureType={}, sourceNode={}", 
                configId, failureType, sourceNode);
        
        // 1. 获取故障转移配置
        FailoverConfig config = failoverConfigRepository.findById(configId)
                .orElseThrow(() -> new RuntimeException("故障转移配置不存在: " + configId));
        
        // 2. 创建故障转移记录
        FailoverRecord record = new FailoverRecord();
        record.setConfigId(configId);
        record.setFailureType(failureType);
        record.setSourceNode(sourceNode);
        record.setFailoverStatus(FailoverStatus.INITIALIZING);
        record.setStartTime(LocalDateTime.now());
        record.setAutoTriggered(true);
        record = failoverRecordRepository.save(record);
        
        try {
            // 3. 选择目标节点
            String targetNode = selectTargetNode(config, sourceNode);
            record.setTargetNode(targetNode);
            record.setFailoverStatus(FailoverStatus.IN_PROGRESS);
            failoverRecordRepository.save(record);
            
            // 4. 执行故障转移
            performFailover(config, sourceNode, targetNode);
            
            // 5. 更新负载均衡器
            updateLoadBalancer(sourceNode, targetNode);
            
            // 6. 验证故障转移结果
            validateFailover(targetNode);
            
            // 7. 更新记录状态
            record.setFailoverStatus(FailoverStatus.SUCCESS);
            record.setEndTime(LocalDateTime.now());
            record.setDurationMs(Duration.between(record.getStartTime(), record.getEndTime()).toMillis());
            
            // 8. 发送通知
            notificationService.sendFailoverNotification(record, "故障转移成功完成");
            
            log.info("故障转移执行成功: {} -> {}, 耗时: {}ms", 
                    sourceNode, targetNode, record.getDurationMs());
            
        } catch (Exception e) {
            log.error("故障转移执行失败", e);
            record.setFailoverStatus(FailoverStatus.FAILED);
            record.setEndTime(LocalDateTime.now());
            record.setErrorMessage(e.getMessage());
            
            // 发送失败通知
            notificationService.sendFailoverNotification(record, "故障转移执行失败: " + e.getMessage());
        }
        
        return failoverRecordRepository.save(record);
    }
    
    /**
     * 选择目标节点
     */
    private String selectTargetNode(FailoverConfig config, String sourceNode) {
        List<String> backupNodes = parseBackupNodes(config.getBackupNodes());
        
        // 排除源节点
        backupNodes.removeIf(node -> node.equals(sourceNode));
        
        if (backupNodes.isEmpty()) {
            throw new RuntimeException("没有可用的备用节点");
        }
        
        // 选择健康的节点
        for (String node : backupNodes) {
            if (healthCheckService.isNodeHealthy(node)) {
                return node;
            }
        }
        
        throw new RuntimeException("所有备用节点都不健康");
    }
    
    /**
     * 执行故障转移操作
     */
    private void performFailover(FailoverConfig config, String sourceNode, String targetNode) {
        switch (config.getFailoverLevel()) {
            case APPLICATION_LEVEL:
                performApplicationFailover(sourceNode, targetNode);
                break;
            case SERVICE_LEVEL:
                performServiceFailover(sourceNode, targetNode);
                break;
            case DATACENTER_LEVEL:
                performDatacenterFailover(sourceNode, targetNode);
                break;
            case REGION_LEVEL:
                performRegionFailover(sourceNode, targetNode);
                break;
            default:
                throw new RuntimeException("不支持的故障转移级别: " + config.getFailoverLevel());
        }
    }
    
    /**
     * 应用级故障转移
     */
    private void performApplicationFailover(String sourceNode, String targetNode) {
        log.info("执行应用级故障转移: {} -> {}", sourceNode, targetNode);
        
        // 1. 停止源节点上的应用
        stopApplication(sourceNode);
        
        // 2. 启动目标节点上的应用
        startApplication(targetNode);
        
        // 3. 同步应用状态
        syncApplicationState(sourceNode, targetNode);
    }
    
    /**
     * 服务级故障转移
     */
    private void performServiceFailover(String sourceNode, String targetNode) {
        log.info("执行服务级故障转移: {} -> {}", sourceNode, targetNode);
        
        // 1. 迁移服务实例
        migrateServiceInstances(sourceNode, targetNode);
        
        // 2. 更新服务注册中心
        updateServiceRegistry(sourceNode, targetNode);
        
        // 3. 重新路由请求
        rerouteRequests(sourceNode, targetNode);
    }
    
    /**
     * 数据中心级故障转移
     */
    private void performDatacenterFailover(String sourceNode, String targetNode) {
        log.info("执行数据中心级故障转移: {} -> {}", sourceNode, targetNode);
        
        // 1. 切换DNS解析
        switchDNSResolution(sourceNode, targetNode);
        
        // 2. 激活备用数据中心
        activateBackupDatacenter(targetNode);
        
        // 3. 同步数据状态
        syncDatacenterState(sourceNode, targetNode);
    }
    
    /**
     * 区域级故障转移
     */
    private void performRegionFailover(String sourceNode, String targetNode) {
        log.info("执行区域级故障转移: {} -> {}", sourceNode, targetNode);
        
        // 1. 切换全局负载均衡
        switchGlobalLoadBalancer(sourceNode, targetNode);
        
        // 2. 激活备用区域
        activateBackupRegion(targetNode);
        
        // 3. 同步全局状态
        syncGlobalState(sourceNode, targetNode);
    }
    
    /**
     * 更新负载均衡器
     */
    private void updateLoadBalancer(String sourceNode, String targetNode) {
        log.info("更新负载均衡器: 移除 {}, 添加 {}", sourceNode, targetNode);
        
        // 从负载均衡器中移除故障节点
        loadBalancerService.removeNode(sourceNode);
        
        // 将目标节点添加到负载均衡器
        loadBalancerService.addNode(targetNode);
        
        // 更新权重配置
        loadBalancerService.updateNodeWeight(targetNode, 100);
    }
    
    /**
     * 验证故障转移结果
     */
    private void validateFailover(String targetNode) {
        log.info("验证故障转移结果: {}", targetNode);
        
        // 检查目标节点健康状态
        if (!healthCheckService.isNodeHealthy(targetNode)) {
            throw new RuntimeException("目标节点不健康: " + targetNode);
        }
        
        // 检查服务可用性
        if (!healthCheckService.isServiceAvailable(targetNode)) {
            throw new RuntimeException("目标节点服务不可用: " + targetNode);
        }
        
        // 检查数据一致性
        if (!healthCheckService.isDataConsistent(targetNode)) {
            throw new RuntimeException("目标节点数据不一致: " + targetNode);
        }
    }
    
    /**
     * 解析备用节点列表
     */
    private List<String> parseBackupNodes(String backupNodesJson) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(backupNodesJson, new TypeReference<List<String>>() {});
        } catch (Exception e) {
            log.error("解析备用节点列表失败", e);
            return new ArrayList<>();
        }
    }
    
    // 其他辅助方法的实现...
    private void stopApplication(String node) { /* 实现应用停止逻辑 */ }
    private void startApplication(String node) { /* 实现应用启动逻辑 */ }
    private void syncApplicationState(String source, String target) { /* 实现状态同步逻辑 */ }
    private void migrateServiceInstances(String source, String target) { /* 实现服务迁移逻辑 */ }
    private void updateServiceRegistry(String source, String target) { /* 实现服务注册更新逻辑 */ }
    private void rerouteRequests(String source, String target) { /* 实现请求重路由逻辑 */ }
    private void switchDNSResolution(String source, String target) { /* 实现DNS切换逻辑 */ }
    private void activateBackupDatacenter(String target) { /* 实现数据中心激活逻辑 */ }
    private void syncDatacenterState(String source, String target) { /* 实现数据中心状态同步逻辑 */ }
    private void switchGlobalLoadBalancer(String source, String target) { /* 实现全局负载均衡切换逻辑 */ }
    private void activateBackupRegion(String target) { /* 实现区域激活逻辑 */ }
    private void syncGlobalState(String source, String target) { /* 实现全局状态同步逻辑 */ }
}
```

## 健康检查服务

### 健康检查实现

```java
/**
 * 健康检查服务
 * 负责监控系统各组件的健康状态
 */
@Service
@Slf4j
public class HealthCheckService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Value("${health.check.timeout:5000}")
    private int healthCheckTimeout;
    
    /**
     * 检查节点是否健康
     * 
     * @param nodeUrl 节点URL
     * @return 是否健康
     */
    public boolean isNodeHealthy(String nodeUrl) {
        try {
            // 1. HTTP健康检查
            if (!checkHttpHealth(nodeUrl)) {
                return false;
            }
            
            // 2. 数据库连接检查
            if (!checkDatabaseHealth(nodeUrl)) {
                return false;
            }
            
            // 3. 缓存连接检查
            if (!checkCacheHealth(nodeUrl)) {
                return false;
            }
            
            // 4. 业务功能检查
            if (!checkBusinessHealth(nodeUrl)) {
                return false;
            }
            
            return true;
            
        } catch (Exception e) {
            log.error("健康检查异常: {}", nodeUrl, e);
            return false;
        }
    }
    
    /**
     * HTTP健康检查
     */
    private boolean checkHttpHealth(String nodeUrl) {
        try {
            String healthUrl = nodeUrl + "/actuator/health";
            
            // 设置超时时间
            restTemplate.getRestTemplate().setRequestFactory(
                new HttpComponentsClientHttpRequestFactory() {{
                    setConnectTimeout(healthCheckTimeout);
                    setReadTimeout(healthCheckTimeout);
                }}
            );
            
            ResponseEntity<Map> response = restTemplate.getForEntity(healthUrl, Map.class);
            
            if (response.getStatusCode() == HttpStatus.OK) {
                Map<String, Object> body = response.getBody();
                return "UP".equals(body.get("status"));
            }
            
            return false;
            
        } catch (Exception e) {
            log.warn("HTTP健康检查失败: {}", nodeUrl, e);
            return false;
        }
    }
    
    /**
     * 数据库健康检查
     */
    private boolean checkDatabaseHealth(String nodeUrl) {
        try {
            String dbHealthUrl = nodeUrl + "/actuator/health/db";
            ResponseEntity<Map> response = restTemplate.getForEntity(dbHealthUrl, Map.class);
            
            if (response.getStatusCode() == HttpStatus.OK) {
                Map<String, Object> body = response.getBody();
                return "UP".equals(body.get("status"));
            }
            
            return false;
            
        } catch (Exception e) {
            log.warn("数据库健康检查失败: {}", nodeUrl, e);
            return false;
        }
    }
    
    /**
     * 缓存健康检查
     */
    private boolean checkCacheHealth(String nodeUrl) {
        try {
            String cacheHealthUrl = nodeUrl + "/actuator/health/redis";
            ResponseEntity<Map> response = restTemplate.getForEntity(cacheHealthUrl, Map.class);
            
            if (response.getStatusCode() == HttpStatus.OK) {
                Map<String, Object> body = response.getBody();
                return "UP".equals(body.get("status"));
            }
            
            return false;
            
        } catch (Exception e) {
            log.warn("缓存健康检查失败: {}", nodeUrl, e);
            return false;
        }
    }
    
    /**
     * 业务功能健康检查
     */
    private boolean checkBusinessHealth(String nodeUrl) {
        try {
            // 检查核心业务接口
            String businessHealthUrl = nodeUrl + "/api/health/business";
            ResponseEntity<Map> response = restTemplate.getForEntity(businessHealthUrl, Map.class);
            
            if (response.getStatusCode() == HttpStatus.OK) {
                Map<String, Object> body = response.getBody();
                return "HEALTHY".equals(body.get("status"));
            }
            
            return false;
            
        } catch (Exception e) {
            log.warn("业务功能健康检查失败: {}", nodeUrl, e);
            return false;
        }
    }
    
    /**
     * 检查服务是否可用
     */
    public boolean isServiceAvailable(String nodeUrl) {
        try {
            // 测试关键业务接口
            String testUrl = nodeUrl + "/api/sim-card/test";
            ResponseEntity<String> response = restTemplate.getForEntity(testUrl, String.class);
            
            return response.getStatusCode() == HttpStatus.OK;
            
        } catch (Exception e) {
            log.warn("服务可用性检查失败: {}", nodeUrl, e);
            return false;
        }
    }
    
    /**
     * 检查数据一致性
     */
    public boolean isDataConsistent(String nodeUrl) {
        try {
            // 检查数据同步状态
            String syncStatusUrl = nodeUrl + "/api/data/sync-status";
            ResponseEntity<Map> response = restTemplate.getForEntity(syncStatusUrl, Map.class);
            
            if (response.getStatusCode() == HttpStatus.OK) {
                Map<String, Object> body = response.getBody();
                return "SYNCED".equals(body.get("status"));
            }
            
            return false;
            
        } catch (Exception e) {
            log.warn("数据一致性检查失败: {}", nodeUrl, e);
            return false;
        }
    }
    
    /**
     * 获取节点性能指标
     */
    public Map<String, Object> getNodeMetrics(String nodeUrl) {
        try {
            String metricsUrl = nodeUrl + "/actuator/metrics";
            ResponseEntity<Map> response = restTemplate.getForEntity(metricsUrl, Map.class);
            
            if (response.getStatusCode() == HttpStatus.OK) {
                return response.getBody();
            }
            
            return new HashMap<>();
            
        } catch (Exception e) {
            log.warn("获取节点性能指标失败: {}", nodeUrl, e);
            return new HashMap<>();
        }
    }
}
```

## Demo脚本示例

### 故障转移Demo脚本

```bash
#!/bin/bash

# NSRS故障转移机制Demo脚本
# 演示应用级和服务级故障转移

echo "=== NSRS故障转移机制Demo ==="
echo "演示场景：应用级故障转移和服务级故障转移"
echo

# 1. 启动多个应用实例
echo "1. 启动多个应用实例..."

# 启动主应用实例（端口8080）
echo "启动主应用实例（端口8080）..."
docker run -d --name nsrs-primary \
  -p 8080:8080 \
  -e SERVER_PORT=8080 \
  -e SPRING_PROFILES_ACTIVE=primary \
  -e MYSQL_URL=jdbc:mysql://host.docker.internal:3306/nsrs \
  -e REDIS_HOST=host.docker.internal \
  -e REDIS_PORT=6379 \
  nsrs:latest

# 启动备用应用实例（端口8081）
echo "启动备用应用实例（端口8081）..."
docker run -d --name nsrs-backup1 \
  -p 8081:8080 \
  -e SERVER_PORT=8080 \
  -e SPRING_PROFILES_ACTIVE=backup \
  -e MYSQL_URL=jdbc:mysql://host.docker.internal:3306/nsrs \
  -e REDIS_HOST=host.docker.internal \
  -e REDIS_PORT=6379 \
  nsrs:latest

# 启动第二个备用应用实例（端口8082）
echo "启动第二个备用应用实例（端口8082）..."
docker run -d --name nsrs-backup2 \
  -p 8082:8080 \
  -e SERVER_PORT=8080 \
  -e SPRING_PROFILES_ACTIVE=backup \
  -e MYSQL_URL=jdbc:mysql://host.docker.internal:3306/nsrs \
  -e REDIS_HOST=host.docker.internal \
  -e REDIS_PORT=6379 \
  nsrs:latest

# 等待应用启动
echo "等待应用启动..."
sleep 30

# 2. 配置Nginx负载均衡器
echo "\n2. 配置Nginx负载均衡器..."

# 创建Nginx配置文件
cat > nginx.conf << 'EOF'
events {
    worker_connections 1024;
}

http {
    upstream nsrs_backend {
        server host.docker.internal:8080 weight=3;
        server host.docker.internal:8081 weight=1 backup;
        server host.docker.internal:8082 weight=1 backup;
    }
    
    server {
        listen 80;
        
        location / {
            proxy_pass http://nsrs_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            
            # 健康检查配置
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;
        }
        
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}
EOF

# 启动Nginx负载均衡器
echo "启动Nginx负载均衡器..."
docker run -d --name nsrs-nginx \
  -p 80:80 \
  -v $(pwd)/nginx.conf:/etc/nginx/nginx.conf:ro \
  nginx:alpine

# 3. 验证初始状态
echo "\n3. 验证初始状态..."

# 检查所有实例健康状态
echo "检查应用实例健康状态："
for port in 8080 8081 8082; do
    echo -n "端口 $port: "
    curl -s http://localhost:$port/actuator/health | jq -r '.status' 2>/dev/null || echo "不可用"
done

# 测试负载均衡
echo "\n测试负载均衡（发送10个请求）："
for i in {1..10}; do
    echo -n "请求 $i: "
    curl -s http://localhost/api/sim-card/test 2>/dev/null || echo "失败"
done

# 4. 模拟主应用故障
echo "\n4. 模拟主应用故障..."
echo "停止主应用实例（端口8080）..."
docker stop nsrs-primary

# 等待故障检测
echo "等待故障检测和自动切换..."
sleep 10

# 5. 验证故障转移
echo "\n5. 验证故障转移..."

# 检查应用实例状态
echo "检查应用实例状态："
for port in 8080 8081 8082; do
    echo -n "端口 $port: "
    curl -s http://localhost:$port/actuator/health | jq -r '.status' 2>/dev/null || echo "不可用"
done

# 测试服务可用性
echo "\n测试服务可用性（发送10个请求）："
for i in {1..10}; do
    echo -n "请求 $i: "
    response=$(curl -s http://localhost/api/sim-card/test 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "成功 - $response"
    else
        echo "失败"
    fi
done

# 6. 模拟第一个备用实例故障
echo "\n6. 模拟第一个备用实例故障..."
echo "停止第一个备用实例（端口8081）..."
docker stop nsrs-backup1

# 等待故障检测
echo "等待故障检测..."
sleep 5

# 7. 验证二级故障转移
echo "\n7. 验证二级故障转移..."

# 检查剩余实例状态
echo "检查剩余实例状态："
for port in 8080 8081 8082; do
    echo -n "端口 $port: "
    curl -s http://localhost:$port/actuator/health | jq -r '.status' 2>/dev/null || echo "不可用"
done

# 测试服务可用性
echo "\n测试服务可用性（发送5个请求）："
for i in {1..5}; do
    echo -n "请求 $i: "
    response=$(curl -s http://localhost/api/sim-card/test 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "成功 - $response"
    else
        echo "失败"
    fi
done

# 8. 恢复主应用实例
echo "\n8. 恢复主应用实例..."
echo "重启主应用实例..."
docker start nsrs-primary

# 等待应用启动
echo "等待应用启动..."
sleep 20

# 9. 验证故障恢复
echo "\n9. 验证故障恢复..."

# 检查所有实例状态
echo "检查所有实例状态："
for port in 8080 8081 8082; do
    echo -n "端口 $port: "
    curl -s http://localhost:$port/actuator/health | jq -r '.status' 2>/dev/null || echo "不可用"
done

# 测试负载分布
echo "\n测试负载分布（发送20个请求）："
for i in {1..20}; do
    echo -n "请求 $i: "
    response=$(curl -s http://localhost/api/sim-card/test 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "成功"
    else
        echo "失败"
    fi
done

# 10. 故障转移统计
echo "\n10. 故障转移统计..."
echo "获取故障转移记录："
curl -s http://localhost:8082/api/failover/records | jq '.' 2>/dev/null || echo "无法获取记录"

echo "\n=== 故障转移Demo完成 ==="
echo "主要功能验证："
echo "✓ 多实例部署"
echo "✓ 负载均衡配置"
echo "✓ 主实例故障检测"
echo "✓ 自动故障转移"
echo "✓ 备用实例激活"
echo "✓ 服务连续性保证"
echo "✓ 故障恢复处理"
```

### 数据库故障转移Demo

```bash
#!/bin/bash

# 数据库故障转移Demo脚本
# 演示数据库主从切换和读写分离故障转移

echo "=== 数据库故障转移Demo ==="
echo "演示场景：MySQL主从切换和读写分离故障转移"
echo

# 1. 启动MySQL主从集群
echo "1. 启动MySQL主从集群..."

# 启动主数据库
echo "启动主数据库（端口3306）..."
docker run -d --name mysql-master \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=nsrs123456 \
  -e MYSQL_DATABASE=nsrs \
  -e MYSQL_USER=nsrs \
  -e MYSQL_PASSWORD=nsrs123456 \
  -v mysql_master_data:/var/lib/mysql \
  mysql:8.0 \
  --server-id=1 \
  --log-bin=mysql-bin \
  --binlog-format=ROW

# 启动从数据库1
echo "启动从数据库1（端口3307）..."
docker run -d --name mysql-slave1 \
  -p 3307:3306 \
  -e MYSQL_ROOT_PASSWORD=nsrs123456 \
  -e MYSQL_DATABASE=nsrs \
  -e MYSQL_USER=nsrs \
  -e MYSQL_PASSWORD=nsrs123456 \
  -v mysql_slave1_data:/var/lib/mysql \
  mysql:8.0 \
  --server-id=2 \
  --relay-log=mysql-relay-bin

# 启动从数据库2
echo "启动从数据库2（端口3308）..."
docker run -d --name mysql-slave2 \
  -p 3308:3306 \
  -e MYSQL_ROOT_PASSWORD=nsrs123456 \
  -e MYSQL_DATABASE=nsrs \
  -e MYSQL_USER=nsrs \
  -e MYSQL_PASSWORD=nsrs123456 \
  -v mysql_slave2_data:/var/lib/mysql \
  mysql:8.0 \
  --server-id=3 \
  --relay-log=mysql-relay-bin

# 等待数据库启动
echo "等待数据库启动..."
sleep 30

# 2. 配置主从复制
echo "\n2. 配置主从复制..."

# 在主数据库创建复制用户
echo "在主数据库创建复制用户..."
mysql -h localhost -P 3306 -u root -pnsrs123456 -e "
CREATE USER 'repl'@'%' IDENTIFIED BY 'repl123456';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;
SHOW MASTER STATUS;
"

# 配置从数据库1
echo "配置从数据库1..."
mysql -h localhost -P 3307 -u root -pnsrs123456 -e "
CHANGE MASTER TO
  MASTER_HOST='host.docker.internal',
  MASTER_PORT=3306,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123456',
  MASTER_AUTO_POSITION=1;
START SLAVE;
SHOW SLAVE STATUS\G;
"

# 配置从数据库2
echo "配置从数据库2..."
mysql -h localhost -P 3308 -u root -pnsrs123456 -e "
CHANGE MASTER TO
  MASTER_HOST='host.docker.internal',
  MASTER_PORT=3306,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123456',
  MASTER_AUTO_POSITION=1;
START SLAVE;
SHOW SLAVE STATUS\G;
"

# 3. 初始化测试数据
echo "\n3. 初始化测试数据..."

# 在主数据库创建测试表和数据
mysql -h localhost -P 3306 -u root -pnsrs123456 nsrs << 'EOF'
CREATE TABLE IF NOT EXISTS failover_test (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    test_data VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO failover_test (test_data) VALUES 
('Initial data 1'),
('Initial data 2'),
('Initial data 3');
EOF

# 等待数据同步
echo "等待数据同步..."
sleep 5

# 4. 验证主从同步
echo "\n4. 验证主从同步..."

# 检查各数据库的数据
echo "主数据库数据："
mysql -h localhost -P 3306 -u root -pnsrs123456 nsrs -e "SELECT COUNT(*) as count FROM failover_test;"

echo "从数据库1数据："
mysql -h localhost -P 3307 -u root -pnsrs123456 nsrs -e "SELECT COUNT(*) as count FROM failover_test;"

echo "从数据库2数据："
mysql -h localhost -P 3308 -u root -pnsrs123456 nsrs -e "SELECT COUNT(*) as count FROM failover_test;"

# 5. 配置ProxySQL读写分离
echo "\n5. 配置ProxySQL读写分离..."

# 启动ProxySQL
echo "启动ProxySQL..."
docker run -d --name proxysql \
  -p 6032:6032 \
  -p 6033:6033 \
  -v $(pwd)/proxysql.cnf:/etc/proxysql.cnf \
  proxysql/proxysql:latest

# 创建ProxySQL配置文件
cat > proxysql.cnf << 'EOF'
datadir="/var/lib/proxysql"

admin_variables=
{
    admin_credentials="admin:admin"
    mysql_ifaces="0.0.0.0:6032"
}

mysql_variables=
{
    threads=4
    max_connections=2048
    default_query_delay=0
    default_query_timeout=36000000
    have_compress=true
    poll_timeout=2000
    interfaces="0.0.0.0:6033"
    default_schema="nsrs"
    stacksize=1048576
    server_version="8.0.0"
    connect_timeout_server=3000
    monitor_username="monitor"
    monitor_password="monitor"
    monitor_history=600000
    monitor_connect_interval=60000
    monitor_ping_interval=10000
    monitor_read_only_interval=1500
    monitor_read_only_timeout=500
    ping_interval_server_msec=120000
    ping_timeout_server=500
    commands_stats=true
    sessions_sort=true
    connect_retries_on_failure=10
}

mysql_servers =
(
    {
        address = "host.docker.internal"
        port = 3306
        hostgroup = 0
        weight = 1000
        comment = "Master"
    },
    {
        address = "host.docker.internal"
        port = 3307
        hostgroup = 1
        weight = 900
        comment = "Slave1"
    },
    {
        address = "host.docker.internal"
        port = 3308
        hostgroup = 1
        weight = 900
        comment = "Slave2"
    }
)

mysql_users:
(
    {
        username = "nsrs"
        password = "nsrs123456"
        default_hostgroup = 0
        max_connections=1000
        default_schema="nsrs"
        active = 1
    }
)

mysql_query_rules:
(
    {
        rule_id=1
        active=1
        match_pattern="^SELECT.*FOR UPDATE$"
        destination_hostgroup=0
        apply=1
    },
    {
        rule_id=2
        active=1
        match_pattern="^SELECT"
        destination_hostgroup=1
        apply=1
    }
)
EOF

# 等待ProxySQL启动
echo "等待ProxySQL启动..."
sleep 10

# 6. 测试读写分离
echo "\n6. 测试读写分离..."

# 通过ProxySQL写入数据
echo "通过ProxySQL写入数据..."
mysql -h localhost -P 6033 -u nsrs -pnsrs123456 nsrs -e "
INSERT INTO failover_test (test_data) VALUES ('ProxySQL write test');
"

# 通过ProxySQL读取数据
echo "通过ProxySQL读取数据："
mysql -h localhost -P 6033 -u nsrs -pnsrs123456 nsrs -e "SELECT * FROM failover_test ORDER BY id DESC LIMIT 5;"

# 7. 模拟主数据库故障
echo "\n7. 模拟主数据库故障..."
echo "停止主数据库..."
docker stop mysql-master

# 等待故障检测
echo "等待故障检测..."
sleep 10

# 8. 执行主从切换
echo "\n8. 执行主从切换..."
echo "将从数据库1提升为主数据库..."

# 停止从数据库1的复制
mysql -h localhost -P 3307 -u root -pnsrs123456 -e "STOP SLAVE;"

# 重置从数据库1为主数据库
mysql -h localhost -P 3307 -u root -pnsrs123456 -e "RESET MASTER;"

# 配置从数据库2指向新的主数据库
mysql -h localhost -P 3308 -u root -pnsrs123456 -e "
STOP SLAVE;
CHANGE MASTER TO
  MASTER_HOST='host.docker.internal',
  MASTER_PORT=3307,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123456',
  MASTER_AUTO_POSITION=1;
START SLAVE;
SHOW SLAVE STATUS\G;
"

# 9. 更新ProxySQL配置
echo "\n9. 更新ProxySQL配置..."
echo "更新ProxySQL服务器配置..."

# 通过ProxySQL管理接口更新配置
mysql -h localhost -P 6032 -u admin -padmin << 'EOF'
UPDATE mysql_servers SET hostgroup=0 WHERE address='host.docker.internal' AND port=3307;
UPDATE mysql_servers SET hostgroup=2 WHERE address='host.docker.internal' AND port=3306;
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
EOF

# 10. 验证故障转移
echo "\n10. 验证故障转移..."

# 测试写入新主数据库
echo "测试写入新主数据库..."
mysql -h localhost -P 6033 -u nsrs -pnsrs123456 nsrs -e "
INSERT INTO failover_test (test_data) VALUES ('After failover write test');
"

# 验证数据一致性
echo "验证数据一致性："
echo "新主数据库（原从数据库1）数据："
mysql -h localhost -P 3307 -u root -pnsrs123456 nsrs -e "SELECT COUNT(*) as count FROM failover_test;"

echo "从数据库2数据："
mysql -h localhost -P 3308 -u root -pnsrs123456 nsrs -e "SELECT COUNT(*) as count FROM failover_test;"

# 通过ProxySQL读取数据
echo "通过ProxySQL读取数据："
mysql -h localhost -P 6033 -u nsrs -pnsrs123456 nsrs -e "SELECT * FROM failover_test ORDER BY id DESC LIMIT 3;"

echo "\n=== 数据库故障转移Demo完成 ==="
echo "主要功能验证："
echo "✓ MySQL主从复制配置"
echo "✓ ProxySQL读写分离"
echo "✓ 主数据库故障检测"
echo "✓ 从数据库提升为主"
echo "✓ 复制关系重新配置"
echo "✓ ProxySQL配置更新"
echo "✓ 数据一致性验证"
```