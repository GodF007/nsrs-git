# 故障转移机制设计指南

## 概述

本文档详细描述NSRS号卡资源管理系统的故障转移机制，包括自动故障检测、快速切换、数据一致性保障和服务恢复等关键环节。

## 故障转移架构

### 1. 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    故障转移控制中心                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 健康检查器   │  │ 决策引擎     │  │ 切换执行器   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
    ┌─────────▼─────────┐ ┌───▼────┐ ┌────────▼────────┐
    │   数据库层故障转移  │ │ 应用层  │ │   网络层故障转移  │
    │                  │ │ 故障转移 │ │                │
    │ ┌──────┐┌──────┐ │ │        │ │ ┌──────┐┌──────┐│
    │ │ 主库 ││ 从库 │ │ │ ┌────┐ │ │ │ 主线 ││ 备线 ││
    │ └──────┘└──────┘ │ │ │Pod │ │ │ └──────┘└──────┘│
    └───────────────────┘ │ └────┘ │ └─────────────────┘
                          └────────┘
```

### 2. 故障检测机制

#### 多层次健康检查
```java
/**
 * 综合健康检查服务
 */
@Service
@Slf4j
public class HealthCheckService {
    
    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private RestTemplate restTemplate;
    
    // 健康检查结果缓存
    private final Map<String, HealthStatus> healthCache = new ConcurrentHashMap<>();
    
    // 故障计数器
    private final Map<String, AtomicInteger> failureCounters = new ConcurrentHashMap<>();
    
    /**
     * 数据库健康检查
     */
    public HealthStatus checkDatabaseHealth() {
        String component = "database";
        try {
            long startTime = System.currentTimeMillis();
            
            // 执行简单查询测试连接
            try (Connection connection = dataSource.getConnection();
                 PreparedStatement stmt = connection.prepareStatement("SELECT 1");
                 ResultSet rs = stmt.executeQuery()) {
                
                long responseTime = System.currentTimeMillis() - startTime;
                
                if (responseTime > 5000) { // 响应时间超过5秒认为异常
                    return recordFailure(component, "Database response time too high: " + responseTime + "ms");
                }
                
                // 检查连接池状态
                HikariDataSource hikariDS = (HikariDataSource) dataSource;
                int activeConnections = hikariDS.getHikariPoolMXBean().getActiveConnections();
                int totalConnections = hikariDS.getHikariPoolMXBean().getTotalConnections();
                
                if (activeConnections >= totalConnections * 0.9) {
                    log.warn("Database connection pool usage high: {}/{}", activeConnections, totalConnections);
                }
                
                return recordSuccess(component, Map.of(
                    "responseTime", responseTime,
                    "activeConnections", activeConnections,
                    "totalConnections", totalConnections
                ));
            }
            
        } catch (Exception e) {
            return recordFailure(component, "Database connection failed: " + e.getMessage());
        }
    }
    
    /**
     * Redis健康检查
     */
    public HealthStatus checkRedisHealth() {
        String component = "redis";
        try {
            long startTime = System.currentTimeMillis();
            
            // 执行ping命令
            String pong = redisTemplate.execute((RedisCallback<String>) connection -> {
                return connection.ping();
            });
            
            long responseTime = System.currentTimeMillis() - startTime;
            
            if (!"PONG".equals(pong)) {
                return recordFailure(component, "Redis ping failed: " + pong);
            }
            
            if (responseTime > 1000) { // 响应时间超过1秒认为异常
                return recordFailure(component, "Redis response time too high: " + responseTime + "ms");
            }
            
            // 检查内存使用情况
            Properties info = redisTemplate.execute((RedisCallback<Properties>) connection -> {
                return connection.info("memory");
            });
            
            String usedMemory = info.getProperty("used_memory");
            String maxMemory = info.getProperty("maxmemory");
            
            return recordSuccess(component, Map.of(
                "responseTime", responseTime,
                "usedMemory", usedMemory,
                "maxMemory", maxMemory
            ));
            
        } catch (Exception e) {
            return recordFailure(component, "Redis health check failed: " + e.getMessage());
        }
    }
    
    /**
     * 应用服务健康检查
     */
    public HealthStatus checkApplicationHealth() {
        String component = "application";
        try {
            long startTime = System.currentTimeMillis();
            
            // 检查关键业务接口
            ResponseEntity<String> response = restTemplate.getForEntity(
                "http://localhost:8080/api/sim-cards/health-check", String.class);
            
            long responseTime = System.currentTimeMillis() - startTime;
            
            if (response.getStatusCode() != HttpStatus.OK) {
                return recordFailure(component, "Application health check failed: " + response.getStatusCode());
            }
            
            if (responseTime > 3000) { // 响应时间超过3秒认为异常
                return recordFailure(component, "Application response time too high: " + responseTime + "ms");
            }
            
            // 检查JVM状态
            MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
            MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
            
            double heapUsagePercent = (double) heapUsage.getUsed() / heapUsage.getMax() * 100;
            
            if (heapUsagePercent > 90) {
                log.warn("JVM heap usage high: {}%", heapUsagePercent);
            }
            
            return recordSuccess(component, Map.of(
                "responseTime", responseTime,
                "heapUsagePercent", heapUsagePercent,
                "heapUsed", heapUsage.getUsed(),
                "heapMax", heapUsage.getMax()
            ));
            
        } catch (Exception e) {
            return recordFailure(component, "Application health check failed: " + e.getMessage());
        }
    }
    
    /**
     * 网络连通性检查
     */
    public HealthStatus checkNetworkHealth() {
        String component = "network";
        try {
            List<String> testHosts = Arrays.asList("8.8.8.8", "114.114.114.114", "223.5.5.5");
            int successCount = 0;
            long totalResponseTime = 0;
            
            for (String host : testHosts) {
                try {
                    long startTime = System.currentTimeMillis();
                    
                    // 使用Java实现ping功能
                    InetAddress address = InetAddress.getByName(host);
                    boolean reachable = address.isReachable(5000);
                    
                    long responseTime = System.currentTimeMillis() - startTime;
                    
                    if (reachable) {
                        successCount++;
                        totalResponseTime += responseTime;
                    }
                    
                } catch (Exception e) {
                    log.debug("Network test failed for host: {}", host, e);
                }
            }
            
            if (successCount == 0) {
                return recordFailure(component, "All network connectivity tests failed");
            }
            
            double successRate = (double) successCount / testHosts.size() * 100;
            long avgResponseTime = totalResponseTime / Math.max(successCount, 1);
            
            if (successRate < 50) {
                return recordFailure(component, "Network connectivity success rate too low: " + successRate + "%");
            }
            
            return recordSuccess(component, Map.of(
                "successRate", successRate,
                "avgResponseTime", avgResponseTime,
                "successCount", successCount,
                "totalTests", testHosts.size()
            ));
            
        } catch (Exception e) {
            return recordFailure(component, "Network health check failed: " + e.getMessage());
        }
    }
    
    /**
     * 记录成功状态
     */
    private HealthStatus recordSuccess(String component, Map<String, Object> metrics) {
        failureCounters.computeIfAbsent(component, k -> new AtomicInteger(0)).set(0);
        
        HealthStatus status = HealthStatus.builder()
            .component(component)
            .status("UP")
            .timestamp(Instant.now())
            .metrics(metrics)
            .build();
        
        healthCache.put(component, status);
        log.debug("Health check passed for component: {}", component);
        
        return status;
    }
    
    /**
     * 记录失败状态
     */
    private HealthStatus recordFailure(String component, String error) {
        int failureCount = failureCounters.computeIfAbsent(component, k -> new AtomicInteger(0))
            .incrementAndGet();
        
        HealthStatus status = HealthStatus.builder()
            .component(component)
            .status("DOWN")
            .timestamp(Instant.now())
            .error(error)
            .failureCount(failureCount)
            .build();
        
        healthCache.put(component, status);
        log.error("Health check failed for component: {} (failure count: {}), error: {}", 
                 component, failureCount, error);
        
        // 如果连续失败次数达到阈值，触发故障转移
        if (failureCount >= getFailureThreshold(component)) {
            triggerFailover(component, status);
        }
        
        return status;
    }
    
    /**
     * 获取故障阈值
     */
    private int getFailureThreshold(String component) {
        switch (component) {
            case "database":
                return 3; // 数据库连续失败3次触发故障转移
            case "redis":
                return 5; // Redis连续失败5次触发故障转移
            case "application":
                return 3; // 应用连续失败3次触发故障转移
            case "network":
                return 2; // 网络连续失败2次触发故障转移
            default:
                return 3;
        }
    }
    
    /**
     * 触发故障转移
     */
    private void triggerFailover(String component, HealthStatus status) {
        log.error("Triggering failover for component: {}", component);
        
        // 发布故障转移事件
        ApplicationEventPublisher eventPublisher = 
            ApplicationContextHolder.getApplicationContext();
        eventPublisher.publishEvent(new FailoverTriggeredEvent(component, status));
    }
    
    /**
     * 综合健康检查
     */
    @Scheduled(fixedDelay = 30000) // 每30秒执行一次
    public void performHealthCheck() {
        log.debug("Starting comprehensive health check");
        
        CompletableFuture<HealthStatus> dbCheck = CompletableFuture.supplyAsync(this::checkDatabaseHealth);
        CompletableFuture<HealthStatus> redisCheck = CompletableFuture.supplyAsync(this::checkRedisHealth);
        CompletableFuture<HealthStatus> appCheck = CompletableFuture.supplyAsync(this::checkApplicationHealth);
        CompletableFuture<HealthStatus> networkCheck = CompletableFuture.supplyAsync(this::checkNetworkHealth);
        
        try {
            CompletableFuture.allOf(dbCheck, redisCheck, appCheck, networkCheck)
                .get(30, TimeUnit.SECONDS);
            
            log.debug("Comprehensive health check completed");
            
        } catch (Exception e) {
            log.error("Health check execution failed", e);
        }
    }
    
    /**
     * 获取当前健康状态
     */
    public Map<String, HealthStatus> getCurrentHealthStatus() {
        return new HashMap<>(healthCache);
    }
}

/**
 * 健康状态实体
 */
@Data
@Builder
public class HealthStatus {
    private String component;
    private String status; // UP, DOWN, DEGRADED
    private Instant timestamp;
    private String error;
    private Map<String, Object> metrics;
    private int failureCount;
}

/**
 * 故障转移触发事件
 */
public class FailoverTriggeredEvent extends ApplicationEvent {
    private final String component;
    private final HealthStatus healthStatus;
    
    public FailoverTriggeredEvent(String component, HealthStatus healthStatus) {
        super(component);
        this.component = component;
        this.healthStatus = healthStatus;
    }
    
    public String getComponent() {
        return component;
    }
    
    public HealthStatus getHealthStatus() {
        return healthStatus;
    }
}
```

### 3. 故障转移决策引擎

#### 智能决策服务
```java
/**
 * 故障转移决策引擎
 */
@Service
@Slf4j
public class FailoverDecisionEngine {
    
    @Autowired
    private HealthCheckService healthCheckService;
    
    @Autowired
    private FailoverExecutorService failoverExecutorService;
    
    // 决策规则配置
    private final Map<String, FailoverRule> failoverRules = new HashMap<>();
    
    @PostConstruct
    public void initializeRules() {
        // 数据库故障转移规则
        failoverRules.put("database", FailoverRule.builder()
            .component("database")
            .failureThreshold(3)
            .recoveryThreshold(2)
            .cooldownPeriod(Duration.ofMinutes(5))
            .autoFailback(true)
            .priority(1) // 最高优先级
            .build());
        
        // Redis故障转移规则
        failoverRules.put("redis", FailoverRule.builder()
            .component("redis")
            .failureThreshold(5)
            .recoveryThreshold(3)
            .cooldownPeriod(Duration.ofMinutes(2))
            .autoFailback(true)
            .priority(2)
            .build());
        
        // 应用故障转移规则
        failoverRules.put("application", FailoverRule.builder()
            .component("application")
            .failureThreshold(3)
            .recoveryThreshold(2)
            .cooldownPeriod(Duration.ofMinutes(3))
            .autoFailback(true)
            .priority(3)
            .build());
        
        // 网络故障转移规则
        failoverRules.put("network", FailoverRule.builder()
            .component("network")
            .failureThreshold(2)
            .recoveryThreshold(1)
            .cooldownPeriod(Duration.ofMinutes(1))
            .autoFailback(false) // 网络故障不自动回切
            .priority(4)
            .build());
    }
    
    /**
     * 处理故障转移事件
     */
    @EventListener
    @Async("failoverExecutor")
    public void handleFailoverEvent(FailoverTriggeredEvent event) {
        String component = event.getComponent();
        HealthStatus healthStatus = event.getHealthStatus();
        
        log.info("Processing failover event for component: {}", component);
        
        FailoverRule rule = failoverRules.get(component);
        if (rule == null) {
            log.warn("No failover rule found for component: {}", component);
            return;
        }
        
        // 检查是否满足故障转移条件
        if (shouldTriggerFailover(component, healthStatus, rule)) {
            executeFailover(component, rule);
        }
    }
    
    /**
     * 判断是否应该触发故障转移
     */
    private boolean shouldTriggerFailover(String component, HealthStatus healthStatus, FailoverRule rule) {
        // 检查故障次数是否达到阈值
        if (healthStatus.getFailureCount() < rule.getFailureThreshold()) {
            log.debug("Failure count {} below threshold {} for component: {}", 
                     healthStatus.getFailureCount(), rule.getFailureThreshold(), component);
            return false;
        }
        
        // 检查冷却期
        Instant lastFailover = getLastFailoverTime(component);
        if (lastFailover != null && 
            Duration.between(lastFailover, Instant.now()).compareTo(rule.getCooldownPeriod()) < 0) {
            log.debug("Component {} is in cooldown period", component);
            return false;
        }
        
        // 检查依赖组件状态
        if (!checkDependencyHealth(component)) {
            log.warn("Dependency health check failed for component: {}", component);
            return false;
        }
        
        // 检查系统负载
        if (!checkSystemLoad()) {
            log.warn("System load too high, delaying failover for component: {}", component);
            return false;
        }
        
        return true;
    }
    
    /**
     * 执行故障转移
     */
    private void executeFailover(String component, FailoverRule rule) {
        log.info("Executing failover for component: {}", component);
        
        try {
            // 记录故障转移开始时间
            recordFailoverStart(component);
            
            // 根据组件类型执行相应的故障转移逻辑
            switch (component) {
                case "database":
                    failoverExecutorService.executeDatabaseFailover();
                    break;
                case "redis":
                    failoverExecutorService.executeRedisFailover();
                    break;
                case "application":
                    failoverExecutorService.executeApplicationFailover();
                    break;
                case "network":
                    failoverExecutorService.executeNetworkFailover();
                    break;
                default:
                    log.error("Unknown component type for failover: {}", component);
                    return;
            }
            
            // 记录故障转移完成
            recordFailoverComplete(component);
            
            // 发送通知
            sendFailoverNotification(component, "SUCCESS");
            
            // 如果支持自动回切，启动监控
            if (rule.isAutoFailback()) {
                startFailbackMonitoring(component, rule);
            }
            
        } catch (Exception e) {
            log.error("Failover execution failed for component: {}", component, e);
            recordFailoverFailure(component, e.getMessage());
            sendFailoverNotification(component, "FAILED");
        }
    }
    
    /**
     * 检查依赖组件健康状态
     */
    private boolean checkDependencyHealth(String component) {
        Map<String, HealthStatus> healthStatus = healthCheckService.getCurrentHealthStatus();
        
        switch (component) {
            case "application":
                // 应用依赖数据库和Redis
                HealthStatus dbStatus = healthStatus.get("database");
                HealthStatus redisStatus = healthStatus.get("redis");
                return (dbStatus == null || "UP".equals(dbStatus.getStatus())) &&
                       (redisStatus == null || "UP".equals(redisStatus.getStatus()));
            
            case "database":
                // 数据库依赖网络
                HealthStatus networkStatus = healthStatus.get("network");
                return networkStatus == null || "UP".equals(networkStatus.getStatus());
            
            default:
                return true; // 其他组件暂不检查依赖
        }
    }
    
    /**
     * 检查系统负载
     */
    private boolean checkSystemLoad() {
        try {
            OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
            double cpuLoad = osBean.getProcessCpuLoad();
            
            MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
            MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
            double memoryUsage = (double) heapUsage.getUsed() / heapUsage.getMax();
            
            // CPU使用率超过90%或内存使用率超过95%时延迟故障转移
            if (cpuLoad > 0.9 || memoryUsage > 0.95) {
                log.warn("High system load detected - CPU: {}%, Memory: {}%", 
                        cpuLoad * 100, memoryUsage * 100);
                return false;
            }
            
            return true;
            
        } catch (Exception e) {
            log.warn("Failed to check system load", e);
            return true; // 检查失败时允许故障转移
        }
    }
    
    /**
     * 启动故障回切监控
     */
    @Async("failoverExecutor")
    public void startFailbackMonitoring(String component, FailoverRule rule) {
        log.info("Starting failback monitoring for component: {}", component);
        
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        
        scheduler.scheduleWithFixedDelay(() -> {
            try {
                if (shouldTriggerFailback(component, rule)) {
                    executeFailback(component);
                    scheduler.shutdown();
                }
            } catch (Exception e) {
                log.error("Failback monitoring error for component: {}", component, e);
            }
        }, 60, 30, TimeUnit.SECONDS); // 1分钟后开始，每30秒检查一次
    }
    
    /**
     * 判断是否应该触发故障回切
     */
    private boolean shouldTriggerFailback(String component, FailoverRule rule) {
        // 检查原主组件是否恢复健康
        HealthStatus healthStatus = checkOriginalComponentHealth(component);
        if (healthStatus == null || !"UP".equals(healthStatus.getStatus())) {
            return false;
        }
        
        // 检查连续健康次数是否达到阈值
        int healthyCount = getConsecutiveHealthyCount(component);
        if (healthyCount < rule.getRecoveryThreshold()) {
            log.debug("Healthy count {} below recovery threshold {} for component: {}", 
                     healthyCount, rule.getRecoveryThreshold(), component);
            return false;
        }
        
        return true;
    }
    
    /**
     * 执行故障回切
     */
    private void executeFailback(String component) {
        log.info("Executing failback for component: {}", component);
        
        try {
            switch (component) {
                case "database":
                    failoverExecutorService.executeDatabaseFailback();
                    break;
                case "redis":
                    failoverExecutorService.executeRedisFailback();
                    break;
                case "application":
                    failoverExecutorService.executeApplicationFailback();
                    break;
                default:
                    log.warn("Failback not supported for component: {}", component);
                    return;
            }
            
            sendFailbackNotification(component, "SUCCESS");
            
        } catch (Exception e) {
            log.error("Failback execution failed for component: {}", component, e);
            sendFailbackNotification(component, "FAILED");
        }
    }
    
    // 辅助方法实现...
    private Instant getLastFailoverTime(String component) {
        // 从数据库或缓存中获取最后故障转移时间
        return null;
    }
    
    private void recordFailoverStart(String component) {
        // 记录故障转移开始时间
    }
    
    private void recordFailoverComplete(String component) {
        // 记录故障转移完成时间
    }
    
    private void recordFailoverFailure(String component, String error) {
        // 记录故障转移失败信息
    }
    
    private HealthStatus checkOriginalComponentHealth(String component) {
        // 检查原组件健康状态
        return null;
    }
    
    private int getConsecutiveHealthyCount(String component) {
        // 获取连续健康次数
        return 0;
    }
    
    private void sendFailoverNotification(String component, String status) {
        // 发送故障转移通知
    }
    
    private void sendFailoverNotification(String component, String status) {
        // 发送故障转移通知
    }
    
    private void sendFailbackNotification(String component, String status) {
        // 发送故障回切通知
    }
}

/**
 * 故障转移规则
 */
@Data
@Builder
public class FailoverRule {
    private String component;
    private int failureThreshold;     // 故障阈值
    private int recoveryThreshold;    // 恢复阈值
    private Duration cooldownPeriod;  // 冷却期
    private boolean autoFailback;     // 是否自动回切
    private int priority;             // 优先级
}
```

### 4. 故障转移执行器

#### 故障转移执行服务
```java
/**
 * 故障转移执行服务
 */
@Service
@Slf4j
public class FailoverExecutorService {
    
    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Value("${failover.database.backup-url}")
    private String backupDatabaseUrl;
    
    @Value("${failover.redis.backup-nodes}")
    private String backupRedisNodes;
    
    /**
     * 执行数据库故障转移
     */
    public void executeDatabaseFailover() {
        log.info("Starting database failover execution");
        
        try {
            // 1. 停止对主库的写操作
            stopDatabaseWrites();
            
            // 2. 等待从库同步完成
            waitForReplicationSync();
            
            // 3. 提升从库为主库
            promoteSlaveToMaster();
            
            // 4. 更新应用配置
            updateDatabaseConfiguration();
            
            // 5. 重启应用连接池
            refreshDatabaseConnections();
            
            // 6. 验证故障转移结果
            validateDatabaseFailover();
            
            log.info("Database failover completed successfully");
            
        } catch (Exception e) {
            log.error("Database failover failed", e);
            throw new FailoverException("Database failover failed", e);
        }
    }
    
    /**
     * 停止数据库写操作
     */
    private void stopDatabaseWrites() {
        log.info("Stopping database write operations");
        
        try {
            // 设置数据库为只读模式
            try (Connection connection = dataSource.getConnection();
                 Statement stmt = connection.createStatement()) {
                
                stmt.execute("SET GLOBAL read_only = ON");
                stmt.execute("SET GLOBAL super_read_only = ON");
                
                log.info("Database set to read-only mode");
            }
            
        } catch (Exception e) {
            log.error("Failed to stop database writes", e);
            throw new RuntimeException("Failed to stop database writes", e);
        }
    }
    
    /**
     * 等待复制同步完成
     */
    private void waitForReplicationSync() {
        log.info("Waiting for replication synchronization");
        
        int maxWaitSeconds = 30;
        int waitInterval = 1;
        
        for (int i = 0; i < maxWaitSeconds; i += waitInterval) {
            try {
                if (isReplicationSynced()) {
                    log.info("Replication synchronization completed");
                    return;
                }
                
                Thread.sleep(waitInterval * 1000);
                
            } catch (Exception e) {
                log.warn("Error checking replication status", e);
            }
        }
        
        log.warn("Replication synchronization timeout after {} seconds", maxWaitSeconds);
    }
    
    /**
     * 检查复制是否同步
     */
    private boolean isReplicationSynced() {
        try (Connection connection = dataSource.getConnection();
             Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("SHOW SLAVE STATUS")) {
            
            if (rs.next()) {
                String ioRunning = rs.getString("Slave_IO_Running");
                String sqlRunning = rs.getString("Slave_SQL_Running");
                int secondsBehind = rs.getInt("Seconds_Behind_Master");
                
                return "Yes".equals(ioRunning) && "Yes".equals(sqlRunning) && secondsBehind == 0;
            }
            
        } catch (Exception e) {
            log.error("Failed to check replication status", e);
        }
        
        return false;
    }
    
    /**
     * 提升从库为主库
     */
    private void promoteSlaveToMaster() {
        log.info("Promoting slave to master");
        
        try {
            // 连接到备库
            String backupUrl = backupDatabaseUrl;
            try (Connection connection = DriverManager.getConnection(backupUrl);
                 Statement stmt = connection.createStatement()) {
                
                // 停止从库复制
                stmt.execute("STOP SLAVE");
                
                // 重置从库状态
                stmt.execute("RESET SLAVE ALL");
                
                // 设置为可写
                stmt.execute("SET GLOBAL read_only = OFF");
                stmt.execute("SET GLOBAL super_read_only = OFF");
                
                log.info("Slave promoted to master successfully");
            }
            
        } catch (Exception e) {
            log.error("Failed to promote slave to master", e);
            throw new RuntimeException("Failed to promote slave to master", e);
        }
    }
    
    /**
     * 更新数据库配置
     */
    private void updateDatabaseConfiguration() {
        log.info("Updating database configuration");
        
        try {
            // 通过配置中心更新数据库连接配置
            ConfigurableEnvironment environment = 
                (ConfigurableEnvironment) ApplicationContextHolder.getApplicationContext().getEnvironment();
            
            // 更新数据源URL
            System.setProperty("spring.datasource.url", backupDatabaseUrl);
            
            log.info("Database configuration updated to backup URL: {}", backupDatabaseUrl);
            
        } catch (Exception e) {
            log.error("Failed to update database configuration", e);
            throw new RuntimeException("Failed to update database configuration", e);
        }
    }
    
    /**
     * 刷新数据库连接
     */
    private void refreshDatabaseConnections() {
        log.info("Refreshing database connections");
        
        try {
            if (dataSource instanceof HikariDataSource) {
                HikariDataSource hikariDS = (HikariDataSource) dataSource;
                
                // 关闭现有连接池
                hikariDS.close();
                
                // 重新初始化连接池
                // 这里需要重新创建DataSource Bean
                log.info("Database connection pool refreshed");
            }
            
        } catch (Exception e) {
            log.error("Failed to refresh database connections", e);
            throw new RuntimeException("Failed to refresh database connections", e);
        }
    }
    
    /**
     * 验证数据库故障转移
     */
    private void validateDatabaseFailover() {
        log.info("Validating database failover");
        
        try {
            // 测试数据库连接
            try (Connection connection = dataSource.getConnection();
                 Statement stmt = connection.createStatement();
                 ResultSet rs = stmt.executeQuery("SELECT 1")) {
                
                if (rs.next() && rs.getInt(1) == 1) {
                    log.info("Database failover validation successful");
                } else {
                    throw new RuntimeException("Database failover validation failed");
                }
            }
            
        } catch (Exception e) {
            log.error("Database failover validation failed", e);
            throw new RuntimeException("Database failover validation failed", e);
        }
    }
    
    /**
     * 执行Redis故障转移
     */
    public void executeRedisFailover() {
        log.info("Starting Redis failover execution");
        
        try {
            // 1. 检测Redis Sentinel状态
            checkSentinelStatus();
            
            // 2. 触发手动故障转移（如果自动转移失败）
            triggerManualFailover();
            
            // 3. 更新应用Redis配置
            updateRedisConfiguration();
            
            // 4. 重新初始化Redis连接
            refreshRedisConnections();
            
            // 5. 验证Redis故障转移
            validateRedisFailover();
            
            log.info("Redis failover completed successfully");
            
        } catch (Exception e) {
            log.error("Redis failover failed", e);
            throw new FailoverException("Redis failover failed", e);
        }
    }
    
    /**
     * 检查Sentinel状态
     */
    private void checkSentinelStatus() {
        log.info("Checking Redis Sentinel status");
        
        try {
            // 连接到Sentinel检查状态
            JedisSentinelPool sentinelPool = new JedisSentinelPool(
                "nsrs-redis", 
                Set.of(backupRedisNodes.split(",")),
                "redis_password_2024"
            );
            
            try (Jedis jedis = sentinelPool.getResource()) {
                String pong = jedis.ping();
                if ("PONG".equals(pong)) {
                    log.info("Redis Sentinel is responsive");
                } else {
                    throw new RuntimeException("Redis Sentinel not responsive");
                }
            }
            
        } catch (Exception e) {
            log.error("Failed to check Sentinel status", e);
            throw new RuntimeException("Failed to check Sentinel status", e);
        }
    }
    
    /**
     * 触发手动故障转移
     */
    private void triggerManualFailover() {
        log.info("Triggering manual Redis failover");
        
        try {
            // 通过Sentinel API触发故障转移
            String[] sentinelNodes = backupRedisNodes.split(",");
            
            for (String node : sentinelNodes) {
                try {
                    String[] hostPort = node.split(":");
                    Jedis sentinel = new Jedis(hostPort[0], Integer.parseInt(hostPort[1]));
                    
                    // 执行故障转移命令
                    String result = sentinel.sentinelFailover("nsrs-redis");
                    log.info("Manual failover result: {}", result);
                    
                    sentinel.close();
                    break;
                    
                } catch (Exception e) {
                    log.warn("Failed to trigger failover on sentinel: {}", node, e);
                }
            }
            
        } catch (Exception e) {
            log.error("Failed to trigger manual failover", e);
            throw new RuntimeException("Failed to trigger manual failover", e);
        }
    }
    
    /**
     * 更新Redis配置
     */
    private void updateRedisConfiguration() {
        log.info("Updating Redis configuration");
        
        try {
            // 更新Redis连接配置
            System.setProperty("spring.redis.sentinel.nodes", backupRedisNodes);
            
            log.info("Redis configuration updated to backup nodes: {}", backupRedisNodes);
            
        } catch (Exception e) {
            log.error("Failed to update Redis configuration", e);
            throw new RuntimeException("Failed to update Redis configuration", e);
        }
    }
    
    /**
     * 刷新Redis连接
     */
    private void refreshRedisConnections() {
        log.info("Refreshing Redis connections");
        
        try {
            // 重置Redis连接工厂
            LettuceConnectionFactory connectionFactory = 
                ApplicationContextHolder.getApplicationContext().getBean(LettuceConnectionFactory.class);
            
            connectionFactory.resetConnection();
            
            log.info("Redis connections refreshed");
            
        } catch (Exception e) {
            log.error("Failed to refresh Redis connections", e);
            throw new RuntimeException("Failed to refresh Redis connections", e);
        }
    }
    
    /**
     * 验证Redis故障转移
     */
    private void validateRedisFailover() {
        log.info("Validating Redis failover");
        
        try {
            // 测试Redis连接
            String pong = redisTemplate.execute((RedisCallback<String>) connection -> {
                return connection.ping();
            });
            
            if ("PONG".equals(pong)) {
                log.info("Redis failover validation successful");
            } else {
                throw new RuntimeException("Redis failover validation failed");
            }
            
        } catch (Exception e) {
            log.error("Redis failover validation failed", e);
            throw new RuntimeException("Redis failover validation failed", e);
        }
    }
    
    /**
     * 执行应用故障转移
     */
    public void executeApplicationFailover() {
        log.info("Starting application failover execution");
        
        try {
            // 1. 扩容备集群
            scaleUpBackupCluster();
            
            // 2. 等待备集群就绪
            waitForBackupClusterReady();
            
            // 3. 切换流量到备集群
            switchTrafficToBackup();
            
            // 4. 验证应用故障转移
            validateApplicationFailover();
            
            log.info("Application failover completed successfully");
            
        } catch (Exception e) {
            log.error("Application failover failed", e);
            throw new FailoverException("Application failover failed", e);
        }
    }
    
    /**
     * 扩容备集群
     */
    private void scaleUpBackupCluster() {
        log.info("Scaling up backup cluster");
        
        try {
            // 使用kubectl命令扩容
            ProcessBuilder pb = new ProcessBuilder(
                "kubectl", "scale", "deployment/nsrs-application", 
                "--replicas=6", "--context=backup-cluster", "-n", "nsrs-prod"
            );
            
            Process process = pb.start();
            int exitCode = process.waitFor();
            
            if (exitCode == 0) {
                log.info("Backup cluster scaled up successfully");
            } else {
                throw new RuntimeException("Failed to scale up backup cluster, exit code: " + exitCode);
            }
            
        } catch (Exception e) {
            log.error("Failed to scale up backup cluster", e);
            throw new RuntimeException("Failed to scale up backup cluster", e);
        }
    }
    
    /**
     * 等待备集群就绪
     */
    private void waitForBackupClusterReady() {
        log.info("Waiting for backup cluster to be ready");
        
        try {
            ProcessBuilder pb = new ProcessBuilder(
                "kubectl", "wait", "--for=condition=available", 
                "--timeout=300s", "deployment/nsrs-application", 
                "--context=backup-cluster", "-n", "nsrs-prod"
            );
            
            Process process = pb.start();
            int exitCode = process.waitFor();
            
            if (exitCode == 0) {
                log.info("Backup cluster is ready");
            } else {
                throw new RuntimeException("Backup cluster failed to become ready");
            }
            
        } catch (Exception e) {
            log.error("Failed to wait for backup cluster ready", e);
            throw new RuntimeException("Failed to wait for backup cluster ready", e);
        }
    }
    
    /**
     * 切换流量到备集群
     */
    private void switchTrafficToBackup() {
        log.info("Switching traffic to backup cluster");
        
        try {
            // 更新Istio VirtualService配置
            String virtualServiceYaml = """
                apiVersion: networking.istio.io/v1beta1
                kind: VirtualService
                metadata:
                  name: nsrs-traffic-split
                  namespace: nsrs-prod
                spec:
                  hosts:
                  - nsrs.example.com
                  gateways:
                  - nsrs-gateway
                  http:
                  - route:
                    - destination:
                        host: nsrs-application-service
                        subset: backup
                      weight: 100
                """;
            
            // 应用配置
            Files.write(Paths.get("/tmp/failover-vs.yaml"), virtualServiceYaml.getBytes());
            
            ProcessBuilder pb = new ProcessBuilder(
                "kubectl", "apply", "-f", "/tmp/failover-vs.yaml"
            );
            
            Process process = pb.start();
            int exitCode = process.waitFor();
            
            if (exitCode == 0) {
                log.info("Traffic switched to backup cluster successfully");
            } else {
                throw new RuntimeException("Failed to switch traffic to backup cluster");
            }
            
        } catch (Exception e) {
            log.error("Failed to switch traffic to backup cluster", e);
            throw new RuntimeException("Failed to switch traffic to backup cluster", e);
        }
    }
    
    /**
     * 验证应用故障转移
     */
    private void validateApplicationFailover() {
        log.info("Validating application failover");
        
        try {
            // 测试应用健康检查接口
            RestTemplate restTemplate = new RestTemplate();
            ResponseEntity<String> response = restTemplate.getForEntity(
                "https://nsrs.example.com/actuator/health", String.class);
            
            if (response.getStatusCode() == HttpStatus.OK) {
                log.info("Application failover validation successful");
            } else {
                throw new RuntimeException("Application failover validation failed: " + response.getStatusCode());
            }
            
        } catch (Exception e) {
            log.error("Application failover validation failed", e);
            throw new RuntimeException("Application failover validation failed", e);
        }
    }
    
    /**
     * 执行网络故障转移
     */
    public void executeNetworkFailover() {
        log.info("Starting network failover execution");
        
        try {
            // 1. 检测可用网络线路
            detectAvailableNetworkLines();
            
            // 2. 更新路由权重
            updateRoutingWeights();
            
            // 3. 验证网络故障转移
            validateNetworkFailover();
            
            log.info("Network failover completed successfully");
            
        } catch (Exception e) {
            log.error("Network failover failed", e);
            throw new FailoverException("Network failover failed", e);
        }
    }
    
    /**
     * 检测可用网络线路
     */
    private void detectAvailableNetworkLines() {
        log.info("Detecting available network lines");
        
        // 实现网络线路检测逻辑
        // 这里可以调用网络监控脚本或API
    }
    
    /**
     * 更新路由权重
     */
    private void updateRoutingWeights() {
        log.info("Updating routing weights");
        
        // 实现路由权重更新逻辑
        // 这里可以调用BGP配置更新脚本
    }
    
    /**
     * 验证网络故障转移
     */
    private void validateNetworkFailover() {
        log.info("Validating network failover");
        
        // 实现网络连通性验证逻辑
    }
    
    /**
     * 执行数据库故障回切
     */
    public void executeDatabaseFailback() {
        log.info("Starting database failback execution");
        
        try {
            // 1. 验证原主库健康状态
            validateOriginalDatabaseHealth();
            
            // 2. 建立新的主从复制关系
            setupNewReplication();
            
            // 3. 等待数据同步
            waitForDataSync();
            
            // 4. 切换回原主库
            switchBackToOriginalDatabase();
            
            log.info("Database failback completed successfully");
            
        } catch (Exception e) {
            log.error("Database failback failed", e);
            throw new FailoverException("Database failback failed", e);
        }
    }
    
    /**
     * 执行Redis故障回切
     */
    public void executeRedisFailback() {
        log.info("Starting Redis failback execution");
        
        try {
            // 1. 验证原Redis主节点健康状态
            validateOriginalRedisHealth();
            
            // 2. 重新配置Redis主从关系
            reconfigureRedisMasterSlave();
            
            // 3. 切换回原Redis主节点
            switchBackToOriginalRedis();
            
            log.info("Redis failback completed successfully");
            
        } catch (Exception e) {
            log.error("Redis failback failed", e);
            throw new FailoverException("Redis failback failed", e);
        }
    }
    
    /**
     * 执行应用故障回切
     */
    public void executeApplicationFailback() {
        log.info("Starting application failback execution");
        
        try {
            // 1. 验证原主集群健康状态
            validateOriginalClusterHealth();
            
            // 2. 逐步切换流量回主集群
            graduallyShiftTrafficBack();
            
            // 3. 缩容备集群
            scaleDownBackupCluster();
            
            log.info("Application failback completed successfully");
            
        } catch (Exception e) {
            log.error("Application failback failed", e);
            throw new FailoverException("Application failback failed", e);
        }
    }
    
    // 辅助方法实现...
    private void validateOriginalDatabaseHealth() {
        // 验证原数据库健康状态
    }
    
    private void setupNewReplication() {
        // 建立新的主从复制关系
    }
    
    private void waitForDataSync() {
        // 等待数据同步
    }
    
    private void switchBackToOriginalDatabase() {
        // 切换回原数据库
    }
    
    private void validateOriginalRedisHealth() {
        // 验证原Redis健康状态
    }
    
    private void reconfigureRedisMasterSlave() {
        // 重新配置Redis主从关系
    }
    
    private void switchBackToOriginalRedis() {
        // 切换回原Redis
    }
    
    private void validateOriginalClusterHealth() {
        // 验证原集群健康状态
    }
    
    private void graduallyShiftTrafficBack() {
        // 逐步切换流量回主集群
    }
    
    private void scaleDownBackupCluster() {
        // 缩容备集群
    }
}

/**
 * 故障转移异常
 */
public class FailoverException extends RuntimeException {
    public FailoverException(String message) {
        super(message);
    }
    
    public FailoverException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

## Demo样例

### 1. 数据库故障转移演示

#### 演示脚本
```bash
#!/bin/bash
# database_failover_demo.sh - 数据库故障转移演示

echo "=== 数据库故障转移演示 ==="

# 1. 显示当前数据库状态
echo "1. 当前数据库状态:"
mysql -h10.1.7.10 -uroot -p123456 -e "SHOW MASTER STATUS;"
mysql -h10.1.7.11 -uroot -p123456 -e "SHOW SLAVE STATUS\G" | grep -E "Slave_IO_Running|Slave_SQL_Running|Seconds_Behind_Master"

# 2. 模拟主库故障
echo "\n2. 模拟主库故障 (停止MySQL服务):"
ssh root@10.1.7.10 "systemctl stop mysql"
echo "主库已停止"

# 3. 等待故障检测
echo "\n3. 等待故障检测和自动切换 (30秒):"
for i in {1..30}; do
    echo -n "."
    sleep 1
done
echo

# 4. 检查应用状态
echo "\n4. 检查应用健康状态:"
curl -s http://localhost:8080/actuator/health | jq '.status'

# 5. 验证数据库切换
echo "\n5. 验证数据库已切换到备库:"
mysql -h10.1.7.11 -uroot -p123456 -e "SELECT @@hostname, @@read_only;"

# 6. 测试业务功能
echo "\n6. 测试业务功能 (查询SIM卡信息):"
curl -s "http://localhost:8080/api/sim-cards/search?imsi=460001234567890" | jq '.data.imsi'

# 7. 恢复主库
echo "\n7. 恢复主库服务:"
ssh root@10.1.7.10 "systemctl start mysql"
echo "主库已恢复"

# 8. 等待自动回切
echo "\n8. 等待自动故障回切 (60秒):"
for i in {1..60}; do
    echo -n "."
    sleep 1
done
echo

# 9. 验证回切结果
echo "\n9. 验证已回切到主库:"
mysql -h10.1.7.10 -uroot -p123456 -e "SELECT @@hostname, @@read_only;"

echo "\n=== 数据库故障转移演示完成 ==="
```

### 2. Redis故障转移演示

#### 演示脚本
```bash
#!/bin/bash
# redis_failover_demo.sh - Redis故障转移演示

echo "=== Redis故障转移演示 ==="

# 1. 显示当前Redis状态
echo "1. 当前Redis集群状态:"
redis-cli -h 10.1.7.10 -p 26379 SENTINEL masters
redis-cli -h 10.1.7.10 -p 6379 -a redis_password_2024 INFO replication

# 2. 测试缓存功能
echo "\n2. 测试缓存功能:"
redis-cli -h 10.1.7.10 -p 6379 -a redis_password_2024 SET test_key "test_value"
redis-cli -h 10.1.7.10 -p 6379 -a redis_password_2024 GET test_key

# 3. 模拟Redis主节点故障
echo "\n3. 模拟Redis主节点故障:"
ssh root@10.1.7.10 "systemctl stop redis"
echo "Redis主节点已停止"

# 4. 等待Sentinel检测和切换
echo "\n4. 等待Sentinel自动故障转移 (30秒):"
for i in {1..30}; do
    echo -n "."
    sleep 1
done
echo

# 5. 检查新的主节点
echo "\n5. 检查新的Redis主节点:"
redis-cli -h 10.1.7.10 -p 26379 SENTINEL get-master-addr-by-name nsrs-redis

# 6. 验证缓存数据
echo "\n6. 验证缓存数据是否完整:"
NEW_MASTER=$(redis-cli -h 10.1.7.10 -p 26379 SENTINEL get-master-addr-by-name nsrs-redis | head -1)
redis-cli -h $NEW_MASTER -p 6379 -a redis_password_2024 GET test_key

# 7. 测试应用缓存功能
echo "\n7. 测试应用缓存功能:"
curl -s "http://localhost:8080/api/cache/test" | jq '.status'

# 8. 恢复原主节点
echo "\n8. 恢复原Redis主节点:"
ssh root@10.1.7.10 "systemctl start redis"
echo "原Redis主节点已恢复"

# 9. 检查集群状态
echo "\n9. 检查Redis集群最终状态:"
sleep 10
redis-cli -h 10.1.7.10 -p 26379 SENTINEL masters

echo "\n=== Redis故障转移演示完成 ==="
```

### 3. 应用故障转移演示

#### 演示脚本
```bash
#!/bin/bash
# application_failover_demo.sh - 应用故障转移演示

echo "=== 应用故障转移演示 ==="

# 1. 显示当前集群状态
echo "1. 当前Kubernetes集群状态:"
kubectl get pods -l app=nsrs-application --context=primary-cluster -n nsrs-prod
kubectl get pods -l app=nsrs-application --context=backup-cluster -n nsrs-prod

# 2. 测试应用功能
echo "\n2. 测试应用功能:"
curl -s "https://nsrs.example.com/actuator/health" | jq '.status'
curl -s "https://nsrs.example.com/api/sim-cards/count" | jq '.data'

# 3. 模拟主集群故障
echo "\n3. 模拟主集群故障 (缩容到0):"
kubectl scale deployment nsrs-application --replicas=0 --context=primary-cluster -n nsrs-prod
echo "主集群已停止"

# 4. 等待故障检测和自动切换
echo "\n4. 等待故障检测和自动切换 (120秒):"
for i in {1..120}; do
    echo -n "."
    sleep 1
done
echo

# 5. 检查备集群状态
echo "\n5. 检查备集群状态:"
kubectl get pods -l app=nsrs-application --context=backup-cluster -n nsrs-prod

# 6. 验证应用可用性
echo "\n6. 验证应用可用性:"
for i in {1..5}; do
    STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://nsrs.example.com/actuator/health")
    echo "健康检查 $i: HTTP $STATUS"
    sleep 2
done

# 7. 测试业务功能
echo "\n7. 测试业务功能:"
curl -s "https://nsrs.example.com/api/sim-cards/search?status=ACTIVE" | jq '.data | length'

# 8. 恢复主集群
echo "\n8. 恢复主集群:"
kubectl scale deployment nsrs-application --replicas=6 --context=primary-cluster -n nsrs-prod
echo "主集群正在恢复..."

# 9. 等待主集群就绪
echo "\n9. 等待主集群就绪:"
kubectl wait --for=condition=available --timeout=300s deployment/nsrs-application --context=primary-cluster -n nsrs-prod

# 10. 等待自动回切
echo "\n10. 等待自动故障回切 (180秒):"
for i in {1..180}; do
    echo -n "."
    sleep 1
done
echo

# 11. 验证回切结果
echo "\n11. 验证流量已回切到主集群:"
kubectl get pods -l app=nsrs-application --context=primary-cluster -n nsrs-prod
kubectl get pods -l app=nsrs-application --context=backup-cluster -n nsrs-prod

echo "\n=== 应用故障转移演示完成 ==="
```

### 4. 综合故障转移演示

#### 演示脚本
```bash
#!/bin/bash
# comprehensive_failover_demo.sh - 综合故障转移演示

echo "=== 综合故障转移演示 ==="

# 1. 系统初始状态检查
echo "1. 系统初始状态检查:"
echo "数据库状态:"
mysql -h10.1.7.10 -uroot -p123456 -e "SELECT 'Primary DB OK' as status;"

echo "Redis状态:"
redis-cli -h 10.1.7.10 -p 6379 -a redis_password_2024 ping

echo "应用状态:"
curl -s "https://nsrs.example.com/actuator/health" | jq '.status'

echo "网络状态:"
ping -c 3 8.8.8.8 | grep "packet loss"

# 2. 模拟多重故障
echo "\n2. 模拟多重故障场景:"
echo "停止数据库主库..."
ssh root@10.1.7.10 "systemctl stop mysql" &

echo "停止Redis主节点..."
ssh root@10.1.7.10 "systemctl stop redis" &

echo "停止主集群应用..."
kubectl scale deployment nsrs-application --replicas=0 --context=primary-cluster -n nsrs-prod &

wait
echo "所有故障已模拟"

# 3. 监控故障转移过程
echo "\n3. 监控故障转移过程 (300秒):"
for i in {1..300}; do
    if [ $((i % 30)) -eq 0 ]; then
        echo "\n[$i秒] 检查系统状态:"
        
        # 检查应用健康状态
        APP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://nsrs.example.com/actuator/health")
        echo "应用状态: HTTP $APP_STATUS"
        
        # 检查数据库连接
        DB_STATUS=$(mysql -h10.1.7.11 -uroot -p123456 -e "SELECT 'OK'" 2>/dev/null && echo "OK" || echo "FAIL")
        echo "数据库状态: $DB_STATUS"
        
        # 检查Redis连接
        REDIS_STATUS=$(redis-cli -h 10.1.7.11 -p 6379 -a redis_password_2024 ping 2>/dev/null || echo "FAIL")
        echo "Redis状态: $REDIS_STATUS"
    else
        echo -n "."
    fi
    sleep 1
done
echo

# 4. 验证业务连续性
echo "\n4. 验证业务连续性:"
echo "测试SIM卡查询功能:"
curl -s "https://nsrs.example.com/api/sim-cards/search?pageSize=5" | jq '.data | length'

echo "测试SIM卡创建功能:"
TEST_IMSI="460001$(date +%s)"
curl -s -X POST "https://nsrs.example.com/api/sim-cards" \
    -H "Content-Type: application/json" \
    -d "{
        \"imsi\": \"$TEST_IMSI\",
        \"msisdn\": \"13800138000\",
        \"status\": \"ACTIVE\"
    }" | jq '.success'

echo "测试缓存功能:"
curl -s "https://nsrs.example.com/api/cache/stats" | jq '.hitRate'

# 5. 恢复所有服务
echo "\n5. 恢复所有服务:"
echo "恢复数据库主库..."
ssh root@10.1.7.10 "systemctl start mysql" &

echo "恢复Redis主节点..."
ssh root@10.1.7.10 "systemctl start redis" &

echo "恢复主集群应用..."
kubectl scale deployment nsrs-application --replicas=6 --context=primary-cluster -n nsrs-prod &

wait
echo "所有服务已恢复"

# 6. 等待系统稳定
echo "\n6. 等待系统稳定和自动回切 (600秒):"
for i in {1..600}; do
    if [ $((i % 60)) -eq 0 ]; then
        echo "\n[$i秒] 系统状态检查:"
        
        # 全面健康检查
        curl -s "https://nsrs.example.com/actuator/health" | jq '.components | keys[]'
    else
        echo -n "."
    fi
    sleep 1
done
echo

# 7. 最终状态验证
echo "\n7. 最终状态验证:"
echo "数据库状态:"
mysql -h10.1.7.10 -uroot -p123456 -e "SELECT 'Primary DB Restored' as status;"

echo "Redis状态:"
redis-cli -h 10.1.7.10 -p 6379 -a redis_password_2024 ping

echo "应用集群状态:"
kubectl get pods -l app=nsrs-application --context=primary-cluster -n nsrs-prod | grep Running | wc -l

echo "业务功能验证:"
curl -s "https://nsrs.example.com/api/sim-cards/count" | jq '.data'

echo "\n=== 综合故障转移演示完成 ==="
echo "演示结果: 系统在多重故障情况下保持了业务连续性，并成功实现了自动故障转移和回切。"
```

## 最佳实践

### 1. 故障转移设计原则
- **快速检测**: 故障检测时间应控制在30秒内
- **自动切换**: 优先使用自动故障转移，减少人工干预
- **数据一致性**: 确保故障转移过程中数据不丢失
- **业务连续性**: 故障转移期间业务中断时间最小化
- **可回切性**: 支持故障恢复后的自动回切

### 2. 监控告警要点
- **多维度监控**: 从基础设施到应用层的全方位监控
- **智能告警**: 避免告警风暴，实现告警聚合和抑制
- **分级告警**: 根据故障严重程度分级处理
- **自动化响应**: 关键故障自动触发故障转移流程

### 3. 运维管理建议
- **定期演练**: 每月进行故障转移演练
- **文档维护**: 及时更新故障转移手册
- **人员培训**: 定期进行故障处理培训
- **持续改进**: 根据故障处理经验优化流程

通过以上故障转移机制的实施，NSRS号卡资源管理系统能够在各种故障场景下快速恢复服务，确保业务连续性和数据安全。
```