# 消息队列架构设计详解

基于RocketMQ的NSRS号卡资源管理系统消息队列解决方案

## 目录

- [消息队列概述](#消息队列概述)
- [核心枚举定义](#核心枚举定义)
- [核心实体设计](#核心实体设计)
- [消息队列服务实现](#消息队列服务实现)
- [业务场景应用](#业务场景应用)
- [RocketMQ集群配置](#rocketmq集群配置)
- [监控与运维](#监控与运维)
- [最佳实践](#最佳实践)

## 消息队列概述

### 设计目标

- **异步解耦**: 服务间异步通信，降低系统耦合度
- **削峰填谷**: 处理突发流量，保护下游系统
- **可靠传输**: 保证消息不丢失，支持事务消息
- **顺序保证**: 支持顺序消息和分区顺序
- **高可用**: 集群部署，故障自动切换

### 消息队列架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    NSRS消息队列架构                           │
├─────────────────────────────────────────────────────────────┤
│                      业务应用层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ IMSI Service│ │ Bill Service│ │Report Service│           │
│  │   Producer  │ │   Consumer  │ │   Consumer   │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    消息中间件层                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                RocketMQ Cluster                        │ │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐      │ │
│  │  │NameSrv1 │ │NameSrv2 │ │ Broker1 │ │ Broker2 │      │ │
│  │  │         │ │         │ │ Master  │ │ Slave   │      │ │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘      │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                      存储层                                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ CommitLog   │ │ ConsumeQueue│ │ IndexFile   │           │
│  │   存储      │ │    索引     │ │    索引     │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

## 核心枚举定义

### 1. 消息类型枚举

```java
/**
 * 消息类型枚举
 */
public enum MessageType {
    
    // IMSI相关消息
    IMSI_ALLOCATED("IMSI_ALLOCATED", "IMSI资源分配"),
    IMSI_ACTIVATED("IMSI_ACTIVATED", "IMSI激活"),
    IMSI_SUSPENDED("IMSI_SUSPENDED", "IMSI暂停"),
    IMSI_RELEASED("IMSI_RELEASED", "IMSI释放"),
    
    // SIM卡相关消息
    SIM_CARD_PRODUCED("SIM_CARD_PRODUCED", "SIM卡制作完成"),
    SIM_CARD_PERSONALIZED("SIM_CARD_PERSONALIZED", "SIM卡个人化"),
    SIM_CARD_ACTIVATED("SIM_CARD_ACTIVATED", "SIM卡激活"),
    SIM_CARD_SUSPENDED("SIM_CARD_SUSPENDED", "SIM卡暂停"),
    
    // 计费相关消息
    BILLING_RECORD_CREATED("BILLING_RECORD_CREATED", "计费记录创建"),
    BILLING_SETTLEMENT("BILLING_SETTLEMENT", "计费结算"),
    
    // 系统消息
    SYSTEM_NOTIFICATION("SYSTEM_NOTIFICATION", "系统通知"),
    AUDIT_LOG("AUDIT_LOG", "审计日志");
    
    private final String code;
    private final String description;
    
    MessageType(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

### 2. 消息优先级枚举

```java
/**
 * 消息优先级枚举
 */
public enum MessagePriority {
    
    LOW(1, "低优先级"),
    NORMAL(5, "普通优先级"),
    HIGH(8, "高优先级"),
    URGENT(10, "紧急优先级");
    
    private final int level;
    private final String description;
    
    MessagePriority(int level, String description) {
        this.level = level;
        this.description = description;
    }
    
    // getters...
}
```

### 3. 消息状态枚举

```java
/**
 * 消息状态枚举
 */
public enum MessageStatus {
    
    PENDING("PENDING", "待发送"),
    SENT("SENT", "已发送"),
    CONSUMED("CONSUMED", "已消费"),
    FAILED("FAILED", "发送失败"),
    RETRY("RETRY", "重试中"),
    DEAD_LETTER("DEAD_LETTER", "死信");
    
    private final String code;
    private final String description;
    
    MessageStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

## 核心实体设计

### 1. 消息实体

```java
/**
 * 消息实体
 */
@Entity
@Table(name = "mq_message")
public class MqMessage {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * 消息ID（全局唯一）
     */
    @Column(name = "message_id", unique = true, nullable = false)
    private String messageId;
    
    /**
     * 消息类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "message_type", nullable = false)
    private MessageType messageType;
    
    /**
     * 主题
     */
    @Column(name = "topic", nullable = false)
    private String topic;
    
    /**
     * 标签
     */
    @Column(name = "tag")
    private String tag;
    
    /**
     * 消息键（用于顺序消息）
     */
    @Column(name = "message_key")
    private String messageKey;
    
    /**
     * 消息体
     */
    @Column(name = "message_body", columnDefinition = "TEXT")
    private String messageBody;
    
    /**
     * 消息优先级
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "priority")
    private MessagePriority priority;
    
    /**
     * 消息状态
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private MessageStatus status;
    
    /**
     * 延迟时间（毫秒）
     */
    @Column(name = "delay_time")
    private Long delayTime;
    
    /**
     * 重试次数
     */
    @Column(name = "retry_count")
    private Integer retryCount;
    
    /**
     * 最大重试次数
     */
    @Column(name = "max_retry_count")
    private Integer maxRetryCount;
    
    /**
     * 发送时间
     */
    @Column(name = "send_time")
    private LocalDateTime sendTime;
    
    /**
     * 消费时间
     */
    @Column(name = "consume_time")
    private LocalDateTime consumeTime;
    
    /**
     * 创建时间
     */
    @Column(name = "create_time")
    private LocalDateTime createTime;
    
    /**
     * 更新时间
     */
    @Column(name = "update_time")
    private LocalDateTime updateTime;
    
    // constructors, getters, setters...
}
```

### 2. 消息消费记录实体

```java
/**
 * 消息消费记录实体
 */
@Entity
@Table(name = "mq_consume_record")
public class MqConsumeRecord {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * 消息ID
     */
    @Column(name = "message_id", nullable = false)
    private String messageId;
    
    /**
     * 消费者组
     */
    @Column(name = "consumer_group", nullable = false)
    private String consumerGroup;
    
    /**
     * 消费者实例
     */
    @Column(name = "consumer_instance")
    private String consumerInstance;
    
    /**
     * 消费状态
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "consume_status")
    private ConsumeStatus consumeStatus;
    
    /**
     * 消费开始时间
     */
    @Column(name = "consume_start_time")
    private LocalDateTime consumeStartTime;
    
    /**
     * 消费结束时间
     */
    @Column(name = "consume_end_time")
    private LocalDateTime consumeEndTime;
    
    /**
     * 消费耗时（毫秒）
     */
    @Column(name = "consume_duration")
    private Long consumeDuration;
    
    /**
     * 错误信息
     */
    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;
    
    /**
     * 创建时间
     */
    @Column(name = "create_time")
    private LocalDateTime createTime;
    
    // constructors, getters, setters...
}
```

## 消息队列服务实现

### 1. 消息生产者服务

```java
/**
 * 消息生产者服务
 */
@Service
@Slf4j
public class MessageProducerService {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    @Autowired
    private MqMessageRepository messageRepository;
    
    /**
     * 发送普通消息
     */
    public void sendMessage(String topic, String tag, Object message) {
        try {
            String messageId = generateMessageId();
            String messageBody = JSON.toJSONString(message);
            
            // 保存消息记录
            MqMessage mqMessage = new MqMessage();
            mqMessage.setMessageId(messageId);
            mqMessage.setTopic(topic);
            mqMessage.setTag(tag);
            mqMessage.setMessageBody(messageBody);
            mqMessage.setStatus(MessageStatus.PENDING);
            mqMessage.setCreateTime(LocalDateTime.now());
            messageRepository.save(mqMessage);
            
            // 发送消息
            Message<String> msg = MessageBuilder
                .withPayload(messageBody)
                .setHeader(RocketMQHeaders.KEYS, messageId)
                .setHeader(RocketMQHeaders.TAGS, tag)
                .build();
            
            SendResult sendResult = rocketMQTemplate.syncSend(topic, msg);
            
            // 更新消息状态
            mqMessage.setStatus(MessageStatus.SENT);
            mqMessage.setSendTime(LocalDateTime.now());
            mqMessage.setUpdateTime(LocalDateTime.now());
            messageRepository.save(mqMessage);
            
            log.info("Message sent successfully: messageId={}, sendResult={}", 
                messageId, sendResult);
            
        } catch (Exception e) {
            log.error("Failed to send message: topic={}, tag={}", topic, tag, e);
            throw new MessageSendException("Failed to send message", e);
        }
    }
    
    /**
     * 发送顺序消息
     */
    public void sendOrderlyMessage(String topic, String tag, Object message, String orderKey) {
        try {
            String messageId = generateMessageId();
            String messageBody = JSON.toJSONString(message);
            
            // 保存消息记录
            MqMessage mqMessage = new MqMessage();
            mqMessage.setMessageId(messageId);
            mqMessage.setTopic(topic);
            mqMessage.setTag(tag);
            mqMessage.setMessageKey(orderKey);
            mqMessage.setMessageBody(messageBody);
            mqMessage.setStatus(MessageStatus.PENDING);
            mqMessage.setCreateTime(LocalDateTime.now());
            messageRepository.save(mqMessage);
            
            // 发送顺序消息
            Message<String> msg = MessageBuilder
                .withPayload(messageBody)
                .setHeader(RocketMQHeaders.KEYS, messageId)
                .setHeader(RocketMQHeaders.TAGS, tag)
                .build();
            
            SendResult sendResult = rocketMQTemplate.syncSendOrderly(
                topic, msg, orderKey);
            
            // 更新消息状态
            mqMessage.setStatus(MessageStatus.SENT);
            mqMessage.setSendTime(LocalDateTime.now());
            mqMessage.setUpdateTime(LocalDateTime.now());
            messageRepository.save(mqMessage);
            
            log.info("Orderly message sent successfully: messageId={}, orderKey={}", 
                messageId, orderKey);
            
        } catch (Exception e) {
            log.error("Failed to send orderly message: topic={}, orderKey={}", 
                topic, orderKey, e);
            throw new MessageSendException("Failed to send orderly message", e);
        }
    }
    
    /**
     * 发送延迟消息
     */
    public void sendDelayMessage(String topic, String tag, Object message, int delayLevel) {
        try {
            String messageId = generateMessageId();
            String messageBody = JSON.toJSONString(message);
            
            // 保存消息记录
            MqMessage mqMessage = new MqMessage();
            mqMessage.setMessageId(messageId);
            mqMessage.setTopic(topic);
            mqMessage.setTag(tag);
            mqMessage.setMessageBody(messageBody);
            mqMessage.setDelayTime((long) delayLevel);
            mqMessage.setStatus(MessageStatus.PENDING);
            mqMessage.setCreateTime(LocalDateTime.now());
            messageRepository.save(mqMessage);
            
            // 发送延迟消息
            Message<String> msg = MessageBuilder
                .withPayload(messageBody)
                .setHeader(RocketMQHeaders.KEYS, messageId)
                .setHeader(RocketMQHeaders.TAGS, tag)
                .build();
            
            SendResult sendResult = rocketMQTemplate.syncSend(
                topic, msg, 3000, delayLevel);
            
            // 更新消息状态
            mqMessage.setStatus(MessageStatus.SENT);
            mqMessage.setSendTime(LocalDateTime.now());
            mqMessage.setUpdateTime(LocalDateTime.now());
            messageRepository.save(mqMessage);
            
            log.info("Delay message sent successfully: messageId={}, delayLevel={}", 
                messageId, delayLevel);
            
        } catch (Exception e) {
            log.error("Failed to send delay message: topic={}, delayLevel={}", 
                topic, delayLevel, e);
            throw new MessageSendException("Failed to send delay message", e);
        }
    }
    
    /**
     * 发送事务消息
     */
    @Transactional
    public void sendTransactionMessage(String topic, String tag, Object message, 
                                     TransactionExecutor executor) {
        try {
            String messageId = generateMessageId();
            String messageBody = JSON.toJSONString(message);
            
            // 发送半消息
            Message<String> msg = MessageBuilder
                .withPayload(messageBody)
                .setHeader(RocketMQHeaders.KEYS, messageId)
                .setHeader(RocketMQHeaders.TAGS, tag)
                .build();
            
            TransactionSendResult sendResult = rocketMQTemplate.sendMessageInTransaction(
                topic, msg, executor);
            
            log.info("Transaction message sent: messageId={}, localTransactionState={}", 
                messageId, sendResult.getLocalTransactionState());
            
        } catch (Exception e) {
            log.error("Failed to send transaction message: topic={}", topic, e);
            throw new MessageSendException("Failed to send transaction message", e);
        }
    }
    
    /**
     * 生成消息ID
     */
    private String generateMessageId() {
        return "MSG_" + System.currentTimeMillis() + "_" + 
               ThreadLocalRandom.current().nextInt(1000, 9999);
    }
}
```

### 2. 消息消费者基类

```java
/**
 * 消息消费者基类
 */
@Slf4j
public abstract class BaseMessageConsumer {
    
    @Autowired
    private MqConsumeRecordRepository consumeRecordRepository;
    
    /**
     * 处理消息
     */
    protected ConsumeStatus handleMessage(String messageId, String consumerGroup, 
                                        String messageBody, MessageProcessor processor) {
        
        MqConsumeRecord record = new MqConsumeRecord();
        record.setMessageId(messageId);
        record.setConsumerGroup(consumerGroup);
        record.setConsumerInstance(getConsumerInstance());
        record.setConsumeStartTime(LocalDateTime.now());
        record.setConsumeStatus(ConsumeStatus.CONSUMING);
        record.setCreateTime(LocalDateTime.now());
        
        try {
            // 保存消费记录
            consumeRecordRepository.save(record);
            
            // 处理消息
            processor.process(messageBody);
            
            // 更新消费记录
            record.setConsumeStatus(ConsumeStatus.SUCCESS);
            record.setConsumeEndTime(LocalDateTime.now());
            record.setConsumeDuration(
                Duration.between(record.getConsumeStartTime(), 
                               record.getConsumeEndTime()).toMillis());
            consumeRecordRepository.save(record);
            
            log.info("Message consumed successfully: messageId={}", messageId);
            return ConsumeStatus.SUCCESS;
            
        } catch (Exception e) {
            // 更新消费记录
            record.setConsumeStatus(ConsumeStatus.FAILED);
            record.setConsumeEndTime(LocalDateTime.now());
            record.setErrorMessage(e.getMessage());
            record.setConsumeDuration(
                Duration.between(record.getConsumeStartTime(), 
                               record.getConsumeEndTime()).toMillis());
            consumeRecordRepository.save(record);
            
            log.error("Failed to consume message: messageId={}", messageId, e);
            return ConsumeStatus.RECONSUME_LATER;
        }
    }
    
    /**
     * 获取消费者实例标识
     */
    private String getConsumerInstance() {
        try {
            return InetAddress.getLocalHost().getHostName() + "_" + 
                   ManagementFactory.getRuntimeMXBean().getName();
        } catch (Exception e) {
            return "unknown_instance";
        }
    }
    
    /**
     * 消息处理器接口
     */
    @FunctionalInterface
    public interface MessageProcessor {
        void process(String messageBody) throws Exception;
    }
}
```

## 业务场景应用

### 1. IMSI资源分配消息消费者

```java
/**
 * IMSI资源分配消息消费者
 */
@Component
@RocketMQMessageListener(
    topic = "NSRS_IMSI_TOPIC",
    consumerGroup = "imsi-allocation-consumer-group",
    messageModel = MessageModel.CLUSTERING
)
public class ImsiAllocationConsumer extends BaseMessageConsumer 
    implements RocketMQListener<String> {
    
    @Autowired
    private ImsiResourceService imsiResourceService;
    
    @Autowired
    private BillingService billingService;
    
    @Override
    public void onMessage(String message) {
        try {
            // 解析消息
            ImsiAllocationMessage allocationMessage = 
                JSON.parseObject(message, ImsiAllocationMessage.class);
            
            String messageId = allocationMessage.getMessageId();
            
            // 处理消息
            ConsumeStatus status = handleMessage(messageId, 
                "imsi-allocation-consumer-group", message, messageBody -> {
                
                // 更新IMSI资源状态
                imsiResourceService.updateImsiStatus(
                    allocationMessage.getImsi(), 
                    ImsiStatus.ALLOCATED,
                    allocationMessage.getUserId());
                
                // 创建计费记录
                billingService.createBillingRecord(
                    allocationMessage.getUserId(),
                    allocationMessage.getImsi(),
                    BillingType.IMSI_ALLOCATION,
                    allocationMessage.getAllocationTime());
                
                // 发送激活通知
                sendActivationNotification(allocationMessage);
            });
            
            if (status != ConsumeStatus.SUCCESS) {
                throw new MessageConsumerException("Failed to process IMSI allocation message");
            }
            
        } catch (Exception e) {
            log.error("Error processing IMSI allocation message: {}", message, e);
            throw e;
        }
    }
    
    /**
     * 发送激活通知
     */
    private void sendActivationNotification(ImsiAllocationMessage message) {
        // 发送激活通知消息
        ActivationNotificationMessage notification = new ActivationNotificationMessage();
        notification.setUserId(message.getUserId());
        notification.setImsi(message.getImsi());
        notification.setNotificationType(NotificationType.IMSI_ALLOCATED);
        notification.setCreateTime(LocalDateTime.now());
        
        // 使用消息生产者发送通知
        MessageProducerService producer = SpringContextUtil.getBean(MessageProducerService.class);
        producer.sendMessage("NSRS_NOTIFICATION_TOPIC", "ACTIVATION", notification);
    }
}
```

### 2. SIM卡状态变更消息生产

```java
/**
 * SIM卡服务
 */
@Service
@Transactional
public class SimCardService {
    
    @Autowired
    private SimCardRepository simCardRepository;
    
    @Autowired
    private MessageProducerService messageProducer;
    
    /**
     * 激活SIM卡
     */
    public void activateSimCard(String iccid, String userId) {
        try {
            // 更新SIM卡状态
            SimCard simCard = simCardRepository.findByIccid(iccid)
                .orElseThrow(() -> new SimCardNotFoundException("SIM card not found: " + iccid));
            
            simCard.setStatus(SimCardStatus.ACTIVE);
            simCard.setUserId(userId);
            simCard.setActivationTime(LocalDateTime.now());
            simCard.setUpdateTime(LocalDateTime.now());
            simCardRepository.save(simCard);
            
            // 发送SIM卡激活消息
            SimCardActivationMessage message = new SimCardActivationMessage();
            message.setIccid(iccid);
            message.setUserId(userId);
            message.setImsi(simCard.getImsi());
            message.setActivationTime(simCard.getActivationTime());
            message.setMessageId(generateMessageId());
            
            // 使用顺序消息保证同一SIM卡的消息顺序
            messageProducer.sendOrderlyMessage(
                "NSRS_SIM_CARD_TOPIC", 
                "ACTIVATION", 
                message, 
                iccid);
            
            log.info("SIM card activated successfully: iccid={}, userId={}", iccid, userId);
            
        } catch (Exception e) {
            log.error("Failed to activate SIM card: iccid={}", iccid, e);
            throw new SimCardActivationException("Failed to activate SIM card", e);
        }
    }
    
    /**
     * 暂停SIM卡
     */
    public void suspendSimCard(String iccid, String reason) {
        try {
            // 更新SIM卡状态
            SimCard simCard = simCardRepository.findByIccid(iccid)
                .orElseThrow(() -> new SimCardNotFoundException("SIM card not found: " + iccid));
            
            simCard.setStatus(SimCardStatus.SUSPENDED);
            simCard.setSuspendReason(reason);
            simCard.setSuspendTime(LocalDateTime.now());
            simCard.setUpdateTime(LocalDateTime.now());
            simCardRepository.save(simCard);
            
            // 发送SIM卡暂停消息
            SimCardSuspensionMessage message = new SimCardSuspensionMessage();
            message.setIccid(iccid);
            message.setUserId(simCard.getUserId());
            message.setImsi(simCard.getImsi());
            message.setReason(reason);
            message.setSuspendTime(simCard.getSuspendTime());
            message.setMessageId(generateMessageId());
            
            // 发送高优先级消息
            messageProducer.sendMessage(
                "NSRS_SIM_CARD_TOPIC", 
                "SUSPENSION", 
                message);
            
            log.info("SIM card suspended successfully: iccid={}, reason={}", iccid, reason);
            
        } catch (Exception e) {
            log.error("Failed to suspend SIM card: iccid={}", iccid, e);
            throw new SimCardSuspensionException("Failed to suspend SIM card", e);
        }
    }
    
    private String generateMessageId() {
        return "SIM_" + System.currentTimeMillis() + "_" + 
               ThreadLocalRandom.current().nextInt(1000, 9999);
    }
}
```

## RocketMQ集群配置

### 1. NameServer集群配置

```bash
# nameserver1配置 (namesrv1.conf)
listenPort=9876
serverWorkerThreads=8
serverCallbackExecutorThreads=0
serverSelectorThreads=3
serverOneWayInvokeSemaphore=256
serverAsyncSemaphore=64
bindAddress=0.0.0.0

# nameserver2配置 (namesrv2.conf)
listenPort=9876
serverWorkerThreads=8
serverCallbackExecutorThreads=0
serverSelectorThreads=3
serverOneWayInvokeSemaphore=256
serverAsyncSemaphore=64
bindAddress=0.0.0.0
```

### 2. Broker主从配置

```bash
# broker-master配置 (broker-a.conf)
brokerClusterName=nsrs-cluster
brokerName=broker-a
brokerId=0
namesrvAddr=nameserver1:9876;nameserver2:9876
defaultTopicQueueNums=4
autoCreateTopicEnable=true
autoCreateSubscriptionGroup=true
listenPort=10911
deleteWhen=04
fileReservedTime=120
mapedFileSizeCommitLog=1073741824
mapedFileSizeConsumeQueue=300000
destroyMapedFileIntervalForcibly=120000
redeleteHangedFileInterval=120000
diskMaxUsedSpaceRatio=88
storePathRootDir=/opt/rocketmq/store
storePathCommitLog=/opt/rocketmq/store/commitlog
storePathConsumeQueue=/opt/rocketmq/store/consumequeue
storePathIndex=/opt/rocketmq/store/index
storeCheckpoint=/opt/rocketmq/store/checkpoint
abortFile=/opt/rocketmq/store/abort
maxMessageSize=65536
flushCommitLogLeastPages=4
flushConsumeQueueLeastPages=2
flushCommitLogThoroughInterval=10000
flushConsumeQueueThoroughInterval=60000
checkTransactionMessageEnable=false
sendMessageThreadPoolNums=128
pullMessageThreadPoolNums=128

# broker-slave配置 (broker-a-s.conf)
brokerClusterName=nsrs-cluster
brokerName=broker-a
brokerId=1
namesrvAddr=nameserver1:9876;nameserver2:9876
defaultTopicQueueNums=4
autoCreateTopicEnable=true
autoCreateSubscriptionGroup=true
listenPort=10911
deleteWhen=04
fileReservedTime=120
mapedFileSizeCommitLog=1073741824
mapedFileSizeConsumeQueue=300000
storePathRootDir=/opt/rocketmq/store-slave
storePathCommitLog=/opt/rocketmq/store-slave/commitlog
storePathConsumeQueue=/opt/rocketmq/store-slave/consumequeue
storePathIndex=/opt/rocketmq/store-slave/index
storeCheckpoint=/opt/rocketmq/store-slave/checkpoint
abortFile=/opt/rocketmq/store-slave/abort
```

### 3. Spring Boot配置

```yaml
# application.yml
rocketmq:
  name-server: nameserver1:9876;nameserver2:9876
  producer:
    group: nsrs-producer-group
    send-message-timeout: 3000
    compress-message-body-threshold: 4096
    max-message-size: 4194304
    retry-times-when-send-failed: 2
    retry-times-when-send-async-failed: 2
    retry-next-server: true
    access-key: ${ROCKETMQ_ACCESS_KEY:}
    secret-key: ${ROCKETMQ_SECRET_KEY:}
  consumer:
    access-key: ${ROCKETMQ_ACCESS_KEY:}
    secret-key: ${ROCKETMQ_SECRET_KEY:}

# 自定义配置
nsrs:
  mq:
    topics:
      imsi: NSRS_IMSI_TOPIC
      sim-card: NSRS_SIM_CARD_TOPIC
      billing: NSRS_BILLING_TOPIC
      notification: NSRS_NOTIFICATION_TOPIC
      audit: NSRS_AUDIT_TOPIC
    consumer-groups:
      imsi-allocation: imsi-allocation-consumer-group
      billing-settlement: billing-settlement-consumer-group
      notification: notification-consumer-group
```

## 监控与运维

### 1. RocketMQ Console部署

```yaml
# docker-compose.yml
version: '3.8'
services:
  rocketmq-console:
    image: apacherocketmq/rocketmq-console:2.0.0
    container_name: rocketmq-console
    ports:
      - "8080:8080"
    environment:
      JAVA_OPTS: "-Drocketmq.namesrv.addr=nameserver1:9876;nameserver2:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false"
    depends_on:
      - nameserver1
      - nameserver2
    networks:
      - rocketmq-network

networks:
  rocketmq-network:
    driver: bridge
```

### 2. 监控指标收集

```java
/**
 * RocketMQ监控服务
 */
@Service
@Slf4j
public class RocketMQMonitoringService {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Autowired
    private MqMessageRepository messageRepository;
    
    @Autowired
    private MqConsumeRecordRepository consumeRecordRepository;
    
    /**
     * 记录消息发送指标
     */
    public void recordMessageSent(String topic, String tag, boolean success) {
        Counter.builder("rocketmq.message.sent")
            .tag("topic", topic)
            .tag("tag", tag)
            .tag("status", success ? "success" : "failed")
            .register(meterRegistry)
            .increment();
    }
    
    /**
     * 记录消息消费指标
     */
    public void recordMessageConsumed(String topic, String consumerGroup, 
                                    long consumeTime, boolean success) {
        // 消费计数
        Counter.builder("rocketmq.message.consumed")
            .tag("topic", topic)
            .tag("consumer_group", consumerGroup)
            .tag("status", success ? "success" : "failed")
            .register(meterRegistry)
            .increment();
        
        // 消费耗时
        Timer.builder("rocketmq.message.consume.duration")
            .tag("topic", topic)
            .tag("consumer_group", consumerGroup)
            .register(meterRegistry)
            .record(consumeTime, TimeUnit.MILLISECONDS);
    }
    
    /**
     * 获取消息积压情况
     */
    @Scheduled(fixedRate = 60000) // 每分钟执行一次
    public void recordMessageBacklog() {
        try {
            // 统计各状态消息数量
            Map<MessageStatus, Long> statusCount = messageRepository
                .countByStatusGroupBy();
            
            statusCount.forEach((status, count) -> {
                Gauge.builder("rocketmq.message.backlog")
                    .tag("status", status.getCode())
                    .register(meterRegistry, count);
            });
            
            // 统计消费延迟
            List<ConsumeDelayInfo> delayInfos = consumeRecordRepository
                .findConsumeDelayInfo();
            
            delayInfos.forEach(info -> {
                Gauge.builder("rocketmq.consume.delay")
                    .tag("consumer_group", info.getConsumerGroup())
                    .register(meterRegistry, info.getAvgDelay());
            });
            
        } catch (Exception e) {
            log.error("Failed to record message backlog metrics", e);
        }
    }
    
    /**
     * 获取Topic统计信息
     */
    public Map<String, Object> getTopicStats(String topic) {
        Map<String, Object> stats = new HashMap<>();
        
        // 消息总数
        Long totalMessages = messageRepository.countByTopic(topic);
        stats.put("totalMessages", totalMessages);
        
        // 各状态消息数
        Map<MessageStatus, Long> statusCount = messageRepository
            .countByTopicAndStatusGroupBy(topic);
        stats.put("statusCount", statusCount);
        
        // 今日消息数
        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
        Long todayMessages = messageRepository
            .countByTopicAndCreateTimeAfter(topic, startOfDay);
        stats.put("todayMessages", todayMessages);
        
        return stats;
    }
}
```

## 最佳实践

### 1. 消息设计原则

#### 消息幂等性
- **消息去重**: 使用业务唯一标识作为消息Key
- **幂等处理**: 消费者端实现幂等逻辑
- **状态检查**: 处理前检查业务状态

#### 消息可靠性
- **持久化存储**: 重要消息持久化到数据库
- **确认机制**: 使用ACK确认消息消费
- **重试机制**: 失败消息自动重试
- **死信队列**: 处理重试失败的消息

### 2. 性能优化

#### 生产者优化
```java
// 批量发送
List<Message> messages = new ArrayList<>();
for (Object data : dataList) {
    Message msg = new Message(topic, tag, JSON.toJSONString(data).getBytes());
    messages.add(msg);
}
producer.send(messages);

// 异步发送
producer.sendAsync(message, new SendCallback() {
    @Override
    public void onSuccess(SendResult sendResult) {
        log.info("Message sent successfully: {}", sendResult.getMsgId());
    }
    
    @Override
    public void onException(Throwable e) {
        log.error("Failed to send message", e);
    }
});
```

#### 消费者优化
```java
// 并发消费配置
@RocketMQMessageListener(
    topic = "NSRS_TOPIC",
    consumerGroup = "consumer-group",
    consumeMode = ConsumeMode.CONCURRENTLY,
    consumeThreadMax = 20,
    maxReconsumeTimes = 3
)
public class OptimizedConsumer implements RocketMQListener<String> {
    
    @Override
    public void onMessage(String message) {
        // 消费逻辑
    }
}
```

### 3. 运维管理

#### 容量规划
- **存储容量**: 根据消息量和保留时间规划存储
- **网络带宽**: 考虑峰值流量的网络需求
- **实例规格**: 根据TPS要求选择合适的实例规格

#### 监控告警
```yaml
# Prometheus告警规则
groups:
  - name: rocketmq.rules
    rules:
      - alert: RocketMQMessageBacklog
        expr: rocketmq_message_backlog{status="pending"} > 1000
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "RocketMQ消息积压"
          description: "Topic {{ $labels.topic }} 消息积压超过1000条"
      
      - alert: RocketMQConsumeDelay
        expr: rocketmq_consume_delay > 30000
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "RocketMQ消费延迟"
          description: "消费组 {{ $labels.consumer_group }} 消费延迟超过30秒"
```

### 4. 安全配置

#### ACL权限控制
```bash
# broker配置
aclEnable=true

# 用户权限配置 (plain_acl.yml)
globalWhiteRemoteAddresses:
  - 10.10.103.*
  - 192.168.0.*

accounts:
  - accessKey: nsrs_producer
    secretKey: producer_secret_key
    whiteRemoteAddress: 192.168.0.*
    admin: false
    defaultTopicPerm: PUB
    topicPerms:
      - NSRS_IMSI_TOPIC=PUB
      - NSRS_SIM_CARD_TOPIC=PUB
  
  - accessKey: nsrs_consumer
    secretKey: consumer_secret_key
    whiteRemoteAddress: 192.168.0.*
    admin: false
    defaultTopicPerm: SUB
    groupPerms:
      - imsi-allocation-consumer-group=SUB
      - billing-settlement-consumer-group=SUB
```

通过以上消息队列架构设计，NSRS号卡资源管理系统实现了高可靠、高性能的异步消息处理能力，支持业务解耦、削峰填谷和分布式事务等关键特性，为系统的可扩展性和稳定性提供了强有力的保障。