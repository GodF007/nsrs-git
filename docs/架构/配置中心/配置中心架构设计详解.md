# 配置中心架构设计详解

基于Apollo的NSRS号卡资源管理系统配置中心解决方案

## 目录

- [配置中心概述](#配置中心概述)
- [核心枚举定义](#核心枚举定义)
- [核心实体设计](#核心实体设计)
- [配置服务实现](#配置服务实现)
- [业务场景应用](#业务场景应用)
- [Apollo集群配置](#apollo集群配置)
- [配置管理最佳实践](#配置管理最佳实践)
- [监控与运维](#监控与运维)

## 配置中心概述

### 设计目标

- **集中管理**: 统一管理所有微服务的配置信息
- **动态更新**: 支持配置的实时推送和热更新
- **环境隔离**: 支持多环境配置管理（开发、测试、生产）
- **权限控制**: 细粒度的配置权限管理
- **版本管理**: 配置变更历史追踪和回滚
- **高可用**: 集群部署，保证配置服务的高可用性

### 配置中心架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    NSRS配置中心架构                           │
├─────────────────────────────────────────────────────────────┤
│                      应用层                                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Gateway   │ │ User Service│ │ IMSI Service│           │
│  │   Service   │ │             │ │             │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│         │               │               │                   │
│         └───────────────┼───────────────┘                   │
│                         │                                   │
├─────────────────────────┼───────────────────────────────────┤
│                    Apollo Client                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Configuration Cache                        │ │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐      │ │
│  │  │Database │ │  Redis  │ │  MQ     │ │Business │      │ │
│  │  │ Config  │ │ Config  │ │ Config  │ │ Config  │      │ │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘      │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                    Apollo Server                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                Apollo Config Service                   │ │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐                  │ │
│  │  │Config   │ │Admin    │ │Portal   │                  │ │
│  │  │Service  │ │Service  │ │Service  │                  │ │
│  │  └─────────┘ └─────────┘ └─────────┘                  │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                      存储层                                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   MySQL     │ │    Redis    │ │   Eureka    │           │
│  │  Database   │ │    Cache    │ │   Registry  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

## 核心枚举定义

### 1. 配置类型枚举

```java
/**
 * 配置类型枚举
 */
public enum ConfigType {
    
    // 数据库配置
    DATABASE("DATABASE", "数据库配置"),
    
    // 缓存配置
    CACHE("CACHE", "缓存配置"),
    
    // 消息队列配置
    MESSAGE_QUEUE("MESSAGE_QUEUE", "消息队列配置"),
    
    // 业务配置
    BUSINESS("BUSINESS", "业务配置"),
    
    // 安全配置
    SECURITY("SECURITY", "安全配置"),
    
    // 监控配置
    MONITORING("MONITORING", "监控配置"),
    
    // 第三方服务配置
    THIRD_PARTY("THIRD_PARTY", "第三方服务配置"),
    
    // 系统配置
    SYSTEM("SYSTEM", "系统配置");
    
    private final String code;
    private final String description;
    
    ConfigType(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

### 2. 环境类型枚举

```java
/**
 * 环境类型枚举
 */
public enum EnvironmentType {
    
    // 开发环境
    DEV("DEV", "开发环境"),
    
    // 测试环境
    TEST("TEST", "测试环境"),
    
    // 预发布环境
    UAT("UAT", "预发布环境"),
    
    // 生产环境
    PROD("PROD", "生产环境"),
    
    // 灰度环境
    GRAY("GRAY", "灰度环境");
    
    private final String code;
    private final String description;
    
    EnvironmentType(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

### 3. 配置状态枚举

```java
/**
 * 配置状态枚举
 */
public enum ConfigStatus {
    
    // 草稿
    DRAFT("DRAFT", "草稿"),
    
    // 待审核
    PENDING_REVIEW("PENDING_REVIEW", "待审核"),
    
    // 已发布
    PUBLISHED("PUBLISHED", "已发布"),
    
    // 已回滚
    ROLLBACK("ROLLBACK", "已回滚"),
    
    // 已删除
    DELETED("DELETED", "已删除");
    
    private final String code;
    private final String description;
    
    ConfigStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

## 核心实体设计

### 1. 配置项实体

```java
/**
 * 配置项实体
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "config_item")
public class ConfigItem {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * 应用ID
     */
    @Column(name = "app_id", nullable = false, length = 64)
    private String appId;
    
    /**
     * 集群名称
     */
    @Column(name = "cluster_name", nullable = false, length = 64)
    private String clusterName;
    
    /**
     * 命名空间
     */
    @Column(name = "namespace_name", nullable = false, length = 64)
    private String namespaceName;
    
    /**
     * 配置键
     */
    @Column(name = "config_key", nullable = false, length = 128)
    private String key;
    
    /**
     * 配置值
     */
    @Column(name = "config_value", columnDefinition = "TEXT")
    private String value;
    
    /**
     * 配置类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "config_type", nullable = false)
    private ConfigType configType;
    
    /**
     * 环境类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "environment", nullable = false)
    private EnvironmentType environment;
    
    /**
     * 配置状态
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private ConfigStatus status;
    
    /**
     * 是否敏感配置
     */
    @Column(name = "is_sensitive", nullable = false)
    private Boolean sensitive;
    
    /**
     * 是否加密
     */
    @Column(name = "is_encrypted", nullable = false)
    private Boolean encrypted;
    
    /**
     * 配置描述
     */
    @Column(name = "description", length = 500)
    private String description;
    
    /**
     * 标签
     */
    @Column(name = "tags", length = 500)
    private String tags;
    
    /**
     * 创建人
     */
    @Column(name = "created_by", nullable = false, length = 64)
    private String createdBy;
    
    /**
     * 更新人
     */
    @Column(name = "updated_by", length = 64)
    private String updatedBy;
    
    /**
     * 创建时间
     */
    @Column(name = "create_time", nullable = false)
    private LocalDateTime createTime;
    
    /**
     * 更新时间
     */
    @Column(name = "update_time")
    private LocalDateTime updateTime;
    
    /**
     * 版本号
     */
    @Version
    @Column(name = "version")
    private Long version;
}
```

### 2. 配置变更记录实体

```java
/**
 * 配置变更记录实体
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "config_change_log")
public class ConfigChangeLog {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * 配置项ID
     */
    @Column(name = "config_item_id", nullable = false)
    private Long configItemId;
    
    /**
     * 变更类型
     */
    @Column(name = "change_type", nullable = false, length = 32)
    private String changeType; // CREATE, UPDATE, DELETE, ROLLBACK
    
    /**
     * 变更前的值
     */
    @Column(name = "old_value", columnDefinition = "TEXT")
    private String oldValue;
    
    /**
     * 变更后的值
     */
    @Column(name = "new_value", columnDefinition = "TEXT")
    private String newValue;
    
    /**
     * 变更原因
     */
    @Column(name = "change_reason", length = 500)
    private String changeReason;
    
    /**
     * 操作人
     */
    @Column(name = "operator", nullable = false, length = 64)
    private String operator;
    
    /**
     * 操作时间
     */
    @Column(name = "operation_time", nullable = false)
    private LocalDateTime operationTime;
    
    /**
     * 发布时间
     */
    @Column(name = "release_time")
    private LocalDateTime releaseTime;
    
    /**
     * 发布批次ID
     */
    @Column(name = "release_id", length = 64)
    private String releaseId;
    
    /**
     * 是否已发布
     */
    @Column(name = "is_released", nullable = false)
    private Boolean released;
}
```

### 3. 配置监听器实体

```java
/**
 * 配置监听器实体
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ConfigListener {
    
    /**
     * 监听器ID
     */
    private String listenerId;
    
    /**
     * 应用ID
     */
    private String appId;
    
    /**
     * 集群名称
     */
    private String clusterName;
    
    /**
     * 命名空间
     */
    private String namespaceName;
    
    /**
     * 监听的配置键
     */
    private Set<String> configKeys;
    
    /**
     * 回调处理器
     */
    private ConfigChangeHandler handler;
    
    /**
     * 是否启用
     */
    private Boolean enabled;
    
    /**
     * 创建时间
     */
    private LocalDateTime createTime;
}
```

## 配置服务实现

### 1. 配置管理服务

```java
/**
 * 配置管理服务
 */
@Service
@Slf4j
public class ConfigManagementService {
    
    @Autowired
    private ConfigItemRepository configItemRepository;
    
    @Autowired
    private ConfigChangeLogRepository configChangeLogRepository;
    
    @Autowired
    private ApolloConfigService apolloConfigService;
    
    @Autowired
    private ConfigEncryptionService encryptionService;
    
    /**
     * 创建配置项
     */
    @Transactional
    public ConfigItem createConfig(ConfigCreateRequest request) {
        // 验证配置项是否已存在
        if (configExists(request.getAppId(), request.getClusterName(), 
                        request.getNamespaceName(), request.getKey())) {
            throw new ConfigException("配置项已存在");
        }
        
        // 处理敏感配置加密
        String configValue = request.getValue();
        boolean encrypted = false;
        if (request.getSensitive() && StringUtils.hasText(configValue)) {
            configValue = encryptionService.encrypt(configValue);
            encrypted = true;
        }
        
        // 创建配置项
        ConfigItem configItem = ConfigItem.builder()
            .appId(request.getAppId())
            .clusterName(request.getClusterName())
            .namespaceName(request.getNamespaceName())
            .key(request.getKey())
            .value(configValue)
            .configType(request.getConfigType())
            .environment(request.getEnvironment())
            .status(ConfigStatus.DRAFT)
            .sensitive(request.getSensitive())
            .encrypted(encrypted)
            .description(request.getDescription())
            .tags(request.getTags())
            .createdBy(request.getOperator())
            .createTime(LocalDateTime.now())
            .version(1L)
            .build();
        
        configItem = configItemRepository.save(configItem);
        
        // 记录变更日志
        recordChangeLog(configItem, "CREATE", null, configValue, 
                       "创建配置项", request.getOperator());
        
        log.info("Config item created: appId={}, key={}, operator={}", 
                request.getAppId(), request.getKey(), request.getOperator());
        
        return configItem;
    }
    
    /**
     * 更新配置项
     */
    @Transactional
    public ConfigItem updateConfig(Long configId, ConfigUpdateRequest request) {
        ConfigItem configItem = configItemRepository.findById(configId)
            .orElseThrow(() -> new ConfigException("配置项不存在"));
        
        // 检查权限
        validateUpdatePermission(configItem, request.getOperator());
        
        String oldValue = configItem.getValue();
        String newValue = request.getValue();
        
        // 处理敏感配置加密
        boolean encrypted = false;
        if (configItem.getSensitive() && StringUtils.hasText(newValue)) {
            newValue = encryptionService.encrypt(newValue);
            encrypted = true;
        }
        
        // 更新配置项
        configItem.setValue(newValue);
        configItem.setEncrypted(encrypted);
        configItem.setDescription(request.getDescription());
        configItem.setTags(request.getTags());
        configItem.setUpdatedBy(request.getOperator());
        configItem.setUpdateTime(LocalDateTime.now());
        configItem.setStatus(ConfigStatus.DRAFT);
        
        configItem = configItemRepository.save(configItem);
        
        // 记录变更日志
        recordChangeLog(configItem, "UPDATE", oldValue, newValue, 
                       request.getChangeReason(), request.getOperator());
        
        log.info("Config item updated: id={}, key={}, operator={}", 
                configId, configItem.getKey(), request.getOperator());
        
        return configItem;
    }
    
    /**
     * 发布配置
     */
    @Transactional
    public void publishConfig(Long configId, String operator, String releaseNote) {
        ConfigItem configItem = configItemRepository.findById(configId)
            .orElseThrow(() -> new ConfigException("配置项不存在"));
        
        // 检查发布权限
        validatePublishPermission(configItem, operator);
        
        // 发布到Apollo
        String releaseId = apolloConfigService.publishConfig(
            configItem.getAppId(),
            configItem.getClusterName(),
            configItem.getNamespaceName(),
            configItem.getKey(),
            configItem.getValue(),
            releaseNote,
            operator
        );
        
        // 更新配置状态
        configItem.setStatus(ConfigStatus.PUBLISHED);
        configItem.setUpdatedBy(operator);
        configItem.setUpdateTime(LocalDateTime.now());
        configItemRepository.save(configItem);
        
        // 更新变更日志
        updateChangeLogReleaseInfo(configItem.getId(), releaseId, LocalDateTime.now());
        
        log.info("Config published: id={}, key={}, releaseId={}, operator={}", 
                configId, configItem.getKey(), releaseId, operator);
    }
    
    /**
     * 回滚配置
     */
    @Transactional
    public void rollbackConfig(Long configId, Long targetVersion, String operator) {
        ConfigItem configItem = configItemRepository.findById(configId)
            .orElseThrow(() -> new ConfigException("配置项不存在"));
        
        // 检查回滚权限
        validateRollbackPermission(configItem, operator);
        
        // 获取目标版本的配置值
        ConfigChangeLog targetLog = configChangeLogRepository
            .findByConfigItemIdAndVersion(configId, targetVersion)
            .orElseThrow(() -> new ConfigException("目标版本不存在"));
        
        String oldValue = configItem.getValue();
        String rollbackValue = targetLog.getNewValue();
        
        // 执行回滚
        configItem.setValue(rollbackValue);
        configItem.setStatus(ConfigStatus.ROLLBACK);
        configItem.setUpdatedBy(operator);
        configItem.setUpdateTime(LocalDateTime.now());
        configItemRepository.save(configItem);
        
        // 发布回滚后的配置
        String releaseId = apolloConfigService.publishConfig(
            configItem.getAppId(),
            configItem.getClusterName(),
            configItem.getNamespaceName(),
            configItem.getKey(),
            rollbackValue,
            "回滚到版本: " + targetVersion,
            operator
        );
        
        // 记录回滚日志
        recordChangeLog(configItem, "ROLLBACK", oldValue, rollbackValue, 
                       "回滚到版本: " + targetVersion, operator);
        
        log.info("Config rollback: id={}, targetVersion={}, operator={}", 
                configId, targetVersion, operator);
    }
    
    /**
     * 获取配置值
     */
    public String getConfigValue(String appId, String clusterName, 
                               String namespaceName, String key) {
        ConfigItem configItem = configItemRepository
            .findByAppIdAndClusterNameAndNamespaceNameAndKey(
                appId, clusterName, namespaceName, key)
            .orElse(null);
        
        if (configItem == null) {
            return null;
        }
        
        String value = configItem.getValue();
        
        // 解密敏感配置
        if (configItem.getEncrypted() && StringUtils.hasText(value)) {
            value = encryptionService.decrypt(value);
        }
        
        return value;
    }
    
    /**
     * 批量获取配置
     */
    public Map<String, String> getConfigs(String appId, String clusterName, 
                                         String namespaceName) {
        List<ConfigItem> configItems = configItemRepository
            .findByAppIdAndClusterNameAndNamespaceNameAndStatus(
                appId, clusterName, namespaceName, ConfigStatus.PUBLISHED);
        
        Map<String, String> configs = new HashMap<>();
        
        for (ConfigItem item : configItems) {
            String value = item.getValue();
            
            // 解密敏感配置
            if (item.getEncrypted() && StringUtils.hasText(value)) {
                value = encryptionService.decrypt(value);
            }
            
            configs.put(item.getKey(), value);
        }
        
        return configs;
    }
    
    /**
     * 检查配置是否存在
     */
    private boolean configExists(String appId, String clusterName, 
                                String namespaceName, String key) {
        return configItemRepository
            .findByAppIdAndClusterNameAndNamespaceNameAndKey(
                appId, clusterName, namespaceName, key)
            .isPresent();
    }
    
    /**
     * 记录变更日志
     */
    private void recordChangeLog(ConfigItem configItem, String changeType, 
                               String oldValue, String newValue, 
                               String changeReason, String operator) {
        ConfigChangeLog changeLog = ConfigChangeLog.builder()
            .configItemId(configItem.getId())
            .changeType(changeType)
            .oldValue(oldValue)
            .newValue(newValue)
            .changeReason(changeReason)
            .operator(operator)
            .operationTime(LocalDateTime.now())
            .released(false)
            .build();
        
        configChangeLogRepository.save(changeLog);
    }
    
    /**
     * 更新变更日志发布信息
     */
    private void updateChangeLogReleaseInfo(Long configItemId, String releaseId, 
                                          LocalDateTime releaseTime) {
        List<ConfigChangeLog> logs = configChangeLogRepository
            .findByConfigItemIdAndReleasedFalse(configItemId);
        
        for (ConfigChangeLog log : logs) {
            log.setReleaseId(releaseId);
            log.setReleaseTime(releaseTime);
            log.setReleased(true);
        }
        
        configChangeLogRepository.saveAll(logs);
    }
    
    /**
     * 验证更新权限
     */
    private void validateUpdatePermission(ConfigItem configItem, String operator) {
        // TODO: 实现权限验证逻辑
    }
    
    /**
     * 验证发布权限
     */
    private void validatePublishPermission(ConfigItem configItem, String operator) {
        // TODO: 实现权限验证逻辑
    }
    
    /**
     * 验证回滚权限
     */
    private void validateRollbackPermission(ConfigItem configItem, String operator) {
        // TODO: 实现权限验证逻辑
    }
}
```

### 2. Apollo配置服务

```java
/**
 * Apollo配置服务
 */
@Service
@Slf4j
public class ApolloConfigService {
    
    @Value("${apollo.config.service.url}")
    private String apolloConfigServiceUrl;
    
    @Value("${apollo.admin.service.url}")
    private String apolloAdminServiceUrl;
    
    @Autowired
    private RestTemplate restTemplate;
    
    /**
     * 发布配置到Apollo
     */
    public String publishConfig(String appId, String clusterName, String namespaceName,
                              String key, String value, String releaseNote, String operator) {
        try {
            // 构建发布请求
            Map<String, Object> releaseRequest = new HashMap<>();
            releaseRequest.put("releaseTitle", "Release-" + System.currentTimeMillis());
            releaseRequest.put("releaseComment", releaseNote);
            releaseRequest.put("releasedBy", operator);
            
            // 构建配置项
            Map<String, String> configurations = new HashMap<>();
            configurations.put(key, value);
            releaseRequest.put("configurations", configurations);
            
            // 发送发布请求
            String url = String.format("%s/apps/%s/clusters/%s/namespaces/%s/releases",
                apolloAdminServiceUrl, appId, clusterName, namespaceName);
            
            ResponseEntity<Map> response = restTemplate.postForEntity(
                url, releaseRequest, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> responseBody = response.getBody();
                String releaseId = (String) responseBody.get("id");
                
                log.info("Config published to Apollo: appId={}, key={}, releaseId={}", 
                        appId, key, releaseId);
                
                return releaseId;
            } else {
                throw new ConfigException("Failed to publish config to Apollo");
            }
            
        } catch (Exception e) {
            log.error("Failed to publish config to Apollo: appId={}, key={}", appId, key, e);
            throw new ConfigException("发布配置到Apollo失败", e);
        }
    }
    
    /**
     * 从Apollo获取配置
     */
    public Map<String, String> getConfigFromApollo(String appId, String clusterName, 
                                                  String namespaceName) {
        try {
            String url = String.format("%s/configs/%s/%s/%s",
                apolloConfigServiceUrl, appId, clusterName, namespaceName);
            
            ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> responseBody = response.getBody();
                Map<String, String> configurations = 
                    (Map<String, String>) responseBody.get("configurations");
                
                return configurations != null ? configurations : new HashMap<>();
            } else {
                log.warn("Failed to get config from Apollo: appId={}, namespace={}", 
                        appId, namespaceName);
                return new HashMap<>();
            }
            
        } catch (Exception e) {
            log.error("Failed to get config from Apollo: appId={}, namespace={}", 
                     appId, namespaceName, e);
            return new HashMap<>();
        }
    }
    
    /**
     * 创建应用
     */
    public void createApp(String appId, String appName, String ownerName, String ownerEmail) {
        try {
            Map<String, Object> appRequest = new HashMap<>();
            appRequest.put("appId", appId);
            appRequest.put("name", appName);
            appRequest.put("ownerName", ownerName);
            appRequest.put("ownerEmail", ownerEmail);
            appRequest.put("orgId", "default");
            appRequest.put("orgName", "default");
            
            String url = apolloAdminServiceUrl + "/apps";
            
            ResponseEntity<Map> response = restTemplate.postForEntity(
                url, appRequest, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                log.info("App created in Apollo: appId={}, appName={}", appId, appName);
            } else {
                log.warn("Failed to create app in Apollo: appId={}", appId);
            }
            
        } catch (Exception e) {
            log.error("Failed to create app in Apollo: appId={}", appId, e);
        }
    }
    
    /**
     * 创建命名空间
     */
    public void createNamespace(String appId, String namespaceName, String format) {
        try {
            Map<String, Object> namespaceRequest = new HashMap<>();
            namespaceRequest.put("name", namespaceName);
            namespaceRequest.put("appId", appId);
            namespaceRequest.put("format", format); // properties, xml, json, yml, yaml
            namespaceRequest.put("isPublic", false);
            namespaceRequest.put("comment", "Auto created namespace");
            
            String url = String.format("%s/apps/%s/appnamespaces", 
                apolloAdminServiceUrl, appId);
            
            ResponseEntity<Map> response = restTemplate.postForEntity(
                url, namespaceRequest, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                log.info("Namespace created in Apollo: appId={}, namespace={}", 
                        appId, namespaceName);
            } else {
                log.warn("Failed to create namespace in Apollo: appId={}, namespace={}", 
                        appId, namespaceName);
            }
            
        } catch (Exception e) {
            log.error("Failed to create namespace in Apollo: appId={}, namespace={}", 
                     appId, namespaceName, e);
        }
    }
}
```

### 3. 配置监听服务

```java
/**
 * 配置监听服务
 */
@Service
@Slf4j
public class ConfigListenerService {
    
    private final Map<String, ConfigListener> listeners = new ConcurrentHashMap<>();
    
    @Autowired
    private ConfigManagementService configManagementService;
    
    /**
     * 注册配置监听器
     */
    public void registerListener(String appId, String clusterName, String namespaceName,
                               Set<String> configKeys, ConfigChangeHandler handler) {
        String listenerId = generateListenerId(appId, clusterName, namespaceName);
        
        ConfigListener listener = ConfigListener.builder()
            .listenerId(listenerId)
            .appId(appId)
            .clusterName(clusterName)
            .namespaceName(namespaceName)
            .configKeys(configKeys)
            .handler(handler)
            .enabled(true)
            .createTime(LocalDateTime.now())
            .build();
        
        listeners.put(listenerId, listener);
        
        log.info("Config listener registered: appId={}, namespace={}, keys={}", 
                appId, namespaceName, configKeys);
    }
    
    /**
     * 注销配置监听器
     */
    public void unregisterListener(String appId, String clusterName, String namespaceName) {
        String listenerId = generateListenerId(appId, clusterName, namespaceName);
        
        ConfigListener listener = listeners.remove(listenerId);
        if (listener != null) {
            log.info("Config listener unregistered: appId={}, namespace={}", 
                    appId, namespaceName);
        }
    }
    
    /**
     * 处理配置变更事件
     */
    @EventListener
    @Async
    public void handleConfigChange(ConfigChangeEvent event) {
        String appId = event.getAppId();
        String clusterName = event.getClusterName();
        String namespaceName = event.getNamespaceName();
        String configKey = event.getConfigKey();
        String oldValue = event.getOldValue();
        String newValue = event.getNewValue();
        
        String listenerId = generateListenerId(appId, clusterName, namespaceName);
        ConfigListener listener = listeners.get(listenerId);
        
        if (listener != null && listener.getEnabled() && 
            listener.getConfigKeys().contains(configKey)) {
            
            try {
                ConfigChange change = ConfigChange.builder()
                    .appId(appId)
                    .clusterName(clusterName)
                    .namespaceName(namespaceName)
                    .key(configKey)
                    .oldValue(oldValue)
                    .newValue(newValue)
                    .changeTime(LocalDateTime.now())
                    .build();
                
                listener.getHandler().onChange(change);
                
                log.info("Config change handled: appId={}, key={}, listener={}", 
                        appId, configKey, listenerId);
                
            } catch (Exception e) {
                log.error("Failed to handle config change: appId={}, key={}", 
                         appId, configKey, e);
            }
        }
    }
    
    /**
     * 生成监听器ID
     */
    private String generateListenerId(String appId, String clusterName, String namespaceName) {
        return String.format("%s-%s-%s", appId, clusterName, namespaceName);
    }
    
    /**
     * 获取所有监听器
     */
    public List<ConfigListener> getAllListeners() {
        return new ArrayList<>(listeners.values());
    }
    
    /**
     * 启用/禁用监听器
     */
    public void toggleListener(String listenerId, boolean enabled) {
        ConfigListener listener = listeners.get(listenerId);
        if (listener != null) {
            listener.setEnabled(enabled);
            log.info("Config listener toggled: id={}, enabled={}", listenerId, enabled);
        }
    }
}
```

## 业务场景应用

### 1. 配置管理控制器

```java
/**
 * 配置管理控制器
 */
@RestController
@RequestMapping("/api/config")
@Slf4j
public class ConfigController {
    
    @Autowired
    private ConfigManagementService configManagementService;
    
    @Autowired
    private ConfigListenerService configListenerService;
    
    /**
     * 创建配置项
     */
    @PostMapping
    public ApiResponse<ConfigItem> createConfig(@RequestBody @Valid ConfigCreateRequest request) {
        try {
            ConfigItem configItem = configManagementService.createConfig(request);
            return ApiResponse.success(configItem);
        } catch (Exception e) {
            log.error("Failed to create config", e);
            return ApiResponse.error("创建配置失败: " + e.getMessage());
        }
    }
    
    /**
     * 更新配置项
     */
    @PutMapping("/{configId}")
    public ApiResponse<ConfigItem> updateConfig(@PathVariable Long configId,
                                              @RequestBody @Valid ConfigUpdateRequest request) {
        try {
            ConfigItem configItem = configManagementService.updateConfig(configId, request);
            return ApiResponse.success(configItem);
        } catch (Exception e) {
            log.error("Failed to update config: id={}", configId, e);
            return ApiResponse.error("更新配置失败: " + e.getMessage());
        }
    }
    
    /**
     * 发布配置
     */
    @PostMapping("/{configId}/publish")
    public ApiResponse<Void> publishConfig(@PathVariable Long configId,
                                         @RequestParam String operator,
                                         @RequestParam(required = false) String releaseNote) {
        try {
            configManagementService.publishConfig(configId, operator, releaseNote);
            return ApiResponse.success();
        } catch (Exception e) {
            log.error("Failed to publish config: id={}", configId, e);
            return ApiResponse.error("发布配置失败: " + e.getMessage());
        }
    }
    
    /**
     * 回滚配置
     */
    @PostMapping("/{configId}/rollback")
    public ApiResponse<Void> rollbackConfig(@PathVariable Long configId,
                                          @RequestParam Long targetVersion,
                                          @RequestParam String operator) {
        try {
            configManagementService.rollbackConfig(configId, targetVersion, operator);
            return ApiResponse.success();
        } catch (Exception e) {
            log.error("Failed to rollback config: id={}, targetVersion={}", 
                     configId, targetVersion, e);
            return ApiResponse.error("回滚配置失败: " + e.getMessage());
        }
    }
    
    /**
     * 获取配置值
     */
    @GetMapping("/value")
    public ApiResponse<String> getConfigValue(@RequestParam String appId,
                                            @RequestParam String clusterName,
                                            @RequestParam String namespaceName,
                                            @RequestParam String key) {
        try {
            String value = configManagementService.getConfigValue(
                appId, clusterName, namespaceName, key);
            return ApiResponse.success(value);
        } catch (Exception e) {
            log.error("Failed to get config value: appId={}, key={}", appId, key, e);
            return ApiResponse.error("获取配置值失败: " + e.getMessage());
        }
    }
    
    /**
     * 批量获取配置
     */
    @GetMapping("/batch")
    public ApiResponse<Map<String, String>> getConfigs(@RequestParam String appId,
                                                      @RequestParam String clusterName,
                                                      @RequestParam String namespaceName) {
        try {
            Map<String, String> configs = configManagementService.getConfigs(
                appId, clusterName, namespaceName);
            return ApiResponse.success(configs);
        } catch (Exception e) {
            log.error("Failed to get configs: appId={}, namespace={}", 
                     appId, namespaceName, e);
            return ApiResponse.error("获取配置失败: " + e.getMessage());
        }
    }
    
    /**
     * 获取配置变更历史
     */
    @GetMapping("/{configId}/history")
    public ApiResponse<List<ConfigChangeLog>> getConfigHistory(@PathVariable Long configId) {
        try {
            List<ConfigChangeLog> history = configManagementService.getConfigHistory(configId);
            return ApiResponse.success(history);
        } catch (Exception e) {
            log.error("Failed to get config history: id={}", configId, e);
            return ApiResponse.error("获取配置历史失败: " + e.getMessage());
        }
    }
}
```

### 2. 配置自动刷新组件

```java
/**
 * 配置自动刷新组件
 */
@Component
@Slf4j
public class ConfigAutoRefreshComponent {
    
    @Autowired
    private ConfigListenerService configListenerService;
    
    @Autowired
    private ApplicationContext applicationContext;
    
    /**
     * 应用启动后注册配置监听器
     */
    @EventListener
    public void onApplicationReady(ApplicationReadyEvent event) {
        registerConfigListeners();
    }
    
    /**
     * 注册配置监听器
     */
    private void registerConfigListeners() {
        // 注册数据库配置监听器
        configListenerService.registerListener(
            "nsrs-user-service",
            "default",
            "application",
            Set.of("spring.datasource.url", "spring.datasource.username", 
                  "spring.datasource.password"),
            new DatabaseConfigChangeHandler()
        );
        
        // 注册Redis配置监听器
        configListenerService.registerListener(
            "nsrs-user-service",
            "default",
            "application",
            Set.of("spring.redis.host", "spring.redis.port", "spring.redis.password"),
            new RedisConfigChangeHandler()
        );
        
        // 注册业务配置监听器
        configListenerService.registerListener(
            "nsrs-imsi-service",
            "default",
            "business",
            Set.of("imsi.allocation.batch.size", "imsi.allocation.timeout"),
            new BusinessConfigChangeHandler()
        );
    }
    
    /**
     * 数据库配置变更处理器
     */
    private class DatabaseConfigChangeHandler implements ConfigChangeHandler {
        @Override
        public void onChange(ConfigChange change) {
            log.info("Database config changed: key={}, oldValue={}, newValue={}", 
                    change.getKey(), change.getOldValue(), change.getNewValue());
            
            // 重新初始化数据源
            if (change.getKey().startsWith("spring.datasource")) {
                refreshDataSource();
            }
        }
        
        private void refreshDataSource() {
            try {
                // 获取数据源Bean
                DataSource dataSource = applicationContext.getBean(DataSource.class);
                
                // 如果是HikariDataSource，可以动态更新连接池配置
                if (dataSource instanceof HikariDataSource) {
                    HikariDataSource hikariDataSource = (HikariDataSource) dataSource;
                    // 这里可以实现动态更新逻辑
                    log.info("DataSource refreshed");
                }
            } catch (Exception e) {
                log.error("Failed to refresh data source", e);
            }
        }
    }
    
    /**
     * Redis配置变更处理器
     */
    private class RedisConfigChangeHandler implements ConfigChangeHandler {
        @Override
        public void onChange(ConfigChange change) {
            log.info("Redis config changed: key={}, oldValue={}, newValue={}", 
                    change.getKey(), change.getOldValue(), change.getNewValue());
            
            // 重新初始化Redis连接
            if (change.getKey().startsWith("spring.redis")) {
                refreshRedisConnection();
            }
        }
        
        private void refreshRedisConnection() {
            try {
                // 获取Redis模板Bean
                RedisTemplate<String, Object> redisTemplate = 
                    applicationContext.getBean("redisTemplate", RedisTemplate.class);
                
                // 重新初始化连接工厂
                log.info("Redis connection refreshed");
            } catch (Exception e) {
                log.error("Failed to refresh Redis connection", e);
            }
        }
    }
    
    /**
     * 业务配置变更处理器
     */
    private class BusinessConfigChangeHandler implements ConfigChangeHandler {
        @Override
        public void onChange(ConfigChange change) {
            log.info("Business config changed: key={}, oldValue={}, newValue={}", 
                    change.getKey(), change.getOldValue(), change.getNewValue());
            
            // 刷新业务配置
            refreshBusinessConfig(change);
        }
        
        private void refreshBusinessConfig(ConfigChange change) {
            try {
                // 发布配置变更事件
                applicationContext.publishEvent(new BusinessConfigChangedEvent(
                    change.getKey(), change.getOldValue(), change.getNewValue()));
                
                log.info("Business config refreshed: key={}", change.getKey());
            } catch (Exception e) {
                log.error("Failed to refresh business config: key={}", 
                         change.getKey(), e);
            }
        }
    }
}
```

## Apollo集群配置

### 1. Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'
services:
  apollo-configdb:
    image: mysql:8.0
    container_name: apollo-configdb
    environment:
      MYSQL_ROOT_PASSWORD: apollo123
      MYSQL_DATABASE: ApolloConfigDB
      MYSQL_USER: apollo
      MYSQL_PASSWORD: apollo123
    volumes:
      - apollo-configdb-data:/var/lib/mysql
      - ./sql/apolloconfigdb.sql:/docker-entrypoint-initdb.d/apolloconfigdb.sql
    ports:
      - "3306:3306"
    networks:
      - apollo-network

  apollo-portaldb:
    image: mysql:8.0
    container_name: apollo-portaldb
    environment:
      MYSQL_ROOT_PASSWORD: apollo123
      MYSQL_DATABASE: ApolloPortalDB
      MYSQL_USER: apollo
      MYSQL_PASSWORD: apollo123
    volumes:
      - apollo-portaldb-data:/var/lib/mysql
      - ./sql/apolloportaldb.sql:/docker-entrypoint-initdb.d/apolloportaldb.sql
    ports:
      - "3307:3306"
    networks:
      - apollo-network

  apollo-configservice:
    image: apolloconfig/apollo-configservice:2.0.1
    container_name: apollo-configservice
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://apollo-configdb:3306/ApolloConfigDB?characterEncoding=utf8&serverTimezone=Asia/Shanghai
      SPRING_DATASOURCE_USERNAME: apollo
      SPRING_DATASOURCE_PASSWORD: apollo123
      EUREKA_INSTANCE_IP_ADDRESS: apollo-configservice
    ports:
      - "8080:8080"
    depends_on:
      - apollo-configdb
    networks:
      - apollo-network

  apollo-adminservice:
    image: apolloconfig/apollo-adminservice:2.0.1
    container_name: apollo-adminservice
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://apollo-configdb:3306/ApolloConfigDB?characterEncoding=utf8&serverTimezone=Asia/Shanghai
      SPRING_DATASOURCE_USERNAME: apollo
      SPRING_DATASOURCE_PASSWORD: apollo123
      EUREKA_SERVICE_URL: http://apollo-configservice:8080/eureka/
    ports:
      - "8090:8090"
    depends_on:
      - apollo-configdb
      - apollo-configservice
    networks:
      - apollo-network

  apollo-portal:
    image: apolloconfig/apollo-portal:2.0.1
    container_name: apollo-portal
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://apollo-portaldb:3306/ApolloPortalDB?characterEncoding=utf8&serverTimezone=Asia/Shanghai
      SPRING_DATASOURCE_USERNAME: apollo
      SPRING_DATASOURCE_PASSWORD: apollo123
      APOLLO_PORTAL_ENVS: dev,test,prod
      DEV_META: http://apollo-configservice:8080
      TEST_META: http://apollo-configservice:8080
      PROD_META: http://apollo-configservice:8080
    ports:
      - "8070:8070"
    depends_on:
      - apollo-portaldb
      - apollo-configservice
      - apollo-adminservice
    networks:
      - apollo-network

volumes:
  apollo-configdb-data:
  apollo-portaldb-data:

networks:
  apollo-network:
    driver: bridge
```

### 2. 应用配置

```yaml
# application.yml
apollo:
  meta: http://localhost:8080
  bootstrap:
    enabled: true
    eagerLoad:
      enabled: true
    namespaces: application,database,redis,business
  cacheDir: /opt/data/apollo-cache
  cluster: default
  
app:
  id: nsrs-user-service
  
spring:
  application:
    name: nsrs-user-service
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
```

### 3. 配置加密服务

```java
/**
 * 配置加密服务
 */
@Service
@Slf4j
public class ConfigEncryptionService {
    
    @Value("${config.encryption.key:nsrs-config-secret-key}")
    private String encryptionKey;
    
    private final AESUtil aesUtil;
    
    public ConfigEncryptionService() {
        this.aesUtil = new AESUtil();
    }
    
    /**
     * 加密配置值
     */
    public String encrypt(String plainText) {
        try {
            if (StringUtils.hasText(plainText)) {
                return aesUtil.encrypt(plainText, encryptionKey);
            }
            return plainText;
        } catch (Exception e) {
            log.error("Failed to encrypt config value", e);
            throw new ConfigException("配置加密失败", e);
        }
    }
    
    /**
     * 解密配置值
     */
    public String decrypt(String encryptedText) {
        try {
            if (StringUtils.hasText(encryptedText)) {
                return aesUtil.decrypt(encryptedText, encryptionKey);
            }
            return encryptedText;
        } catch (Exception e) {
            log.error("Failed to decrypt config value", e);
            throw new ConfigException("配置解密失败", e);
        }
    }
    
    /**
     * 判断是否为加密配置
     */
    public boolean isEncrypted(String value) {
        return StringUtils.hasText(value) && value.startsWith("ENC(") && value.endsWith(")");
    }
}
```

## 配置管理最佳实践

### 1. 配置分层管理

```
配置层次结构：
├── 全局配置（Global）
│   ├── 基础设施配置
│   ├── 公共组件配置
│   └── 安全配置
├── 环境配置（Environment）
│   ├── 开发环境
│   ├── 测试环境
│   └── 生产环境
├── 应用配置（Application）
│   ├── 数据库配置
│   ├── 缓存配置
│   └── 业务配置
└── 实例配置（Instance）
    ├── 节点特定配置
    └── 个性化配置
```

### 2. 配置命名规范

```properties
# 数据库配置
spring.datasource.url=jdbc:mysql://localhost:3306/nsrs
spring.datasource.username=nsrs_user
spring.datasource.password=ENC(encrypted_password)

# Redis配置
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=ENC(encrypted_password)

# 业务配置
nsrs.imsi.allocation.batch.size=1000
nsrs.imsi.allocation.timeout=30000
nsrs.sim.card.status.check.interval=60000

# 第三方服务配置
third.party.sms.service.url=https://api.sms.com
third.party.sms.service.key=ENC(encrypted_api_key)
```

### 3. 配置变更流程

```
配置变更流程：
1. 配置修改 → 2. 代码审查 → 3. 测试验证 → 4. 发布上线 → 5. 监控验证

权限控制：
- 开发人员：只读权限
- 测试人员：测试环境读写权限
- 运维人员：生产环境读写权限
- 管理员：全部权限
```

## 监控与运维

### 1. 配置监控指标

```java
/**
 * 配置监控服务
 */
@Service
@Slf4j
public class ConfigMonitoringService {
    
    private final MeterRegistry meterRegistry;
    private final Counter configChangeCounter;
    private final Timer configLoadTimer;
    private final Gauge configItemGauge;
    
    public ConfigMonitoringService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.configChangeCounter = Counter.builder("config.change.count")
            .description("配置变更次数")
            .register(meterRegistry);
        this.configLoadTimer = Timer.builder("config.load.time")
            .description("配置加载耗时")
            .register(meterRegistry);
        this.configItemGauge = Gauge.builder("config.item.count")
            .description("配置项数量")
            .register(meterRegistry, this, ConfigMonitoringService::getConfigItemCount);
    }
    
    /**
     * 记录配置变更
     */
    public void recordConfigChange(String appId, String environment, String changeType) {
        configChangeCounter.increment(
            Tags.of(
                "app_id", appId,
                "environment", environment,
                "change_type", changeType
            )
        );
    }
    
    /**
     * 记录配置加载耗时
     */
    public void recordConfigLoadTime(String appId, Duration duration) {
        configLoadTimer.record(duration, 
            Tags.of("app_id", appId));
    }
    
    /**
     * 获取配置项数量
     */
    private double getConfigItemCount() {
        // 实现获取配置项数量的逻辑
        return 0.0;
    }
}
```

### 2. 告警规则

```yaml
# Prometheus告警规则
groups:
  - name: apollo.rules
    rules:
      - alert: ApolloConfigServiceDown
        expr: up{job="apollo-configservice"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "配置变更过于频繁"
          description: "配置变更频率超过阈值，可能存在异常"
      
      - alert: ConfigLoadTimeout
        expr: config_load_time > 5
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "配置加载超时"
          description: "配置加载耗时超过5秒"
```

### 3. 配置审计

```java
/**
 * 配置审计服务
 */
@Service
@Slf4j
public class ConfigAuditService {
    
    @Autowired
    private ConfigChangeLogRepository configChangeLogRepository;
    
    /**
     * 生成配置审计报告
     */
    public ConfigAuditReport generateAuditReport(String appId, 
                                                LocalDateTime startTime, 
                                                LocalDateTime endTime) {
        List<ConfigChangeLog> changeLogs = configChangeLogRepository
            .findByAppIdAndOperationTimeBetween(appId, startTime, endTime);
        
        Map<String, Long> changeTypeStats = changeLogs.stream()
            .collect(Collectors.groupingBy(
                ConfigChangeLog::getChangeType,
                Collectors.counting()));
        
        Map<String, Long> operatorStats = changeLogs.stream()
            .collect(Collectors.groupingBy(
                ConfigChangeLog::getOperator,
                Collectors.counting()));
        
        return ConfigAuditReport.builder()
            .appId(appId)
            .startTime(startTime)
            .endTime(endTime)
            .totalChanges(changeLogs.size())
            .changeTypeStats(changeTypeStats)
            .operatorStats(operatorStats)
            .changeLogs(changeLogs)
            .build();
    }
    
    /**
     * 检查配置合规性
     */
    public List<ConfigComplianceIssue> checkCompliance(String appId) {
        List<ConfigComplianceIssue> issues = new ArrayList<>();
        
        // 检查敏感配置是否加密
        List<ConfigItem> sensitiveConfigs = configItemRepository
            .findByAppIdAndSensitiveTrueAndEncryptedFalse(appId);
        
        for (ConfigItem config : sensitiveConfigs) {
            issues.add(ConfigComplianceIssue.builder()
                .type("SENSITIVE_NOT_ENCRYPTED")
                .configId(config.getId())
                .configKey(config.getKey())
                .description("敏感配置未加密")
                .severity("HIGH")
                .build());
        }
        
        // 检查配置是否有描述
        List<ConfigItem> noDescConfigs = configItemRepository
            .findByAppIdAndDescriptionIsNull(appId);
        
        for (ConfigItem config : noDescConfigs) {
            issues.add(ConfigComplianceIssue.builder()
                .type("NO_DESCRIPTION")
                .configId(config.getId())
                .configKey(config.getKey())
                .description("配置缺少描述信息")
                .severity("LOW")
                .build());
        }
        
        return issues;
    }
}
```

## 总结

通过以上配置中心架构设计，NSRS号卡资源管理系统实现了：

### 核心特性
- **集中化管理**: 统一管理所有微服务配置
- **动态更新**: 支持配置热更新，无需重启服务
- **环境隔离**: 多环境配置管理，确保环境间配置独立
- **权限控制**: 细粒度权限管理，保障配置安全
- **版本管理**: 完整的配置变更历史和回滚机制
- **高可用性**: 集群部署，保证配置服务稳定性

### 安全保障
- **配置加密**: 敏感配置自动加密存储
- **权限控制**: 基于角色的配置访问控制
- **审计追踪**: 完整的配置变更审计日志
- **合规检查**: 自动化配置合规性检查

### 运维支持
- **监控告警**: 全面的配置服务监控指标
- **自动化部署**: 基于Docker的一键部署
- **故障恢复**: 自动故障检测和恢复机制
- **性能优化**: 配置缓存和批量操作优化

配置中心作为微服务架构的重要基础设施，为NSRS系统提供了稳定、安全、高效的配置管理能力，支撑业务的快速发展和运维效率的提升。 "Apollo配置服务不可用"
          description: "Apollo配置服务已停止响应"
      
      - alert: ConfigChangeFrequent
        expr: rate(config_change_count[5m]) > 10
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: