# 链路追踪架构设计详解

基于SkyWalking的NSRS号卡资源管理系统链路追踪解决方案

## 目录

- [链路追踪概述](#链路追踪概述)
- [核心组件设计](#核心组件设计)
- [SkyWalking集成](#skywalking集成)
- [业务场景应用](#业务场景应用)
- [性能监控](#性能监控)
- [告警配置](#告警配置)
- [最佳实践](#最佳实践)

## 链路追踪概述

### 设计目标

- **全链路监控**: 跟踪请求在微服务间的完整调用链路
- **性能分析**: 识别系统瓶颈和性能问题
- **故障定位**: 快速定位分布式系统中的故障点
- **依赖分析**: 分析服务间的依赖关系
- **容量规划**: 基于链路数据进行容量规划

### 架构图

```
NSRS链路追踪架构：

┌─────────────────────────────────────────────────────────────┐
│                      用户请求                                │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────────┐
│                   API网关                                   │
│              (TraceId生成)                                  │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
┌───────▼──────┐ ┌───▼────┐ ┌──────▼──────┐
│ User Service │ │IMSI Svc│ │MSISDN Svc   │
│ (Span A)     │ │(Span B)│ │(Span C)     │
└──────┬───────┘ └───┬────┘ └──────┬──────┘
       │             │             │
┌──────▼──────┐ ┌───▼────┐ ┌──────▼──────┐
│ SIM Service │ │Bill Svc│ │Report Svc   │
│ (Span D)    │ │(Span E)│ │(Span F)     │
└─────────────┘ └────────┘ └─────────────┘
       │             │             │
┌──────▼─────────────▼─────────────▼──────┐
│              SkyWalking OAP              │
│           (数据收集与分析)                │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│            SkyWalking UI                │
│         (链路可视化展示)                 │
└─────────────────────────────────────────┘
```

## 核心组件设计

### 1. 链路追踪枚举

```java
/**
 * 链路追踪类型
 */
public enum TraceType {
    HTTP_REQUEST("HTTP_REQUEST", "HTTP请求"),
    RPC_CALL("RPC_CALL", "RPC调用"),
    DATABASE_QUERY("DATABASE_QUERY", "数据库查询"),
    CACHE_OPERATION("CACHE_OPERATION", "缓存操作"),
    MESSAGE_QUEUE("MESSAGE_QUEUE", "消息队列"),
    EXTERNAL_API("EXTERNAL_API", "外部API调用");
    
    private final String code;
    private final String description;
    
    TraceType(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}

/**
 * Span状态
 */
public enum SpanStatus {
    SUCCESS("SUCCESS", "成功"),
    ERROR("ERROR", "错误"),
    TIMEOUT("TIMEOUT", "超时"),
    CANCELLED("CANCELLED", "取消");
    
    private final String code;
    private final String description;
    
    SpanStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }
    
    // getters...
}
```

### 2. 链路追踪实体

```java
/**
 * 链路追踪记录
 */
@Entity
@Table(name = "trace_record")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TraceRecord {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * 链路ID
     */
    @Column(name = "trace_id", nullable = false, length = 64)
    private String traceId;
    
    /**
     * Span ID
     */
    @Column(name = "span_id", nullable = false, length = 64)
    private String spanId;
    
    /**
     * 父Span ID
     */
    @Column(name = "parent_span_id", length = 64)
    private String parentSpanId;
    
    /**
     * 服务名称
     */
    @Column(name = "service_name", nullable = false, length = 100)
    private String serviceName;
    
    /**
     * 操作名称
     */
    @Column(name = "operation_name", nullable = false, length = 200)
    private String operationName;
    
    /**
     * 追踪类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "trace_type", nullable = false)
    private TraceType traceType;
    
    /**
     * 开始时间
     */
    @Column(name = "start_time", nullable = false)
    private LocalDateTime startTime;
    
    /**
     * 结束时间
     */
    @Column(name = "end_time")
    private LocalDateTime endTime;
    
    /**
     * 耗时(毫秒)
     */
    @Column(name = "duration")
    private Long duration;
    
    /**
     * Span状态
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private SpanStatus status;
    
    /**
     * 标签信息(JSON格式)
     */
    @Column(name = "tags", columnDefinition = "TEXT")
    private String tags;
    
    /**
     * 日志信息(JSON格式)
     */
    @Column(name = "logs", columnDefinition = "TEXT")
    private String logs;
    
    /**
     * 错误信息
     */
    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;
    
    /**
     * 创建时间
     */
    @Column(name = "create_time", nullable = false)
    private LocalDateTime createTime;
}
```

## SkyWalking集成

### 1. SkyWalking集群部署

```yaml
# docker-compose-skywalking.yml
version: '3.8'

services:
  # Elasticsearch存储
  elasticsearch:
    image: elasticsearch:7.17.0
    container_name: skywalking-elasticsearch
    environment:
      - discovery.type=single-node
      - bootstrap.memory_lock=true
      - "ES_JAVA_OPTS=-Xms2g -Xmx2g"
      - xpack.security.enabled=false
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - skywalking-es-data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - skywalking-network

  # SkyWalking OAP Server
  skywalking-oap:
    image: apache/skywalking-oap-server:9.3.0
    container_name: skywalking-oap
    environment:
      - SW_STORAGE=elasticsearch
      - SW_STORAGE_ES_CLUSTER_NODES=elasticsearch:9200
      - SW_HEALTH_CHECKER=default
      - SW_TELEMETRY=prometheus
      - JAVA_OPTS=-Xms2g -Xmx2g
    ports:
      - "11800:11800"
      - "12800:12800"
    depends_on:
      - elasticsearch
    networks:
      - skywalking-network
    volumes:
      - ./skywalking/config:/skywalking/config

  # SkyWalking UI
  skywalking-ui:
    image: apache/skywalking-ui:9.3.0
    container_name: skywalking-ui
    environment:
      - SW_OAP_ADDRESS=http://skywalking-oap:12800
    ports:
      - "8080:8080"
    depends_on:
      - skywalking-oap
    networks:
      - skywalking-network

volumes:
  skywalking-es-data:

networks:
  skywalking-network:
    driver: bridge
```

### 2. 应用集成配置

```yaml
# application.yml
spring:
  application:
    name: nsrs-imsi-service

# SkyWalking配置
skywalking:
  agent:
    service_name: nsrs-imsi-service
    collector:
      backend_service: skywalking-oap:11800
    logging:
      level: INFO
    plugin:
      toolkit:
        log:
          transmit_formatted: true
```

### 3. 自定义链路追踪

```java
/**
 * 链路追踪服务
 */
@Service
@Slf4j
public class TraceService {
    
    @Autowired
    private TraceRecordRepository traceRecordRepository;
    
    /**
     * 创建自定义Span
     */
    @Trace
    @Tag(key = "operation", value = "arg[0]")
    public void createCustomSpan(String operation, Map<String, Object> tags) {
        ActiveSpan span = SkywalkingTracer.createLocalSpan(operation);
        
        try {
            // 添加标签
            if (tags != null) {
                tags.forEach((key, value) -> 
                    span.tag(Tags.ofKey(key), String.valueOf(value)));
            }
            
            // 记录日志
            span.log(System.currentTimeMillis(), 
                Map.of("event", "custom_operation", "operation", operation));
            
            // 业务逻辑处理
            processBusinessLogic(operation);
            
        } catch (Exception e) {
            // 记录错误
            span.errorOccurred();
            span.log(System.currentTimeMillis(), 
                Map.of("event", "error", "error.object", e, 
                       "message", e.getMessage()));
            throw e;
        } finally {
            SkywalkingTracer.stopSpan();
        }
    }
    
    /**
     * 异步操作追踪
     */
    @Async
    @Trace
    public CompletableFuture<Void> asyncOperation(String operation) {
        return CompletableFuture.runAsync(() -> {
            ActiveSpan span = SkywalkingTracer.createLocalSpan("async_" + operation);
            
            try {
                span.tag(Tags.ofKey("async"), "true");
                span.tag(Tags.ofKey("thread"), Thread.currentThread().getName());
                
                // 异步业务逻辑
                Thread.sleep(1000);
                log.info("异步操作完成: {}", operation);
                
            } catch (Exception e) {
                span.errorOccurred();
                log.error("异步操作失败: {}", operation, e);
            } finally {
                SkywalkingTracer.stopSpan();
            }
        });
    }
    
    private void processBusinessLogic(String operation) {
        // 模拟业务处理
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

## 业务场景应用

### 1. IMSI资源分配链路追踪

```java
/**
 * IMSI资源分配服务
 */
@Service
@Slf4j
public class ImsiAllocationService {
    
    @Autowired
    private ImsiResourceRepository imsiResourceRepository;
    
    @Autowired
    private TraceService traceService;
    
    /**
     * 分配IMSI资源
     */
    @Trace
    @Tag(key = "business", value = "imsi_allocation")
    public ImsiAllocationResult allocateImsi(ImsiAllocationRequest request) {
        String traceId = TraceContext.traceId();
        log.info("开始分配IMSI资源, traceId: {}, request: {}", traceId, request);
        
        ActiveSpan span = SkywalkingTracer.createLocalSpan("imsi_allocation");
        
        try {
            // 添加业务标签
            span.tag(Tags.ofKey("supplier_id"), request.getSupplierId());
            span.tag(Tags.ofKey("quantity"), String.valueOf(request.getQuantity()));
            span.tag(Tags.ofKey("region"), request.getRegion());
            
            // 1. 检查供应商资源
            checkSupplierResource(request.getSupplierId(), request.getQuantity());
            
            // 2. 分配IMSI号段
            List<String> allocatedImsis = allocateImsiNumbers(request);
            
            // 3. 更新资源状态
            updateResourceStatus(allocatedImsis, request.getSupplierId());
            
            // 4. 记录分配日志
            recordAllocationLog(request, allocatedImsis);
            
            ImsiAllocationResult result = ImsiAllocationResult.builder()
                .traceId(traceId)
                .allocatedImsis(allocatedImsis)
                .quantity(allocatedImsis.size())
                .supplierId(request.getSupplierId())
                .build();
            
            span.tag(Tags.ofKey("allocated_count"), String.valueOf(allocatedImsis.size()));
            span.log(System.currentTimeMillis(), 
                Map.of("event", "allocation_success", 
                       "allocated_count", allocatedImsis.size()));
            
            log.info("IMSI资源分配成功, traceId: {}, result: {}", traceId, result);
            return result;
            
        } catch (Exception e) {
            span.errorOccurred();
            span.log(System.currentTimeMillis(), 
                Map.of("event", "allocation_error", 
                       "error.object", e,
                       "message", e.getMessage()));
            
            log.error("IMSI资源分配失败, traceId: {}, error: {}", traceId, e.getMessage(), e);
            throw new ImsiAllocationException("IMSI资源分配失败: " + e.getMessage(), e);
        } finally {
            SkywalkingTracer.stopSpan();
        }
    }
    
    @Trace
    private void checkSupplierResource(String supplierId, Integer quantity) {
        // 检查供应商资源逻辑
    }
    
    @Trace
    private List<String> allocateImsiNumbers(ImsiAllocationRequest request) {
        // 分配IMSI号码逻辑
        return new ArrayList<>();
    }
    
    @Trace
    private void updateResourceStatus(List<String> imsis, String supplierId) {
        // 更新资源状态逻辑
    }
    
    @Trace
    private void recordAllocationLog(ImsiAllocationRequest request, List<String> allocatedImsis) {
        // 记录分配日志逻辑
    }
}
```

### 2. 链路追踪控制器

```java
/**
 * 链路追踪管理控制器
 */
@RestController
@RequestMapping("/api/v1/trace")
@Slf4j
public class TraceController {
    
    @Autowired
    private TraceService traceService;
    
    /**
     * 查询链路追踪记录
     */
    @GetMapping("/records")
    public Result<Page<TraceRecord>> getTraceRecords(
            @RequestParam(required = false) String traceId,
            @RequestParam(required = false) String serviceName,
            @RequestParam(required = false) TraceType traceType,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        
        Pageable pageable = PageRequest.of(page, size);
        Page<TraceRecord> records = traceService.getTraceRecords(
            traceId, serviceName, traceType, pageable);
        
        return Result.success(records);
    }
    
    /**
     * 获取链路详情
     */
    @GetMapping("/detail/{traceId}")
    public Result<TraceDetail> getTraceDetail(@PathVariable String traceId) {
        TraceDetail detail = traceService.getTraceDetail(traceId);
        return Result.success(detail);
    }
    
    /**
     * 获取服务依赖关系
     */
    @GetMapping("/dependencies")
    public Result<List<ServiceDependency>> getServiceDependencies(
            @RequestParam(required = false) String serviceName,
            @RequestParam(defaultValue = "24") int hours) {
        
        List<ServiceDependency> dependencies = traceService
            .getServiceDependencies(serviceName, hours);
        return Result.success(dependencies);
    }
    
    /**
     * 获取性能统计
     */
    @GetMapping("/performance")
    public Result<PerformanceStats> getPerformanceStats(
            @RequestParam String serviceName,
            @RequestParam(defaultValue = "1") int hours) {
        
        PerformanceStats stats = traceService
            .getPerformanceStats(serviceName, hours);
        return Result.success(stats);
    }
}
```

## 性能监控

### 1. 性能指标收集

```java
/**
 * 性能监控服务
 */
@Service
@Slf4j
public class PerformanceMonitoringService {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    private final Timer.Sample sample;
    
    /**
     * 记录请求耗时
     */
    public void recordRequestDuration(String serviceName, String operation, long duration) {
        Timer.builder("request_duration")
            .tag("service", serviceName)
            .tag("operation", operation)
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    /**
     * 记录错误计数
     */
    public void recordError(String serviceName, String operation, String errorType) {
        Counter.builder("request_errors")
            .tag("service", serviceName)
            .tag("operation", operation)
            .tag("error_type", errorType)
            .register(meterRegistry)
            .increment();
    }
    
    /**
     * 记录吞吐量
     */
    public void recordThroughput(String serviceName, String operation) {
        Counter.builder("request_total")
            .tag("service", serviceName)
            .tag("operation", operation)
            .register(meterRegistry)
            .increment();
    }
    
    /**
     * 获取性能统计
     */
    public PerformanceStats getPerformanceStats(String serviceName, int hours) {
        LocalDateTime endTime = LocalDateTime.now();
        LocalDateTime startTime = endTime.minusHours(hours);
        
        // 查询平均响应时间
        double avgDuration = getAverageResponseTime(serviceName, startTime, endTime);
        
        // 查询错误率
        double errorRate = getErrorRate(serviceName, startTime, endTime);
        
        // 查询吞吐量
        long throughput = getThroughput(serviceName, startTime, endTime);
        
        return PerformanceStats.builder()
            .serviceName(serviceName)
            .avgResponseTime(avgDuration)
            .errorRate(errorRate)
            .throughput(throughput)
            .startTime(startTime)
            .endTime(endTime)
            .build();
    }
    
    private double getAverageResponseTime(String serviceName, 
                                        LocalDateTime startTime, 
                                        LocalDateTime endTime) {
        // 从监控系统查询平均响应时间
        return 0.0;
    }
    
    private double getErrorRate(String serviceName, 
                              LocalDateTime startTime, 
                              LocalDateTime endTime) {
        // 从监控系统查询错误率
        return 0.0;
    }
    
    private long getThroughput(String serviceName, 
                             LocalDateTime startTime, 
                             LocalDateTime endTime) {
        // 从监控系统查询吞吐量
        return 0L;
    }
}
```

## 告警配置

### 1. Prometheus告警规则

```yaml
# skywalking-alerts.yml
groups:
  - name: skywalking-alerts
    rules:
      - alert: ServiceResponseTimeHigh
        expr: skywalking_service_resp_time{quantile="0.95"} > 1000
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "服务响应时间过高"
          description: "服务 {{ $labels.service }} 95%响应时间超过1秒"
      
      - alert: ServiceErrorRateHigh
        expr: skywalking_service_sla < 0.95
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "服务错误率过高"
          description: "服务 {{ $labels.service }} SLA低于95%"
      
      - alert: ServiceInstanceDown
        expr: skywalking_service_instance_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "服务实例下线"
          description: "服务实例 {{ $labels.instance }} 已下线"
```

## 最佳实践

### 1. 采样策略

```yaml
# 采样配置
skywalking:
  agent:
    sample_n_per_3_secs: 3  # 每3秒采样3个请求
    namespace: nsrs-prod
    instance_name: ${spring.application.name}-${server.port}
```

### 2. 性能优化

- **异步上报**: 使用异步方式上报链路数据
- **批量发送**: 批量发送链路数据减少网络开销
- **本地缓存**: 使用本地缓存减少重复计算
- **采样控制**: 合理设置采样率平衡性能和监控精度

### 3. 数据治理

- **数据保留**: 设置合理的数据保留期限
- **索引优化**: 优化Elasticsearch索引提升查询性能
- **存储压缩**: 启用数据压缩节省存储空间
- **定期清理**: 定期清理过期数据

通过以上链路追踪架构设计，NSRS系统实现了完整的分布式链路监控能力，为系统性能优化和故障排查提供了强有力的支持。